<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "917dbf890db71a322f306050cb284749",
  "translation_date": "2025-09-04T23:46:59+00:00",
  "source_file": "7-TimeSeries/2-ARIMA/README.md",
  "language_code": "el"
}
-->
# Πρόβλεψη χρονοσειρών με ARIMA

Στο προηγούμενο μάθημα, μάθατε λίγα πράγματα για την πρόβλεψη χρονοσειρών και φορτώσατε ένα σύνολο δεδομένων που δείχνει τις διακυμάνσεις του ηλεκτρικού φορτίου σε μια χρονική περίοδο.

[![Εισαγωγή στο ARIMA](https://img.youtube.com/vi/IUSk-YDau10/0.jpg)](https://youtu.be/IUSk-YDau10 "Εισαγωγή στο ARIMA")

> 🎥 Κάντε κλικ στην εικόνα παραπάνω για ένα βίντεο: Μια σύντομη εισαγωγή στα μοντέλα ARIMA. Το παράδειγμα γίνεται σε R, αλλά οι έννοιες είναι καθολικές.

## [Κουίζ πριν το μάθημα](https://ff-quizzes.netlify.app/en/ml/)

## Εισαγωγή

Σε αυτό το μάθημα, θα ανακαλύψετε έναν συγκεκριμένο τρόπο για να δημιουργήσετε μοντέλα με [ARIMA: *A*uto*R*egressive *I*ntegrated *M*oving *A*verage](https://wikipedia.org/wiki/Autoregressive_integrated_moving_average). Τα μοντέλα ARIMA είναι ιδιαίτερα κατάλληλα για δεδομένα που παρουσιάζουν [μη στασιμότητα](https://wikipedia.org/wiki/Stationary_process).

## Γενικές έννοιες

Για να μπορέσετε να εργαστείτε με το ARIMA, υπάρχουν κάποιες έννοιες που πρέπει να γνωρίζετε:

- 🎓 **Στασιμότητα**. Από στατιστική άποψη, η στασιμότητα αναφέρεται σε δεδομένα των οποίων η κατανομή δεν αλλάζει όταν μετατοπίζονται χρονικά. Τα μη σταθερά δεδομένα, λοιπόν, παρουσιάζουν διακυμάνσεις λόγω τάσεων που πρέπει να μετασχηματιστούν για να αναλυθούν. Η εποχικότητα, για παράδειγμα, μπορεί να εισάγει διακυμάνσεις στα δεδομένα και μπορεί να εξαλειφθεί μέσω μιας διαδικασίας 'εποχικής διαφοροποίησης'.

- 🎓 **[Διαφοροποίηση](https://wikipedia.org/wiki/Autoregressive_integrated_moving_average#Differencing)**. Η διαφοροποίηση δεδομένων, πάλι από στατιστική άποψη, αναφέρεται στη διαδικασία μετασχηματισμού μη σταθερών δεδομένων ώστε να γίνουν σταθερά, αφαιρώντας την μη σταθερή τάση τους. "Η διαφοροποίηση αφαιρεί τις αλλαγές στο επίπεδο μιας χρονοσειράς, εξαλείφοντας την τάση και την εποχικότητα και, κατά συνέπεια, σταθεροποιώντας τον μέσο όρο της χρονοσειράς." [Έγγραφο από Shixiong et al](https://arxiv.org/abs/1904.07632)

## ARIMA στο πλαίσιο των χρονοσειρών

Ας αναλύσουμε τα μέρη του ARIMA για να κατανοήσουμε καλύτερα πώς μας βοηθά να μοντελοποιήσουμε χρονοσειρές και να κάνουμε προβλέψεις.

- **AR - για AutoRegressive**. Τα αυτοπαλινδρομικά μοντέλα, όπως υποδηλώνει το όνομα, κοιτάζουν 'πίσω' στον χρόνο για να αναλύσουν προηγούμενες τιμές στα δεδομένα σας και να κάνουν υποθέσεις γι' αυτές. Αυτές οι προηγούμενες τιμές ονομάζονται 'lags'. Ένα παράδειγμα θα ήταν δεδομένα που δείχνουν μηνιαίες πωλήσεις μολυβιών. Το σύνολο πωλήσεων κάθε μήνα θα θεωρούνταν 'μεταβαλλόμενη μεταβλητή' στο σύνολο δεδομένων. Αυτό το μοντέλο κατασκευάζεται καθώς η "μεταβαλλόμενη μεταβλητή ενδιαφέροντος παλινδρομείται στις δικές της καθυστερημένες (δηλαδή, προηγούμενες) τιμές." [wikipedia](https://wikipedia.org/wiki/Autoregressive_integrated_moving_average)

- **I - για Integrated**. Σε αντίθεση με τα παρόμοια μοντέλα 'ARMA', το 'I' στο ARIMA αναφέρεται στην *[ενσωματωμένη](https://wikipedia.org/wiki/Order_of_integration)* πτυχή του. Τα δεδομένα 'ενσωματώνονται' όταν εφαρμόζονται βήματα διαφοροποίησης για την εξάλειψη της μη στασιμότητας.

- **MA - για Moving Average**. Η πτυχή [κινούμενου μέσου](https://wikipedia.org/wiki/Moving-average_model) αυτού του μοντέλου αναφέρεται στη μεταβλητή εξόδου που καθορίζεται παρατηρώντας τις τρέχουσες και προηγούμενες τιμές των lags.

Συμπέρασμα: Το ARIMA χρησιμοποιείται για να κάνει ένα μοντέλο να ταιριάζει όσο το δυνατόν καλύτερα στη συγκεκριμένη μορφή δεδομένων χρονοσειρών.

## Άσκηση - δημιουργία μοντέλου ARIMA

Ανοίξτε τον φάκελο [_/working_](https://github.com/microsoft/ML-For-Beginners/tree/main/7-TimeSeries/2-ARIMA/working) σε αυτό το μάθημα και βρείτε το αρχείο [_notebook.ipynb_](https://github.com/microsoft/ML-For-Beginners/blob/main/7-TimeSeries/2-ARIMA/working/notebook.ipynb).

1. Εκτελέστε το notebook για να φορτώσετε τη βιβλιοθήκη Python `statsmodels`. Θα χρειαστείτε αυτήν για τα μοντέλα ARIMA.

1. Φορτώστε τις απαραίτητες βιβλιοθήκες.

1. Τώρα, φορτώστε μερικές ακόμη βιβλιοθήκες χρήσιμες για την απεικόνιση δεδομένων:

    ```python
    import os
    import warnings
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    import datetime as dt
    import math

    from pandas.plotting import autocorrelation_plot
    from statsmodels.tsa.statespace.sarimax import SARIMAX
    from sklearn.preprocessing import MinMaxScaler
    from common.utils import load_data, mape
    from IPython.display import Image

    %matplotlib inline
    pd.options.display.float_format = '{:,.2f}'.format
    np.set_printoptions(precision=2)
    warnings.filterwarnings("ignore") # specify to ignore warning messages
    ```

1. Φορτώστε τα δεδομένα από το αρχείο `/data/energy.csv` σε ένα dataframe Pandas και δείτε τα:

    ```python
    energy = load_data('./data')[['load']]
    energy.head(10)
    ```

1. Απεικονίστε όλα τα διαθέσιμα δεδομένα ενέργειας από τον Ιανουάριο του 2012 έως τον Δεκέμβριο του 2014. Δεν θα πρέπει να υπάρχουν εκπλήξεις καθώς είδαμε αυτά τα δεδομένα στο προηγούμενο μάθημα:

    ```python
    energy.plot(y='load', subplots=True, figsize=(15, 8), fontsize=12)
    plt.xlabel('timestamp', fontsize=12)
    plt.ylabel('load', fontsize=12)
    plt.show()
    ```

    Τώρα, ας δημιουργήσουμε ένα μοντέλο!

### Δημιουργία συνόλων δεδομένων εκπαίδευσης και δοκιμής

Τώρα που τα δεδομένα σας έχουν φορτωθεί, μπορείτε να τα χωρίσετε σε σύνολα εκπαίδευσης και δοκιμής. Θα εκπαιδεύσετε το μοντέλο σας στο σύνολο εκπαίδευσης. Όπως συνήθως, αφού το μοντέλο ολοκληρώσει την εκπαίδευση, θα αξιολογήσετε την ακρίβειά του χρησιμοποιώντας το σύνολο δοκιμής. Πρέπει να βεβαιωθείτε ότι το σύνολο δοκιμής καλύπτει μια μεταγενέστερη χρονική περίοδο από το σύνολο εκπαίδευσης, ώστε να διασφαλίσετε ότι το μοντέλο δεν αποκτά πληροφορίες από μελλοντικές χρονικές περιόδους.

1. Κατανομή μιας περιόδου δύο μηνών από την 1η Σεπτεμβρίου έως την 31η Οκτωβρίου 2014 στο σύνολο εκπαίδευσης. Το σύνολο δοκιμής θα περιλαμβάνει την περίοδο δύο μηνών από την 1η Νοεμβρίου έως την 31η Δεκεμβρίου 2014:

    ```python
    train_start_dt = '2014-11-01 00:00:00'
    test_start_dt = '2014-12-30 00:00:00'
    ```

    Δεδομένου ότι αυτά τα δεδομένα αντικατοπτρίζουν την ημερήσια κατανάλωση ενέργειας, υπάρχει ένα ισχυρό εποχικό μοτίβο, αλλά η κατανάλωση είναι πιο παρόμοια με την κατανάλωση των πιο πρόσφατων ημερών.

1. Οπτικοποιήστε τις διαφορές:

    ```python
    energy[(energy.index < test_start_dt) & (energy.index >= train_start_dt)][['load']].rename(columns={'load':'train'}) \
        .join(energy[test_start_dt:][['load']].rename(columns={'load':'test'}), how='outer') \
        .plot(y=['train', 'test'], figsize=(15, 8), fontsize=12)
    plt.xlabel('timestamp', fontsize=12)
    plt.ylabel('load', fontsize=12)
    plt.show()
    ```

    ![δεδομένα εκπαίδευσης και δοκιμής](../../../../7-TimeSeries/2-ARIMA/images/train-test.png)

    Επομένως, η χρήση ενός σχετικά μικρού χρονικού παραθύρου για την εκπαίδευση των δεδομένων θα πρέπει να είναι επαρκής.

    > Σημείωση: Δεδομένου ότι η συνάρτηση που χρησιμοποιούμε για την προσαρμογή του μοντέλου ARIMA χρησιμοποιεί επικύρωση εντός δείγματος κατά την προσαρμογή, θα παραλείψουμε τα δεδομένα επικύρωσης.

### Προετοιμασία των δεδομένων για εκπαίδευση

Τώρα, πρέπει να προετοιμάσετε τα δεδομένα για εκπαίδευση, εκτελώντας φιλτράρισμα και κλιμάκωση των δεδομένων σας. Φιλτράρετε το σύνολο δεδομένων σας ώστε να περιλαμβάνει μόνο τις χρονικές περιόδους και τις στήλες που χρειάζεστε, και κλιμακώστε τα δεδομένα ώστε να προβάλλονται στο διάστημα 0,1.

1. Φιλτράρετε το αρχικό σύνολο δεδομένων ώστε να περιλαμβάνει μόνο τις προαναφερθείσες χρονικές περιόδους ανά σύνολο και μόνο τη στήλη 'load' που χρειάζεται, συν την ημερομηνία:

    ```python
    train = energy.copy()[(energy.index >= train_start_dt) & (energy.index < test_start_dt)][['load']]
    test = energy.copy()[energy.index >= test_start_dt][['load']]

    print('Training data shape: ', train.shape)
    print('Test data shape: ', test.shape)
    ```

    Μπορείτε να δείτε το σχήμα των δεδομένων:

    ```output
    Training data shape:  (1416, 1)
    Test data shape:  (48, 1)
    ```

1. Κλιμακώστε τα δεδομένα ώστε να βρίσκονται στο εύρος (0, 1).

    ```python
    scaler = MinMaxScaler()
    train['load'] = scaler.fit_transform(train)
    train.head(10)
    ```

1. Οπτικοποιήστε τα αρχικά δεδομένα σε σύγκριση με τα κλιμακωμένα δεδομένα:

    ```python
    energy[(energy.index >= train_start_dt) & (energy.index < test_start_dt)][['load']].rename(columns={'load':'original load'}).plot.hist(bins=100, fontsize=12)
    train.rename(columns={'load':'scaled load'}).plot.hist(bins=100, fontsize=12)
    plt.show()
    ```

    ![αρχικά](../../../../7-TimeSeries/2-ARIMA/images/original.png)

    > Τα αρχικά δεδομένα

    ![κλιμακωμένα](../../../../7-TimeSeries/2-ARIMA/images/scaled.png)

    > Τα κλιμακωμένα δεδομένα

1. Τώρα που έχετε βαθμονομήσει τα κλιμακωμένα δεδομένα, μπορείτε να κλιμακώσετε τα δεδομένα δοκιμής:

    ```python
    test['load'] = scaler.transform(test)
    test.head()
    ```

### Υλοποίηση ARIMA

Ήρθε η ώρα να υλοποιήσετε το ARIMA! Τώρα θα χρησιμοποιήσετε τη βιβλιοθήκη `statsmodels` που εγκαταστήσατε νωρίτερα.

Τώρα πρέπει να ακολουθήσετε αρκετά βήματα:

   1. Ορίστε το μοντέλο καλώντας τη συνάρτηση `SARIMAX()` και περνώντας τις παραμέτρους του μοντέλου: τις παραμέτρους p, d και q, καθώς και τις παραμέτρους P, D και Q.
   2. Προετοιμάστε το μοντέλο για τα δεδομένα εκπαίδευσης καλώντας τη συνάρτηση fit().
   3. Κάντε προβλέψεις καλώντας τη συνάρτηση `forecast()` και καθορίζοντας τον αριθμό βημάτων (τον `ορίζοντα`) για πρόβλεψη.

> 🎓 Τι σημαίνουν όλες αυτές οι παράμετροι; Σε ένα μοντέλο ARIMA υπάρχουν 3 παράμετροι που χρησιμοποιούνται για να βοηθήσουν στη μοντελοποίηση των κύριων πτυχών μιας χρονοσειράς: εποχικότητα, τάση και θόρυβος. Αυτές οι παράμετροι είναι:

`p`: η παράμετρος που σχετίζεται με την αυτοπαλινδρομική πτυχή του μοντέλου, η οποία ενσωματώνει *παρελθοντικές* τιμές.
`d`: η παράμετρος που σχετίζεται με την ενσωματωμένη πτυχή του μοντέλου, η οποία επηρεάζει την ποσότητα *διαφοροποίησης* (🎓 θυμηθείτε τη διαφοροποίηση 👆;) που εφαρμόζεται σε μια χρονοσειρά.
`q`: η παράμετρος που σχετίζεται με την πτυχή του κινούμενου μέσου του μοντέλου.

> Σημείωση: Εάν τα δεδομένα σας έχουν εποχική πτυχή - όπως αυτά εδώ - , χρησιμοποιούμε ένα εποχικό μοντέλο ARIMA (SARIMA). Σε αυτήν την περίπτωση, πρέπει να χρησιμοποιήσετε ένα άλλο σύνολο παραμέτρων: `P`, `D` και `Q`, που περιγράφουν τις ίδιες συσχετίσεις με τις `p`, `d` και `q`, αλλά αντιστοιχούν στις εποχικές συνιστώσες του μοντέλου.

1. Ξεκινήστε ορίζοντας την προτιμώμενη τιμή ορίζοντα. Ας δοκιμάσουμε 3 ώρες:

    ```python
    # Specify the number of steps to forecast ahead
    HORIZON = 3
    print('Forecasting horizon:', HORIZON, 'hours')
    ```

    Η επιλογή των καλύτερων τιμών για τις παραμέτρους ενός μοντέλου ARIMA μπορεί να είναι δύσκολη, καθώς είναι κάπως υποκειμενική και χρονοβόρα. Μπορείτε να εξετάσετε τη χρήση της συνάρτησης `auto_arima()` από τη βιβλιοθήκη [`pyramid`](https://alkaline-ml.com/pmdarima/0.9.0/modules/generated/pyramid.arima.auto_arima.html).

1. Προς το παρόν, δοκιμάστε μερικές χειροκίνητες επιλογές για να βρείτε ένα καλό μοντέλο.

    ```python
    order = (4, 1, 0)
    seasonal_order = (1, 1, 0, 24)

    model = SARIMAX(endog=train, order=order, seasonal_order=seasonal_order)
    results = model.fit()

    print(results.summary())
    ```

    Ένας πίνακας αποτελεσμάτων εκτυπώνεται.

Δημιουργήσατε το πρώτο σας μοντέλο! Τώρα πρέπει να βρούμε έναν τρόπο να το αξιολογήσουμε.

### Αξιολόγηση του μοντέλου σας

Για να αξιολογήσετε το μοντέλο σας, μπορείτε να εκτελέσετε την λεγόμενη επικύρωση `walk forward`. Στην πράξη, τα μοντέλα χρονοσειρών επανεκπαιδεύονται κάθε φορά που γίνονται διαθέσιμα νέα δεδομένα. Αυτό επιτρέπει στο μοντέλο να κάνει την καλύτερη πρόβλεψη σε κάθε χρονικό βήμα.

Ξεκινώντας από την αρχή της χρονοσειράς χρησιμοποιώντας αυτήν την τεχνική, εκπαιδεύστε το μοντέλο στο σύνολο δεδομένων εκπαίδευσης. Στη συνέχεια, κάντε μια πρόβλεψη για το επόμενο χρονικό βήμα. Η πρόβλεψη αξιολογείται σε σχέση με την γνωστή τιμή. Το σύνολο εκπαίδευσης επεκτείνεται στη συνέχεια ώστε να περιλαμβάνει την γνωστή τιμή και η διαδικασία επαναλαμβάνεται.

> Σημείωση: Θα πρέπει να διατηρείτε το παράθυρο του συνόλου εκπαίδευσης σταθερό για πιο αποτελεσματική εκπαίδευση, ώστε κάθε φορά που προσθέτετε μια νέα παρατήρηση στο σύνολο εκπαίδευσης, να αφαιρείτε την παρατήρηση από την αρχή του συνόλου.

Αυτή η διαδικασία παρέχει μια πιο αξιόπιστη εκτίμηση του πώς θα αποδίδει το μοντέλο στην πράξη. Ωστόσο, έχει το υπολογιστικό κόστος της δημιουργίας τόσων πολλών μοντέλων. Αυτό είναι αποδεκτό εάν τα δεδομένα είναι μικρά ή εάν το μοντέλο είναι απλό, αλλά θα μπορούσε να είναι πρόβλημα σε μεγαλύτερη κλίμακα.

Η επικύρωση walk-forward είναι το χρυσό πρότυπο για την αξιολόγηση μοντέλων χρονοσειρών και συνιστάται για τα δικά σας έργα.

1. Πρώτα, δημιουργήστε ένα σημείο δεδομένων δοκιμής για κάθε βήμα HORIZON.

    ```python
    test_shifted = test.copy()

    for t in range(1, HORIZON+1):
        test_shifted['load+'+str(t)] = test_shifted['load'].shift(-t, freq='H')

    test_shifted = test_shifted.dropna(how='any')
    test_shifted.head(5)
    ```

    |            |          | load | load+1 | load+2 |
    | ---------- | -------- | ---- | ------ | ------ |
    | 2014-12-30 | 00:00:00 | 0.33 | 0.29   | 0.27   |
    | 2014-12-30 | 01:00:00 | 0.29 | 0.27   | 0.27   |
    | 2014-12-30 | 02:00:00 | 0.27 | 0.27   | 0.30   |
    | 2014-12-30 | 03:00:00 | 0.27 | 0.30   | 0.41   |
    | 2014-12-30 | 04:00:00 | 0.30 | 0.41   | 0.57   |

    Τα δεδομένα μετατοπίζονται οριζόντια σύμφωνα με το σημείο ορίζοντα.

1. Κάντε προβλέψεις στα δεδομένα δοκιμής σας χρησιμοποιώντας αυτήν την προσέγγιση με συρόμενο παράθυρο σε έναν βρόχο με μέγεθος ίσο με το μήκος των δεδομένων δοκιμής:

    ```python
    %%time
    training_window = 720 # dedicate 30 days (720 hours) for training

    train_ts = train['load']
    test_ts = test_shifted

    history = [x for x in train_ts]
    history = history[(-training_window):]

    predictions = list()

    order = (2, 1, 0)
    seasonal_order = (1, 1, 0, 24)

    for t in range(test_ts.shape[0]):
        model = SARIMAX(endog=history, order=order, seasonal_order=seasonal_order)
        model_fit = model.fit()
        yhat = model_fit.forecast(steps = HORIZON)
        predictions.append(yhat)
        obs = list(test_ts.iloc[t])
        # move the training window
        history.append(obs[0])
        history.pop(0)
        print(test_ts.index[t])
        print(t+1, ': predicted =', yhat, 'expected =', obs)
    ```

    Μπορείτε να παρακολουθήσετε την εκπαίδευση που συμβαίνει:

    ```output
    2014-12-30 00:00:00
    1 : predicted = [0.32 0.29 0.28] expected = [0.32945389435989236, 0.2900626678603402, 0.2739480752014323]

    2014-12-30 01:00:00
    2 : predicted = [0.3  0.29 0.3 ] expected = [0.2900626678603402, 0.2739480752014323, 0.26812891674127126]

    2014-12-30 02:00:00
    3 : predicted = [0.27 0.28 0.32] expected = [0.2739480752014323, 0.26812891674127126, 0.3025962399283795]
    ```

1. Συγκρίνετε τις προβλέψεις με το πραγματικό φορτίο:

    ```python
    eval_df = pd.DataFrame(predictions, columns=['t+'+str(t) for t in range(1, HORIZON+1)])
    eval_df['timestamp'] = test.index[0:len(test.index)-HORIZON+1]
    eval_df = pd.melt(eval_df, id_vars='timestamp', value_name='prediction', var_name='h')
    eval_df['actual'] = np.array(np.transpose(test_ts)).ravel()
    eval_df[['prediction', 'actual']] = scaler.inverse_transform(eval_df[['prediction', 'actual']])
    eval_df.head()
    ```

    Έξοδος
    |     |            | timestamp | h   | prediction | actual   |
    | --- | ---------- | --------- | --- | ---------- | -------- |
    | 0   | 2014-12-30 | 00:00:00  | t+1 | 3,008.74   | 3,023.00 |
    | 1   | 2014-12-30 | 01:00:00  | t+1 | 2,955.53   | 2,935.00 |
    | 2   | 2014-12-30 | 02:00:00  | t+1 | 2,900.17   | 2,899.00
> **🧮 Δείξε μου τα μαθηματικά**
>
> ![MAPE](../../../../7-TimeSeries/2-ARIMA/images/mape.png)
>
> [MAPE](https://www.linkedin.com/pulse/what-mape-mad-msd-time-series-allameh-statistics/) χρησιμοποιείται για να δείξει την ακρίβεια πρόβλεψης ως αναλογία που ορίζεται από τον παραπάνω τύπο. Η διαφορά μεταξύ της πραγματικής και της προβλεπόμενης τιμής διαιρείται με την πραγματική.
>
> "Η απόλυτη τιμή σε αυτόν τον υπολογισμό αθροίζεται για κάθε προβλεπόμενο σημείο στον χρόνο και διαιρείται με τον αριθμό των προσαρμοσμένων σημείων n." [wikipedia](https://wikipedia.org/wiki/Mean_absolute_percentage_error)
1. Εκφράστε την εξίσωση σε κώδικα:

    ```python
    if(HORIZON > 1):
        eval_df['APE'] = (eval_df['prediction'] - eval_df['actual']).abs() / eval_df['actual']
        print(eval_df.groupby('h')['APE'].mean())
    ```

1. Υπολογίστε το MAPE ενός βήματος:

    ```python
    print('One step forecast MAPE: ', (mape(eval_df[eval_df['h'] == 't+1']['prediction'], eval_df[eval_df['h'] == 't+1']['actual']))*100, '%')
    ```

    MAPE πρόβλεψης ενός βήματος:  0.5570581332313952 %

1. Εκτυπώστε το MAPE πρόβλεψης πολλών βημάτων:

    ```python
    print('Multi-step forecast MAPE: ', mape(eval_df['prediction'], eval_df['actual'])*100, '%')
    ```

    ```output
    Multi-step forecast MAPE:  1.1460048657704118 %
    ```

    Ένας χαμηλός αριθμός είναι καλύτερος: σκεφτείτε ότι μια πρόβλεψη με MAPE 10 είναι εκτός κατά 10%.

1. Αλλά όπως πάντα, είναι πιο εύκολο να δούμε αυτό το είδος μέτρησης ακρίβειας οπτικά, οπότε ας το σχεδιάσουμε:

    ```python
     if(HORIZON == 1):
        ## Plotting single step forecast
        eval_df.plot(x='timestamp', y=['actual', 'prediction'], style=['r', 'b'], figsize=(15, 8))

    else:
        ## Plotting multi step forecast
        plot_df = eval_df[(eval_df.h=='t+1')][['timestamp', 'actual']]
        for t in range(1, HORIZON+1):
            plot_df['t+'+str(t)] = eval_df[(eval_df.h=='t+'+str(t))]['prediction'].values

        fig = plt.figure(figsize=(15, 8))
        ax = plt.plot(plot_df['timestamp'], plot_df['actual'], color='red', linewidth=4.0)
        ax = fig.add_subplot(111)
        for t in range(1, HORIZON+1):
            x = plot_df['timestamp'][(t-1):]
            y = plot_df['t+'+str(t)][0:len(x)]
            ax.plot(x, y, color='blue', linewidth=4*math.pow(.9,t), alpha=math.pow(0.8,t))

        ax.legend(loc='best')

    plt.xlabel('timestamp', fontsize=12)
    plt.ylabel('load', fontsize=12)
    plt.show()
    ```

    ![ένα μοντέλο χρονοσειρών](../../../../7-TimeSeries/2-ARIMA/images/accuracy.png)

🏆 Ένα πολύ ωραίο γράφημα, που δείχνει ένα μοντέλο με καλή ακρίβεια. Μπράβο!

---

## 🚀Πρόκληση

Εξερευνήστε τους τρόπους για να δοκιμάσετε την ακρίβεια ενός μοντέλου χρονοσειρών. Αναφέραμε το MAPE σε αυτό το μάθημα, αλλά υπάρχουν άλλες μέθοδοι που θα μπορούσατε να χρησιμοποιήσετε; Ερευνήστε τις και σχολιάστε τις. Ένα χρήσιμο έγγραφο μπορείτε να βρείτε [εδώ](https://otexts.com/fpp2/accuracy.html)

## [Κουίζ μετά το μάθημα](https://ff-quizzes.netlify.app/en/ml/)

## Ανασκόπηση & Αυτομελέτη

Αυτό το μάθημα καλύπτει μόνο τα βασικά της πρόβλεψης χρονοσειρών με ARIMA. Αφιερώστε χρόνο για να εμβαθύνετε τις γνώσεις σας εξερευνώντας [αυτό το αποθετήριο](https://microsoft.github.io/forecasting/) και τους διάφορους τύπους μοντέλων του για να μάθετε άλλους τρόπους δημιουργίας μοντέλων χρονοσειρών.

## Εργασία

[Ένα νέο μοντέλο ARIMA](assignment.md)

---

**Αποποίηση ευθύνης**:  
Αυτό το έγγραφο έχει μεταφραστεί χρησιμοποιώντας την υπηρεσία αυτόματης μετάφρασης [Co-op Translator](https://github.com/Azure/co-op-translator). Παρόλο που καταβάλλουμε προσπάθειες για ακρίβεια, παρακαλούμε να έχετε υπόψη ότι οι αυτόματες μεταφράσεις ενδέχεται να περιέχουν λάθη ή ανακρίβειες. Το πρωτότυπο έγγραφο στη μητρική του γλώσσα θα πρέπει να θεωρείται η αυθεντική πηγή. Για κρίσιμες πληροφορίες, συνιστάται επαγγελματική ανθρώπινη μετάφραση. Δεν φέρουμε ευθύνη για τυχόν παρεξηγήσεις ή εσφαλμένες ερμηνείες που προκύπτουν από τη χρήση αυτής της μετάφρασης.