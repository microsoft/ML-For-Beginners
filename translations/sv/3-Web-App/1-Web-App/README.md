<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "e0b75f73e4a90d45181dc5581fe2ef5c",
  "translation_date": "2025-09-05T21:47:01+00:00",
  "source_file": "3-Web-App/1-Web-App/README.md",
  "language_code": "sv"
}
-->
# Bygg en webbapp fÃ¶r att anvÃ¤nda en ML-modell

I denna lektion kommer du att trÃ¤na en ML-modell pÃ¥ en dataset som Ã¤r utomjordisk: _UFO-observationer under det senaste Ã¥rhundradet_, hÃ¤mtad frÃ¥n NUFORC:s databas.

Du kommer att lÃ¤ra dig:

- Hur man 'picklar' en trÃ¤nad modell
- Hur man anvÃ¤nder den modellen i en Flask-app

Vi kommer att fortsÃ¤tta anvÃ¤nda notebooks fÃ¶r att rensa data och trÃ¤na vÃ¥r modell, men du kan ta processen ett steg lÃ¤ngre genom att utforska hur man anvÃ¤nder en modell "i det vilda", sÃ¥ att sÃ¤ga: i en webbapp.

FÃ¶r att gÃ¶ra detta behÃ¶ver du bygga en webbapp med Flask.

## [Quiz fÃ¶re fÃ¶relÃ¤sningen](https://ff-quizzes.netlify.app/en/ml/)

## Bygga en app

Det finns flera sÃ¤tt att bygga webbappar fÃ¶r att anvÃ¤nda maskininlÃ¤rningsmodeller. Din webbarkitektur kan pÃ¥verka hur din modell trÃ¤nas. FÃ¶restÃ¤ll dig att du arbetar i ett fÃ¶retag dÃ¤r dataanalysgruppen har trÃ¤nat en modell som de vill att du ska anvÃ¤nda i en app.

### Ã–vervÃ¤ganden

Det finns mÃ¥nga frÃ¥gor du behÃ¶ver stÃ¤lla:

- **Ã„r det en webbapp eller en mobilapp?** Om du bygger en mobilapp eller behÃ¶ver anvÃ¤nda modellen i ett IoT-sammanhang kan du anvÃ¤nda [TensorFlow Lite](https://www.tensorflow.org/lite/) och anvÃ¤nda modellen i en Android- eller iOS-app.
- **Var kommer modellen att finnas?** I molnet eller lokalt?
- **Offline-stÃ¶d.** MÃ¥ste appen fungera offline?
- **Vilken teknik anvÃ¤ndes fÃ¶r att trÃ¤na modellen?** Den valda tekniken kan pÃ¥verka vilka verktyg du behÃ¶ver anvÃ¤nda.
    - **AnvÃ¤nda TensorFlow.** Om du trÃ¤nar en modell med TensorFlow, till exempel, erbjuder det ekosystemet mÃ¶jligheten att konvertera en TensorFlow-modell fÃ¶r anvÃ¤ndning i en webbapp med [TensorFlow.js](https://www.tensorflow.org/js/).
    - **AnvÃ¤nda PyTorch.** Om du bygger en modell med ett bibliotek som [PyTorch](https://pytorch.org/) har du mÃ¶jlighet att exportera den i [ONNX](https://onnx.ai/) (Open Neural Network Exchange)-format fÃ¶r anvÃ¤ndning i JavaScript-webbappar som kan anvÃ¤nda [Onnx Runtime](https://www.onnxruntime.ai/). Detta alternativ kommer att utforskas i en framtida lektion fÃ¶r en Scikit-learn-trÃ¤nad modell.
    - **AnvÃ¤nda Lobe.ai eller Azure Custom Vision.** Om du anvÃ¤nder ett ML SaaS-system (Software as a Service) som [Lobe.ai](https://lobe.ai/) eller [Azure Custom Vision](https://azure.microsoft.com/services/cognitive-services/custom-vision-service/?WT.mc_id=academic-77952-leestott) fÃ¶r att trÃ¤na en modell, erbjuder denna typ av mjukvara sÃ¤tt att exportera modellen fÃ¶r mÃ¥nga plattformar, inklusive att bygga ett skrÃ¤ddarsytt API som kan frÃ¥gas i molnet av din onlineapplikation.

Du har ocksÃ¥ mÃ¶jlighet att bygga en hel Flask-webbapp som kan trÃ¤na modellen direkt i en webblÃ¤sare. Detta kan ocksÃ¥ gÃ¶ras med TensorFlow.js i en JavaScript-kontext.

FÃ¶r vÃ¥ra Ã¤ndamÃ¥l, eftersom vi har arbetat med Python-baserade notebooks, lÃ¥t oss utforska stegen du behÃ¶ver ta fÃ¶r att exportera en trÃ¤nad modell frÃ¥n en sÃ¥dan notebook till ett format som kan lÃ¤sas av en Python-byggd webbapp.

## Verktyg

FÃ¶r denna uppgift behÃ¶ver du tvÃ¥ verktyg: Flask och Pickle, bÃ¥da kÃ¶rs pÃ¥ Python.

âœ… Vad Ã¤r [Flask](https://palletsprojects.com/p/flask/)? Flask definieras som ett 'mikroramverk' av sina skapare och erbjuder de grundlÃ¤ggande funktionerna fÃ¶r webbramverk med Python och en mallmotor fÃ¶r att bygga webbsidor. Ta en titt pÃ¥ [denna Learn-modul](https://docs.microsoft.com/learn/modules/python-flask-build-ai-web-app?WT.mc_id=academic-77952-leestott) fÃ¶r att Ã¶va pÃ¥ att bygga med Flask.

âœ… Vad Ã¤r [Pickle](https://docs.python.org/3/library/pickle.html)? Pickle ðŸ¥’ Ã¤r en Python-modul som serialiserar och deserialiserar en Python-objektstruktur. NÃ¤r du 'picklar' en modell serialiserar eller plattar du ut dess struktur fÃ¶r anvÃ¤ndning pÃ¥ webben. Var fÃ¶rsiktig: pickle Ã¤r inte intrinsiskt sÃ¤ker, sÃ¥ var fÃ¶rsiktig om du blir ombedd att 'un-pickla' en fil. En picklad fil har suffixet `.pkl`.

## Ã–vning - rensa din data

I denna lektion kommer du att anvÃ¤nda data frÃ¥n 80 000 UFO-observationer, insamlade av [NUFORC](https://nuforc.org) (The National UFO Reporting Center). Denna data har nÃ¥gra intressanta beskrivningar av UFO-observationer, till exempel:

- **LÃ¥ng exempelbeskrivning.** "En man kommer ut frÃ¥n en ljusstrÃ¥le som lyser pÃ¥ en grÃ¤sbevuxen fÃ¤lt pÃ¥ natten och han springer mot Texas Instruments parkeringsplats".
- **Kort exempelbeskrivning.** "ljusen jagade oss".

Kalkylbladet [ufos.csv](../../../../3-Web-App/1-Web-App/data/ufos.csv) innehÃ¥ller kolumner om `city`, `state` och `country` dÃ¤r observationen intrÃ¤ffade, objektets `shape` samt dess `latitude` och `longitude`.

I den tomma [notebook](../../../../3-Web-App/1-Web-App/notebook.ipynb) som ingÃ¥r i denna lektion:

1. importera `pandas`, `matplotlib` och `numpy` som du gjorde i tidigare lektioner och importera UFO-kalkylbladet. Du kan ta en titt pÃ¥ ett exempeldata:

    ```python
    import pandas as pd
    import numpy as np
    
    ufos = pd.read_csv('./data/ufos.csv')
    ufos.head()
    ```

1. Konvertera UFO-datan till en liten dataframe med nya titlar. Kontrollera de unika vÃ¤rdena i fÃ¤ltet `Country`.

    ```python
    ufos = pd.DataFrame({'Seconds': ufos['duration (seconds)'], 'Country': ufos['country'],'Latitude': ufos['latitude'],'Longitude': ufos['longitude']})
    
    ufos.Country.unique()
    ```

1. Nu kan du minska mÃ¤ngden data vi behÃ¶ver hantera genom att ta bort eventuella null-vÃ¤rden och endast importera observationer mellan 1-60 sekunder:

    ```python
    ufos.dropna(inplace=True)
    
    ufos = ufos[(ufos['Seconds'] >= 1) & (ufos['Seconds'] <= 60)]
    
    ufos.info()
    ```

1. Importera Scikit-learns `LabelEncoder`-bibliotek fÃ¶r att konvertera textvÃ¤rden fÃ¶r lÃ¤nder till ett nummer:

    âœ… LabelEncoder kodar data alfabetiskt

    ```python
    from sklearn.preprocessing import LabelEncoder
    
    ufos['Country'] = LabelEncoder().fit_transform(ufos['Country'])
    
    ufos.head()
    ```

    Din data bÃ¶r se ut sÃ¥ hÃ¤r:

    ```output
    	Seconds	Country	Latitude	Longitude
    2	20.0	3		53.200000	-2.916667
    3	20.0	4		28.978333	-96.645833
    14	30.0	4		35.823889	-80.253611
    23	60.0	4		45.582778	-122.352222
    24	3.0		3		51.783333	-0.783333
    ```

## Ã–vning - bygg din modell

Nu kan du fÃ¶rbereda dig fÃ¶r att trÃ¤na en modell genom att dela upp datan i trÃ¤nings- och testgrupper.

1. VÃ¤lj de tre funktioner du vill trÃ¤na pÃ¥ som din X-vektor, och y-vektorn kommer att vara `Country`. Du vill kunna mata in `Seconds`, `Latitude` och `Longitude` och fÃ¥ ett land-id som returneras.

    ```python
    from sklearn.model_selection import train_test_split
    
    Selected_features = ['Seconds','Latitude','Longitude']
    
    X = ufos[Selected_features]
    y = ufos['Country']
    
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)
    ```

1. TrÃ¤na din modell med logistisk regression:

    ```python
    from sklearn.metrics import accuracy_score, classification_report
    from sklearn.linear_model import LogisticRegression
    model = LogisticRegression()
    model.fit(X_train, y_train)
    predictions = model.predict(X_test)
    
    print(classification_report(y_test, predictions))
    print('Predicted labels: ', predictions)
    print('Accuracy: ', accuracy_score(y_test, predictions))
    ```

Noggrannheten Ã¤r inte dÃ¥lig **(runt 95%)**, vilket inte Ã¤r fÃ¶rvÃ¥nande, eftersom `Country` och `Latitude/Longitude` korrelerar.

Modellen du skapade Ã¤r inte sÃ¤rskilt revolutionerande eftersom du borde kunna dra slutsatsen ett `Country` frÃ¥n dess `Latitude` och `Longitude`, men det Ã¤r en bra Ã¶vning att fÃ¶rsÃ¶ka trÃ¤na frÃ¥n rÃ¥data som du rensade, exporterade och sedan anvÃ¤nda denna modell i en webbapp.

## Ã–vning - 'pickla' din modell

Nu Ã¤r det dags att _pickla_ din modell! Du kan gÃ¶ra det med nÃ¥gra rader kod. NÃ¤r den Ã¤r _picklad_, ladda din picklade modell och testa den mot en exempeldata-array som innehÃ¥ller vÃ¤rden fÃ¶r sekunder, latitud och longitud,

```python
import pickle
model_filename = 'ufo-model.pkl'
pickle.dump(model, open(model_filename,'wb'))

model = pickle.load(open('ufo-model.pkl','rb'))
print(model.predict([[50,44,-12]]))
```

Modellen returnerar **'3'**, vilket Ã¤r landskoden fÃ¶r Storbritannien. Galet! ðŸ‘½

## Ã–vning - bygg en Flask-app

Nu kan du bygga en Flask-app fÃ¶r att kalla din modell och returnera liknande resultat, men pÃ¥ ett mer visuellt tilltalande sÃ¤tt.

1. BÃ¶rja med att skapa en mapp som heter **web-app** bredvid filen _notebook.ipynb_ dÃ¤r din _ufo-model.pkl_-fil finns.

1. I den mappen skapar du tre ytterligare mappar: **static**, med en mapp **css** inuti, och **templates**. Du bÃ¶r nu ha fÃ¶ljande filer och kataloger:

    ```output
    web-app/
      static/
        css/
      templates/
    notebook.ipynb
    ufo-model.pkl
    ```

    âœ… Se lÃ¶sningsmappen fÃ¶r en vy av den fÃ¤rdiga appen

1. Den fÃ¶rsta filen att skapa i _web-app_-mappen Ã¤r **requirements.txt**-filen. Precis som _package.json_ i en JavaScript-app listar denna fil beroenden som krÃ¤vs av appen. I **requirements.txt** lÃ¤gger du till raderna:

    ```text
    scikit-learn
    pandas
    numpy
    flask
    ```

1. KÃ¶r nu denna fil genom att navigera till _web-app_:

    ```bash
    cd web-app
    ```

1. I din terminal skriver du `pip install` fÃ¶r att installera biblioteken som listas i _requirements.txt_:

    ```bash
    pip install -r requirements.txt
    ```

1. Nu Ã¤r du redo att skapa tre ytterligare filer fÃ¶r att slutfÃ¶ra appen:

    1. Skapa **app.py** i roten.
    2. Skapa **index.html** i _templates_-katalogen.
    3. Skapa **styles.css** i _static/css_-katalogen.

1. Bygg ut _styles.css_-filen med nÃ¥gra stilar:

    ```css
    body {
    	width: 100%;
    	height: 100%;
    	font-family: 'Helvetica';
    	background: black;
    	color: #fff;
    	text-align: center;
    	letter-spacing: 1.4px;
    	font-size: 30px;
    }
    
    input {
    	min-width: 150px;
    }
    
    .grid {
    	width: 300px;
    	border: 1px solid #2d2d2d;
    	display: grid;
    	justify-content: center;
    	margin: 20px auto;
    }
    
    .box {
    	color: #fff;
    	background: #2d2d2d;
    	padding: 12px;
    	display: inline-block;
    }
    ```

1. NÃ¤sta steg Ã¤r att bygga ut _index.html_-filen:

    ```html
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>ðŸ›¸ UFO Appearance Prediction! ðŸ‘½</title>
        <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
      </head>
    
      <body>
        <div class="grid">
    
          <div class="box">
    
            <p>According to the number of seconds, latitude and longitude, which country is likely to have reported seeing a UFO?</p>
    
            <form action="{{ url_for('predict')}}" method="post">
              <input type="number" name="seconds" placeholder="Seconds" required="required" min="0" max="60" />
              <input type="text" name="latitude" placeholder="Latitude" required="required" />
              <input type="text" name="longitude" placeholder="Longitude" required="required" />
              <button type="submit" class="btn">Predict country where the UFO is seen</button>
            </form>
    
            <p>{{ prediction_text }}</p>
    
          </div>
    
        </div>
    
      </body>
    </html>
    ```

    Titta pÃ¥ mallningen i denna fil. Notera 'mustache'-syntaxen runt variabler som kommer att tillhandahÃ¥llas av appen, som prediktionstexten: `{{}}`. Det finns ocksÃ¥ ett formulÃ¤r som skickar en prediktion till `/predict`-routen.

    Slutligen Ã¤r du redo att bygga Python-filen som driver konsumtionen av modellen och visningen av prediktioner:

1. I `app.py` lÃ¤gger du till:

    ```python
    import numpy as np
    from flask import Flask, request, render_template
    import pickle
    
    app = Flask(__name__)
    
    model = pickle.load(open("./ufo-model.pkl", "rb"))
    
    
    @app.route("/")
    def home():
        return render_template("index.html")
    
    
    @app.route("/predict", methods=["POST"])
    def predict():
    
        int_features = [int(x) for x in request.form.values()]
        final_features = [np.array(int_features)]
        prediction = model.predict(final_features)
    
        output = prediction[0]
    
        countries = ["Australia", "Canada", "Germany", "UK", "US"]
    
        return render_template(
            "index.html", prediction_text="Likely country: {}".format(countries[output])
        )
    
    
    if __name__ == "__main__":
        app.run(debug=True)
    ```

    > ðŸ’¡ Tips: nÃ¤r du lÃ¤gger till [`debug=True`](https://www.askpython.com/python-modules/flask/flask-debug-mode) medan du kÃ¶r webbappen med Flask, kommer alla Ã¤ndringar du gÃ¶r i din applikation att Ã¥terspeglas omedelbart utan att du behÃ¶ver starta om servern. Var fÃ¶rsiktig! Aktivera inte detta lÃ¤ge i en produktionsapp.

Om du kÃ¶r `python app.py` eller `python3 app.py` - startar din webbserver lokalt, och du kan fylla i ett kort formulÃ¤r fÃ¶r att fÃ¥ svar pÃ¥ din brinnande frÃ¥ga om var UFO:n har observerats!

Innan du gÃ¶r det, ta en titt pÃ¥ delarna av `app.py`:

1. FÃ¶rst laddas beroenden och appen startar.
1. Sedan importeras modellen.
1. DÃ¤refter renderas index.html pÃ¥ hemrouten.

PÃ¥ `/predict`-routen hÃ¤nder flera saker nÃ¤r formulÃ¤ret skickas:

1. FormulÃ¤rvariablerna samlas in och konverteras till en numpy-array. De skickas sedan till modellen och en prediktion returneras.
2. LÃ¤nderna som vi vill visa renderas om som lÃ¤sbar text frÃ¥n deras fÃ¶rutsagda landskod, och det vÃ¤rdet skickas tillbaka till index.html fÃ¶r att renderas i mallen.

Att anvÃ¤nda en modell pÃ¥ detta sÃ¤tt, med Flask och en picklad modell, Ã¤r relativt enkelt. Det svÃ¥raste Ã¤r att fÃ¶rstÃ¥ vilken form datan mÃ¥ste ha som skickas till modellen fÃ¶r att fÃ¥ en prediktion. Det beror helt pÃ¥ hur modellen trÃ¤nades. Denna har tre datapunkter som mÃ¥ste matas in fÃ¶r att fÃ¥ en prediktion.

I en professionell miljÃ¶ kan du se hur viktig kommunikation Ã¤r mellan de som trÃ¤nar modellen och de som anvÃ¤nder den i en webb- eller mobilapp. I vÃ¥rt fall Ã¤r det bara en person, du!

---

## ðŸš€ Utmaning

IstÃ¤llet fÃ¶r att arbeta i en notebook och importera modellen till Flask-appen, kan du trÃ¤na modellen direkt i Flask-appen! FÃ¶rsÃ¶k att konvertera din Python-kod i notebooken, kanske efter att din data har rensats, fÃ¶r att trÃ¤na modellen direkt i appen pÃ¥ en route som heter `train`. Vilka Ã¤r fÃ¶r- och nackdelarna med att anvÃ¤nda denna metod?

## [Quiz efter fÃ¶relÃ¤sningen](https://ff-quizzes.netlify.app/en/ml/)

## Granskning & SjÃ¤lvstudier

Det finns mÃ¥nga sÃ¤tt att bygga en webbapp fÃ¶r att anvÃ¤nda ML-modeller. GÃ¶r en lista Ã¶ver sÃ¤tt du kan anvÃ¤nda JavaScript eller Python fÃ¶r att bygga en webbapp som utnyttjar maskininlÃ¤rning. TÃ¤nk pÃ¥ arkitektur: bÃ¶r modellen stanna i appen eller finnas i molnet? Om det senare, hur skulle du komma Ã¥t den? Rita en arkitekturmodell fÃ¶r en tillÃ¤mpad ML-webblÃ¶sning.

## Uppgift

[Prova en annan modell](assignment.md)

---

**Ansvarsfriskrivning**:  
Detta dokument har Ã¶versatts med hjÃ¤lp av AI-Ã¶versÃ¤ttningstjÃ¤nsten [Co-op Translator](https://github.com/Azure/co-op-translator). Ã„ven om vi strÃ¤var efter noggrannhet, vÃ¤nligen notera att automatiska Ã¶versÃ¤ttningar kan innehÃ¥lla fel eller felaktigheter. Det ursprungliga dokumentet pÃ¥ sitt ursprungliga sprÃ¥k bÃ¶r betraktas som den auktoritativa kÃ¤llan. FÃ¶r kritisk information rekommenderas professionell mÃ¤nsklig Ã¶versÃ¤ttning. Vi ansvarar inte fÃ¶r eventuella missfÃ¶rstÃ¥nd eller feltolkningar som uppstÃ¥r vid anvÃ¤ndning av denna Ã¶versÃ¤ttning.