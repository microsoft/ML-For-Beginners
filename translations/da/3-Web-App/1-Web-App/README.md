<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "e0b75f73e4a90d45181dc5581fe2ef5c",
  "translation_date": "2025-09-05T00:37:58+00:00",
  "source_file": "3-Web-App/1-Web-App/README.md",
  "language_code": "da"
}
-->
# Byg en webapp til at bruge en ML-model

I denne lektion vil du trÃ¦ne en ML-model pÃ¥ et datasÃ¦t, der er helt ude af denne verden: _UFO-observationer over det sidste Ã¥rhundrede_, hentet fra NUFORC's database.

Du vil lÃ¦re:

- Hvordan man 'pickler' en trÃ¦net model
- Hvordan man bruger den model i en Flask-app

Vi fortsÃ¦tter med at bruge notebooks til at rense data og trÃ¦ne vores model, men du kan tage processen et skridt videre ved at udforske brugen af en model 'i det fri', sÃ¥ at sige: i en webapp.

For at gÃ¸re dette skal du bygge en webapp ved hjÃ¦lp af Flask.

## [Quiz fÃ¸r lektionen](https://ff-quizzes.netlify.app/en/ml/)

## Bygning af en app

Der er flere mÃ¥der at bygge webapps pÃ¥, der kan bruge machine learning-modeller. Din webarkitektur kan pÃ¥virke, hvordan din model trÃ¦nes. Forestil dig, at du arbejder i en virksomhed, hvor data science-gruppen har trÃ¦net en model, som de Ã¸nsker, at du skal bruge i en app.

### Overvejelser

Der er mange spÃ¸rgsmÃ¥l, du skal stille:

- **Er det en webapp eller en mobilapp?** Hvis du bygger en mobilapp eller skal bruge modellen i en IoT-sammenhÃ¦ng, kan du bruge [TensorFlow Lite](https://www.tensorflow.org/lite/) og bruge modellen i en Android- eller iOS-app.
- **Hvor skal modellen placeres?** I skyen eller lokalt?
- **Offline support.** Skal appen fungere offline?
- **Hvilken teknologi blev brugt til at trÃ¦ne modellen?** Den valgte teknologi kan pÃ¥virke de vÃ¦rktÃ¸jer, du skal bruge.
    - **Brug af TensorFlow.** Hvis du trÃ¦ner en model med TensorFlow, giver det Ã¸kosystem mulighed for at konvertere en TensorFlow-model til brug i en webapp ved hjÃ¦lp af [TensorFlow.js](https://www.tensorflow.org/js/).
    - **Brug af PyTorch.** Hvis du bygger en model med et bibliotek som [PyTorch](https://pytorch.org/), har du mulighed for at eksportere den i [ONNX](https://onnx.ai/) (Open Neural Network Exchange)-format til brug i JavaScript-webapps, der kan bruge [Onnx Runtime](https://www.onnxruntime.ai/). Denne mulighed vil blive udforsket i en fremtidig lektion for en Scikit-learn-trÃ¦net model.
    - **Brug af Lobe.ai eller Azure Custom Vision.** Hvis du bruger et ML SaaS-system (Software as a Service) som [Lobe.ai](https://lobe.ai/) eller [Azure Custom Vision](https://azure.microsoft.com/services/cognitive-services/custom-vision-service/?WT.mc_id=academic-77952-leestott) til at trÃ¦ne en model, giver denne type software mÃ¥der at eksportere modellen til mange platforme, herunder opbygning af en skrÃ¦ddersyet API, der kan forespÃ¸rges i skyen af din online-applikation.

Du har ogsÃ¥ mulighed for at bygge en hel Flask-webapp, der kan trÃ¦ne modellen direkte i en webbrowser. Dette kan ogsÃ¥ gÃ¸res ved hjÃ¦lp af TensorFlow.js i en JavaScript-sammenhÃ¦ng.

For vores formÃ¥l, da vi har arbejdet med Python-baserede notebooks, lad os udforske de trin, du skal tage for at eksportere en trÃ¦net model fra en sÃ¥dan notebook til et format, der kan lÃ¦ses af en Python-bygget webapp.

## VÃ¦rktÃ¸j

Til denne opgave skal du bruge to vÃ¦rktÃ¸jer: Flask og Pickle, som begge kÃ¸rer pÃ¥ Python.

âœ… Hvad er [Flask](https://palletsprojects.com/p/flask/)? Defineret som et 'mikro-framework' af sine skabere, giver Flask de grundlÃ¦ggende funktioner i webframeworks ved hjÃ¦lp af Python og en templating-motor til at bygge websider. Tag et kig pÃ¥ [dette Learn-modul](https://docs.microsoft.com/learn/modules/python-flask-build-ai-web-app?WT.mc_id=academic-77952-leestott) for at Ã¸ve dig i at bygge med Flask.

âœ… Hvad er [Pickle](https://docs.python.org/3/library/pickle.html)? Pickle ðŸ¥’ er et Python-modul, der serialiserer og de-serialiserer en Python-objektstruktur. NÃ¥r du 'pickler' en model, serialiserer eller flader du dens struktur ud til brug pÃ¥ nettet. VÃ¦r forsigtig: pickle er ikke i sig selv sikker, sÃ¥ vÃ¦r forsigtig, hvis du bliver bedt om at 'un-pickle' en fil. En pickled fil har suffikset `.pkl`.

## Ã˜velse - rens dine data

I denne lektion vil du bruge data fra 80.000 UFO-observationer, indsamlet af [NUFORC](https://nuforc.org) (The National UFO Reporting Center). Disse data har nogle interessante beskrivelser af UFO-observationer, for eksempel:

- **Lang eksempelbeskrivelse.** "En mand kommer ud af en lysstrÃ¥le, der skinner pÃ¥ en grÃ¦smark om natten, og han lÃ¸ber mod Texas Instruments' parkeringsplads".
- **Kort eksempelbeskrivelse.** "lysene jagtede os".

Regnearket [ufos.csv](../../../../3-Web-App/1-Web-App/data/ufos.csv) inkluderer kolonner om `city`, `state` og `country`, hvor observationen fandt sted, objektets `shape` og dets `latitude` og `longitude`.

I den tomme [notebook](../../../../3-Web-App/1-Web-App/notebook.ipynb), der er inkluderet i denne lektion:

1. Importer `pandas`, `matplotlib` og `numpy`, som du gjorde i tidligere lektioner, og importer UFO-regnearket. Du kan tage et kig pÃ¥ et eksempel-datasÃ¦t:

    ```python
    import pandas as pd
    import numpy as np
    
    ufos = pd.read_csv('./data/ufos.csv')
    ufos.head()
    ```

1. Konverter UFO-dataene til en lille dataframe med friske titler. Tjek de unikke vÃ¦rdier i `Country`-feltet.

    ```python
    ufos = pd.DataFrame({'Seconds': ufos['duration (seconds)'], 'Country': ufos['country'],'Latitude': ufos['latitude'],'Longitude': ufos['longitude']})
    
    ufos.Country.unique()
    ```

1. Nu kan du reducere mÃ¦ngden af data, vi skal hÃ¥ndtere, ved at droppe eventuelle null-vÃ¦rdier og kun importere observationer mellem 1-60 sekunder:

    ```python
    ufos.dropna(inplace=True)
    
    ufos = ufos[(ufos['Seconds'] >= 1) & (ufos['Seconds'] <= 60)]
    
    ufos.info()
    ```

1. Importer Scikit-learns `LabelEncoder`-bibliotek for at konvertere tekstvÃ¦rdier for lande til et nummer:

    âœ… LabelEncoder koder data alfabetisk

    ```python
    from sklearn.preprocessing import LabelEncoder
    
    ufos['Country'] = LabelEncoder().fit_transform(ufos['Country'])
    
    ufos.head()
    ```

    Dine data bÃ¸r se sÃ¥dan ud:

    ```output
    	Seconds	Country	Latitude	Longitude
    2	20.0	3		53.200000	-2.916667
    3	20.0	4		28.978333	-96.645833
    14	30.0	4		35.823889	-80.253611
    23	60.0	4		45.582778	-122.352222
    24	3.0		3		51.783333	-0.783333
    ```

## Ã˜velse - byg din model

Nu kan du gÃ¸re dig klar til at trÃ¦ne en model ved at opdele dataene i trÃ¦nings- og testgrupper.

1. VÃ¦lg de tre funktioner, du vil trÃ¦ne pÃ¥ som din X-vektor, og y-vektoren vil vÃ¦re `Country`. Du vil kunne indtaste `Seconds`, `Latitude` og `Longitude` og fÃ¥ et land-id som resultat.

    ```python
    from sklearn.model_selection import train_test_split
    
    Selected_features = ['Seconds','Latitude','Longitude']
    
    X = ufos[Selected_features]
    y = ufos['Country']
    
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)
    ```

1. TrÃ¦n din model ved hjÃ¦lp af logistisk regression:

    ```python
    from sklearn.metrics import accuracy_score, classification_report
    from sklearn.linear_model import LogisticRegression
    model = LogisticRegression()
    model.fit(X_train, y_train)
    predictions = model.predict(X_test)
    
    print(classification_report(y_test, predictions))
    print('Predicted labels: ', predictions)
    print('Accuracy: ', accuracy_score(y_test, predictions))
    ```

NÃ¸jagtigheden er ikke dÃ¥rlig **(omkring 95%)**, hvilket ikke er overraskende, da `Country` og `Latitude/Longitude` korrelerer.

Den model, du har oprettet, er ikke sÃ¦rlig revolutionerende, da du burde kunne udlede et `Country` fra dets `Latitude` og `Longitude`, men det er en god Ã¸velse at prÃ¸ve at trÃ¦ne fra rÃ¥ data, som du har renset, eksporteret og derefter bruge denne model i en webapp.

## Ã˜velse - 'pickle' din model

Nu er det tid til at _pickle_ din model! Du kan gÃ¸re det med fÃ¥ linjer kode. NÃ¥r den er _pickled_, skal du indlÃ¦se din pickled model og teste den mod en eksempel-datarray, der indeholder vÃ¦rdier for sekunder, breddegrad og lÃ¦ngdegrad.

```python
import pickle
model_filename = 'ufo-model.pkl'
pickle.dump(model, open(model_filename,'wb'))

model = pickle.load(open('ufo-model.pkl','rb'))
print(model.predict([[50,44,-12]]))
```

Modellen returnerer **'3'**, hvilket er landekoden for Storbritannien. Vildt! ðŸ‘½

## Ã˜velse - byg en Flask-app

Nu kan du bygge en Flask-app til at kalde din model og returnere lignende resultater, men pÃ¥ en mere visuelt tiltalende mÃ¥de.

1. Start med at oprette en mappe kaldet **web-app** ved siden af _notebook.ipynb_-filen, hvor din _ufo-model.pkl_-fil ligger.

1. I den mappe skal du oprette tre flere mapper: **static**, med en mappe **css** indeni, og **templates**. Du bÃ¸r nu have fÃ¸lgende filer og mapper:

    ```output
    web-app/
      static/
        css/
      templates/
    notebook.ipynb
    ufo-model.pkl
    ```

    âœ… Se lÃ¸sningsmappen for at fÃ¥ et overblik over den fÃ¦rdige app

1. Den fÃ¸rste fil, der skal oprettes i _web-app_-mappen, er **requirements.txt**-filen. Ligesom _package.json_ i en JavaScript-app, lister denne fil afhÃ¦ngigheder, der krÃ¦ves af appen. I **requirements.txt** tilfÃ¸j linjerne:

    ```text
    scikit-learn
    pandas
    numpy
    flask
    ```

1. KÃ¸r nu denne fil ved at navigere til _web-app_:

    ```bash
    cd web-app
    ```

1. I din terminal skal du skrive `pip install` for at installere de biblioteker, der er angivet i _requirements.txt_:

    ```bash
    pip install -r requirements.txt
    ```

1. Nu er du klar til at oprette tre flere filer for at fÃ¦rdiggÃ¸re appen:

    1. Opret **app.py** i roden.
    2. Opret **index.html** i _templates_-mappen.
    3. Opret **styles.css** i _static/css_-mappen.

1. Udfyld _styles.css_-filen med nogle fÃ¥ stilarter:

    ```css
    body {
    	width: 100%;
    	height: 100%;
    	font-family: 'Helvetica';
    	background: black;
    	color: #fff;
    	text-align: center;
    	letter-spacing: 1.4px;
    	font-size: 30px;
    }
    
    input {
    	min-width: 150px;
    }
    
    .grid {
    	width: 300px;
    	border: 1px solid #2d2d2d;
    	display: grid;
    	justify-content: center;
    	margin: 20px auto;
    }
    
    .box {
    	color: #fff;
    	background: #2d2d2d;
    	padding: 12px;
    	display: inline-block;
    }
    ```

1. DernÃ¦st skal du udfylde _index.html_-filen:

    ```html
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>ðŸ›¸ UFO Appearance Prediction! ðŸ‘½</title>
        <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
      </head>
    
      <body>
        <div class="grid">
    
          <div class="box">
    
            <p>According to the number of seconds, latitude and longitude, which country is likely to have reported seeing a UFO?</p>
    
            <form action="{{ url_for('predict')}}" method="post">
              <input type="number" name="seconds" placeholder="Seconds" required="required" min="0" max="60" />
              <input type="text" name="latitude" placeholder="Latitude" required="required" />
              <input type="text" name="longitude" placeholder="Longitude" required="required" />
              <button type="submit" class="btn">Predict country where the UFO is seen</button>
            </form>
    
            <p>{{ prediction_text }}</p>
    
          </div>
    
        </div>
    
      </body>
    </html>
    ```

    Tag et kig pÃ¥ templating i denne fil. BemÃ¦rk 'mustache'-syntaksen omkring variabler, der vil blive leveret af appen, som for eksempel prediction-teksten: `{{}}`. Der er ogsÃ¥ en formular, der sender en prediction til `/predict`-ruten.

    Endelig er du klar til at bygge Python-filen, der driver forbruget af modellen og visningen af forudsigelser:

1. I `app.py` tilfÃ¸j:

    ```python
    import numpy as np
    from flask import Flask, request, render_template
    import pickle
    
    app = Flask(__name__)
    
    model = pickle.load(open("./ufo-model.pkl", "rb"))
    
    
    @app.route("/")
    def home():
        return render_template("index.html")
    
    
    @app.route("/predict", methods=["POST"])
    def predict():
    
        int_features = [int(x) for x in request.form.values()]
        final_features = [np.array(int_features)]
        prediction = model.predict(final_features)
    
        output = prediction[0]
    
        countries = ["Australia", "Canada", "Germany", "UK", "US"]
    
        return render_template(
            "index.html", prediction_text="Likely country: {}".format(countries[output])
        )
    
    
    if __name__ == "__main__":
        app.run(debug=True)
    ```

    > ðŸ’¡ Tip: NÃ¥r du tilfÃ¸jer [`debug=True`](https://www.askpython.com/python-modules/flask/flask-debug-mode), mens du kÃ¸rer webappen ved hjÃ¦lp af Flask, vil eventuelle Ã¦ndringer, du foretager i din applikation, straks blive afspejlet uden behov for at genstarte serveren. Pas pÃ¥! Aktiver ikke denne tilstand i en produktionsapp.

Hvis du kÃ¸rer `python app.py` eller `python3 app.py` - starter din webserver lokalt, og du kan udfylde en kort formular for at fÃ¥ svar pÃ¥ dit brÃ¦ndende spÃ¸rgsmÃ¥l om, hvor UFO'er er blevet observeret!

FÃ¸r du gÃ¸r det, skal du tage et kig pÃ¥ delene af `app.py`:

1. FÃ¸rst indlÃ¦ses afhÃ¦ngigheder, og appen starter.
1. Derefter importeres modellen.
1. Derefter renderes index.html pÃ¥ hjemmeruten.

PÃ¥ `/predict`-ruten sker der flere ting, nÃ¥r formularen sendes:

1. Formularvariablerne indsamles og konverteres til en numpy-array. De sendes derefter til modellen, og en prediction returneres.
2. De lande, vi Ã¸nsker vist, genrenderes som lÃ¦sbar tekst fra deres forudsagte landekode, og den vÃ¦rdi sendes tilbage til index.html for at blive renderet i templaten.

At bruge en model pÃ¥ denne mÃ¥de, med Flask og en pickled model, er relativt ligetil. Det svÃ¦reste er at forstÃ¥, hvilken form dataene skal have for at blive sendt til modellen for at fÃ¥ en prediction. Det afhÃ¦nger helt af, hvordan modellen blev trÃ¦net. Denne har tre datapunkter, der skal indtastes for at fÃ¥ en prediction.

I en professionel sammenhÃ¦ng kan du se, hvor vigtig god kommunikation er mellem dem, der trÃ¦ner modellen, og dem, der bruger den i en web- eller mobilapp. I vores tilfÃ¦lde er det kun Ã©n person, dig!

---

## ðŸš€ Udfordring

I stedet for at arbejde i en notebook og importere modellen til Flask-appen, kunne du trÃ¦ne modellen direkte i Flask-appen! PrÃ¸v at konvertere din Python-kode i notebooken, mÃ¥ske efter dine data er renset, til at trÃ¦ne modellen fra appen pÃ¥ en rute kaldet `train`. Hvad er fordele og ulemper ved at forfÃ¸lge denne metode?

## [Quiz efter lektionen](https://ff-quizzes.netlify.app/en/ml/)

## Gennemgang & Selvstudie

Der er mange mÃ¥der at bygge en webapp pÃ¥, der kan bruge ML-modeller. Lav en liste over mÃ¥der, du kunne bruge JavaScript eller Python til at bygge en webapp, der udnytter machine learning. Overvej arkitektur: Skal modellen blive i appen eller leve i skyen? Hvis det sidste, hvordan ville du fÃ¥ adgang til den? Tegn en arkitekturmodel for en anvendt ML-weblÃ¸sning.

## Opgave

[PrÃ¸v en anden model](assignment.md)

---

**Ansvarsfraskrivelse**:  
Dette dokument er blevet oversat ved hjÃ¦lp af AI-oversÃ¦ttelsestjenesten [Co-op Translator](https://github.com/Azure/co-op-translator). Selvom vi bestrÃ¦ber os pÃ¥ nÃ¸jagtighed, skal du vÃ¦re opmÃ¦rksom pÃ¥, at automatiserede oversÃ¦ttelser kan indeholde fejl eller unÃ¸jagtigheder. Det originale dokument pÃ¥ dets oprindelige sprog bÃ¸r betragtes som den autoritative kilde. For kritisk information anbefales professionel menneskelig oversÃ¦ttelse. Vi er ikke ansvarlige for eventuelle misforstÃ¥elser eller fejltolkninger, der opstÃ¥r som fÃ¸lge af brugen af denne oversÃ¦ttelse.