<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "e0b75f73e4a90d45181dc5581fe2ef5c",
  "translation_date": "2025-09-05T08:45:52+00:00",
  "source_file": "3-Web-App/1-Web-App/README.md",
  "language_code": "pt"
}
-->
# Construir uma AplicaÃ§Ã£o Web para Utilizar um Modelo de ML

Nesta liÃ§Ã£o, vais treinar um modelo de ML com um conjunto de dados fora do comum: _avistamentos de OVNIs ao longo do Ãºltimo sÃ©culo_, provenientes da base de dados do NUFORC.

Vais aprender:

- Como 'pickle' um modelo treinado
- Como usar esse modelo numa aplicaÃ§Ã£o Flask

Continuaremos a usar notebooks para limpar os dados e treinar o modelo, mas podes levar o processo um passo adiante ao explorar como usar um modelo "no mundo real", por assim dizer: numa aplicaÃ§Ã£o web.

Para isso, precisas de construir uma aplicaÃ§Ã£o web utilizando Flask.

## [QuestionÃ¡rio prÃ©-aula](https://ff-quizzes.netlify.app/en/ml/)

## Construir uma aplicaÃ§Ã£o

Existem vÃ¡rias formas de construir aplicaÃ§Ãµes web para consumir modelos de machine learning. A arquitetura da tua aplicaÃ§Ã£o web pode influenciar a forma como o modelo Ã© treinado. Imagina que estÃ¡s a trabalhar numa empresa onde o grupo de ciÃªncia de dados treinou um modelo que querem que utilizes numa aplicaÃ§Ã£o.

### ConsideraÃ§Ãµes

HÃ¡ muitas perguntas que precisas de fazer:

- **Ã‰ uma aplicaÃ§Ã£o web ou uma aplicaÃ§Ã£o mÃ³vel?** Se estÃ¡s a construir uma aplicaÃ§Ã£o mÃ³vel ou precisas de usar o modelo num contexto de IoT, podes usar [TensorFlow Lite](https://www.tensorflow.org/lite/) e utilizar o modelo numa aplicaÃ§Ã£o Android ou iOS.
- **Onde o modelo vai residir?** Na nuvem ou localmente?
- **Suporte offline.** A aplicaÃ§Ã£o precisa de funcionar offline?
- **Que tecnologia foi usada para treinar o modelo?** A tecnologia escolhida pode influenciar as ferramentas que precisas de usar.
    - **Usando TensorFlow.** Se estÃ¡s a treinar um modelo com TensorFlow, por exemplo, esse ecossistema permite converter um modelo TensorFlow para uso numa aplicaÃ§Ã£o web utilizando [TensorFlow.js](https://www.tensorflow.org/js/).
    - **Usando PyTorch.** Se estÃ¡s a construir um modelo com uma biblioteca como [PyTorch](https://pytorch.org/), tens a opÃ§Ã£o de exportÃ¡-lo no formato [ONNX](https://onnx.ai/) (Open Neural Network Exchange) para uso em aplicaÃ§Ãµes web JavaScript que podem utilizar o [Onnx Runtime](https://www.onnxruntime.ai/). Esta opÃ§Ã£o serÃ¡ explorada numa liÃ§Ã£o futura para um modelo treinado com Scikit-learn.
    - **Usando Lobe.ai ou Azure Custom Vision.** Se estÃ¡s a usar um sistema ML SaaS (Software como ServiÃ§o) como [Lobe.ai](https://lobe.ai/) ou [Azure Custom Vision](https://azure.microsoft.com/services/cognitive-services/custom-vision-service/?WT.mc_id=academic-77952-leestott) para treinar um modelo, este tipo de software fornece formas de exportar o modelo para vÃ¡rias plataformas, incluindo construir uma API personalizada para ser consultada na nuvem pela tua aplicaÃ§Ã£o online.

TambÃ©m tens a oportunidade de construir uma aplicaÃ§Ã£o web Flask completa que seria capaz de treinar o modelo diretamente no navegador. Isso tambÃ©m pode ser feito utilizando TensorFlow.js num contexto JavaScript.

Para os nossos propÃ³sitos, como temos trabalhado com notebooks baseados em Python, vamos explorar os passos necessÃ¡rios para exportar um modelo treinado de um notebook para um formato legÃ­vel por uma aplicaÃ§Ã£o web construÃ­da em Python.

## Ferramenta

Para esta tarefa, precisas de duas ferramentas: Flask e Pickle, ambas executadas em Python.

âœ… O que Ã© [Flask](https://palletsprojects.com/p/flask/)? Definido como um 'micro-framework' pelos seus criadores, Flask fornece as funcionalidades bÃ¡sicas de frameworks web utilizando Python e um motor de templates para construir pÃ¡ginas web. DÃ¡ uma olhada neste [mÃ³dulo de aprendizagem](https://docs.microsoft.com/learn/modules/python-flask-build-ai-web-app?WT.mc_id=academic-77952-leestott) para praticar a construÃ§Ã£o com Flask.

âœ… O que Ã© [Pickle](https://docs.python.org/3/library/pickle.html)? Pickle ðŸ¥’ Ã© um mÃ³dulo Python que serializa e desserializa uma estrutura de objetos Python. Quando 'pickle' um modelo, estÃ¡s a serializar ou achatar a sua estrutura para uso na web. AtenÃ§Ã£o: pickle nÃ£o Ã© intrinsecamente seguro, por isso tem cuidado se fores solicitado a 'des-picklar' um ficheiro. Um ficheiro pickled tem o sufixo `.pkl`.

## ExercÃ­cio - limpar os dados

Nesta liÃ§Ã£o vais usar dados de 80.000 avistamentos de OVNIs, recolhidos pelo [NUFORC](https://nuforc.org) (Centro Nacional de RelatÃ³rios de OVNIs). Estes dados tÃªm descriÃ§Ãµes interessantes de avistamentos de OVNIs, por exemplo:

- **DescriÃ§Ã£o longa de exemplo.** "Um homem emerge de um feixe de luz que brilha num campo de relva Ã  noite e corre em direÃ§Ã£o ao estacionamento da Texas Instruments".
- **DescriÃ§Ã£o curta de exemplo.** "as luzes perseguiram-nos".

A folha de cÃ¡lculo [ufos.csv](../../../../3-Web-App/1-Web-App/data/ufos.csv) inclui colunas sobre a `cidade`, `estado` e `paÃ­s` onde o avistamento ocorreu, a `forma` do objeto e a sua `latitude` e `longitude`.

No [notebook](../../../../3-Web-App/1-Web-App/notebook.ipynb) em branco incluÃ­do nesta liÃ§Ã£o:

1. Importa `pandas`, `matplotlib` e `numpy` como fizeste nas liÃ§Ãµes anteriores e importa a folha de cÃ¡lculo de OVNIs. Podes dar uma olhada num conjunto de dados de exemplo:

    ```python
    import pandas as pd
    import numpy as np
    
    ufos = pd.read_csv('./data/ufos.csv')
    ufos.head()
    ```

1. Converte os dados de OVNIs para um pequeno dataframe com tÃ­tulos novos. Verifica os valores Ãºnicos no campo `Country`.

    ```python
    ufos = pd.DataFrame({'Seconds': ufos['duration (seconds)'], 'Country': ufos['country'],'Latitude': ufos['latitude'],'Longitude': ufos['longitude']})
    
    ufos.Country.unique()
    ```

1. Agora, podes reduzir a quantidade de dados com que precisas de lidar ao eliminar valores nulos e importar apenas avistamentos entre 1-60 segundos:

    ```python
    ufos.dropna(inplace=True)
    
    ufos = ufos[(ufos['Seconds'] >= 1) & (ufos['Seconds'] <= 60)]
    
    ufos.info()
    ```

1. Importa a biblioteca `LabelEncoder` do Scikit-learn para converter os valores de texto dos paÃ­ses para nÃºmeros:

    âœ… LabelEncoder codifica os dados alfabeticamente

    ```python
    from sklearn.preprocessing import LabelEncoder
    
    ufos['Country'] = LabelEncoder().fit_transform(ufos['Country'])
    
    ufos.head()
    ```

    Os teus dados devem parecer-se com isto:

    ```output
    	Seconds	Country	Latitude	Longitude
    2	20.0	3		53.200000	-2.916667
    3	20.0	4		28.978333	-96.645833
    14	30.0	4		35.823889	-80.253611
    23	60.0	4		45.582778	-122.352222
    24	3.0		3		51.783333	-0.783333
    ```

## ExercÃ­cio - construir o modelo

Agora podes preparar-te para treinar um modelo dividindo os dados em grupos de treino e teste.

1. Seleciona as trÃªs caracterÃ­sticas que queres treinar como o teu vetor X, e o vetor y serÃ¡ o `Country`. Queres ser capaz de inserir `Seconds`, `Latitude` e `Longitude` e obter um id de paÃ­s como retorno.

    ```python
    from sklearn.model_selection import train_test_split
    
    Selected_features = ['Seconds','Latitude','Longitude']
    
    X = ufos[Selected_features]
    y = ufos['Country']
    
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)
    ```

1. Treina o modelo utilizando regressÃ£o logÃ­stica:

    ```python
    from sklearn.metrics import accuracy_score, classification_report
    from sklearn.linear_model import LogisticRegression
    model = LogisticRegression()
    model.fit(X_train, y_train)
    predictions = model.predict(X_test)
    
    print(classification_report(y_test, predictions))
    print('Predicted labels: ', predictions)
    print('Accuracy: ', accuracy_score(y_test, predictions))
    ```

A precisÃ£o nÃ£o Ã© mÃ¡ **(cerca de 95%)**, o que nÃ£o Ã© surpreendente, jÃ¡ que `Country` e `Latitude/Longitude` estÃ£o correlacionados.

O modelo que criaste nÃ£o Ã© muito revolucionÃ¡rio, pois deverias ser capaz de inferir um `Country` a partir da sua `Latitude` e `Longitude`, mas Ã© um bom exercÃ­cio para tentar treinar a partir de dados brutos que limpaste, exportaste e depois usaste este modelo numa aplicaÃ§Ã£o web.

## ExercÃ­cio - 'pickle' o modelo

Agora, Ã© hora de _picklar_ o modelo! Podes fazer isso em algumas linhas de cÃ³digo. Uma vez _pickled_, carrega o modelo pickled e testa-o contra um array de dados de exemplo contendo valores para segundos, latitude e longitude.

```python
import pickle
model_filename = 'ufo-model.pkl'
pickle.dump(model, open(model_filename,'wb'))

model = pickle.load(open('ufo-model.pkl','rb'))
print(model.predict([[50,44,-12]]))
```

O modelo retorna **'3'**, que Ã© o cÃ³digo de paÃ­s para o Reino Unido. IncrÃ­vel! ðŸ‘½

## ExercÃ­cio - construir uma aplicaÃ§Ã£o Flask

Agora podes construir uma aplicaÃ§Ã£o Flask para chamar o modelo e retornar resultados semelhantes, mas de uma forma mais visualmente agradÃ¡vel.

1. ComeÃ§a por criar uma pasta chamada **web-app** ao lado do ficheiro _notebook.ipynb_ onde o teu ficheiro _ufo-model.pkl_ reside.

1. Nessa pasta, cria mais trÃªs pastas: **static**, com uma pasta **css** dentro dela, e **templates**. Deves agora ter os seguintes ficheiros e diretÃ³rios:

    ```output
    web-app/
      static/
        css/
      templates/
    notebook.ipynb
    ufo-model.pkl
    ```

    âœ… Consulta a pasta de soluÃ§Ã£o para ver a aplicaÃ§Ã£o finalizada

1. O primeiro ficheiro a criar na pasta _web-app_ Ã© o ficheiro **requirements.txt**. Tal como _package.json_ numa aplicaÃ§Ã£o JavaScript, este ficheiro lista as dependÃªncias necessÃ¡rias para a aplicaÃ§Ã£o. No **requirements.txt** adiciona as linhas:

    ```text
    scikit-learn
    pandas
    numpy
    flask
    ```

1. Agora, executa este ficheiro navegando atÃ© _web-app_:

    ```bash
    cd web-app
    ```

1. No terminal, digita `pip install` para instalar as bibliotecas listadas no _requirements.txt_:

    ```bash
    pip install -r requirements.txt
    ```

1. Agora, estÃ¡s pronto para criar mais trÃªs ficheiros para finalizar a aplicaÃ§Ã£o:

    1. Cria **app.py** na raiz.
    2. Cria **index.html** na pasta _templates_.
    3. Cria **styles.css** na pasta _static/css_.

1. Desenvolve o ficheiro _styles.css_ com alguns estilos:

    ```css
    body {
    	width: 100%;
    	height: 100%;
    	font-family: 'Helvetica';
    	background: black;
    	color: #fff;
    	text-align: center;
    	letter-spacing: 1.4px;
    	font-size: 30px;
    }
    
    input {
    	min-width: 150px;
    }
    
    .grid {
    	width: 300px;
    	border: 1px solid #2d2d2d;
    	display: grid;
    	justify-content: center;
    	margin: 20px auto;
    }
    
    .box {
    	color: #fff;
    	background: #2d2d2d;
    	padding: 12px;
    	display: inline-block;
    }
    ```

1. Em seguida, desenvolve o ficheiro _index.html_:

    ```html
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>ðŸ›¸ UFO Appearance Prediction! ðŸ‘½</title>
        <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
      </head>
    
      <body>
        <div class="grid">
    
          <div class="box">
    
            <p>According to the number of seconds, latitude and longitude, which country is likely to have reported seeing a UFO?</p>
    
            <form action="{{ url_for('predict')}}" method="post">
              <input type="number" name="seconds" placeholder="Seconds" required="required" min="0" max="60" />
              <input type="text" name="latitude" placeholder="Latitude" required="required" />
              <input type="text" name="longitude" placeholder="Longitude" required="required" />
              <button type="submit" class="btn">Predict country where the UFO is seen</button>
            </form>
    
            <p>{{ prediction_text }}</p>
    
          </div>
    
        </div>
    
      </body>
    </html>
    ```

    DÃ¡ uma olhada na utilizaÃ§Ã£o de templates neste ficheiro. Repara na sintaxe 'mustache' em torno das variÃ¡veis que serÃ£o fornecidas pela aplicaÃ§Ã£o, como o texto de previsÃ£o: `{{}}`. HÃ¡ tambÃ©m um formulÃ¡rio que envia uma previsÃ£o para a rota `/predict`.

    Finalmente, estÃ¡s pronto para construir o ficheiro Python que conduz o consumo do modelo e a exibiÃ§Ã£o das previsÃµes:

1. No `app.py` adiciona:

    ```python
    import numpy as np
    from flask import Flask, request, render_template
    import pickle
    
    app = Flask(__name__)
    
    model = pickle.load(open("./ufo-model.pkl", "rb"))
    
    
    @app.route("/")
    def home():
        return render_template("index.html")
    
    
    @app.route("/predict", methods=["POST"])
    def predict():
    
        int_features = [int(x) for x in request.form.values()]
        final_features = [np.array(int_features)]
        prediction = model.predict(final_features)
    
        output = prediction[0]
    
        countries = ["Australia", "Canada", "Germany", "UK", "US"]
    
        return render_template(
            "index.html", prediction_text="Likely country: {}".format(countries[output])
        )
    
    
    if __name__ == "__main__":
        app.run(debug=True)
    ```

    > ðŸ’¡ Dica: quando adicionas [`debug=True`](https://www.askpython.com/python-modules/flask/flask-debug-mode) enquanto executas a aplicaÃ§Ã£o web utilizando Flask, quaisquer alteraÃ§Ãµes que fizeres na tua aplicaÃ§Ã£o serÃ£o refletidas imediatamente sem necessidade de reiniciar o servidor. AtenÃ§Ã£o! NÃ£o habilites este modo numa aplicaÃ§Ã£o em produÃ§Ã£o.

Se executares `python app.py` ou `python3 app.py` - o teu servidor web inicia localmente, e podes preencher um pequeno formulÃ¡rio para obter uma resposta Ã  tua pergunta sobre onde os OVNIs foram avistados!

Antes de fazer isso, dÃ¡ uma olhada nas partes do `app.py`:

1. Primeiro, as dependÃªncias sÃ£o carregadas e a aplicaÃ§Ã£o inicia.
1. Depois, o modelo Ã© importado.
1. Em seguida, o index.html Ã© renderizado na rota inicial.

Na rota `/predict`, vÃ¡rias coisas acontecem quando o formulÃ¡rio Ã© enviado:

1. As variÃ¡veis do formulÃ¡rio sÃ£o recolhidas e convertidas para um array numpy. Elas sÃ£o entÃ£o enviadas para o modelo e uma previsÃ£o Ã© retornada.
2. Os paÃ­ses que queremos exibir sÃ£o re-renderizados como texto legÃ­vel a partir do cÃ³digo de paÃ­s previsto, e esse valor Ã© enviado de volta ao index.html para ser renderizado no template.

Usar um modelo desta forma, com Flask e um modelo pickled, Ã© relativamente simples. O mais difÃ­cil Ã© entender qual Ã© a forma dos dados que devem ser enviados ao modelo para obter uma previsÃ£o. Isso depende de como o modelo foi treinado. Este tem trÃªs pontos de dados que devem ser inseridos para obter uma previsÃ£o.

Num ambiente profissional, podes ver como Ã© necessÃ¡ria uma boa comunicaÃ§Ã£o entre as pessoas que treinam o modelo e aquelas que o consomem numa aplicaÃ§Ã£o web ou mÃ³vel. No nosso caso, Ã©s apenas tu!

---

## ðŸš€ Desafio

Em vez de trabalhar num notebook e importar o modelo para a aplicaÃ§Ã£o Flask, poderias treinar o modelo diretamente dentro da aplicaÃ§Ã£o Flask! Tenta converter o teu cÃ³digo Python no notebook, talvez depois de os dados serem limpos, para treinar o modelo dentro da aplicaÃ§Ã£o numa rota chamada `train`. Quais sÃ£o os prÃ³s e contras de seguir este mÃ©todo?

## [QuestionÃ¡rio pÃ³s-aula](https://ff-quizzes.netlify.app/en/ml/)

## RevisÃ£o & Autoestudo

Existem muitas formas de construir uma aplicaÃ§Ã£o web para consumir modelos de ML. Faz uma lista das formas como poderias usar JavaScript ou Python para construir uma aplicaÃ§Ã£o web que aproveite o machine learning. Considera a arquitetura: o modelo deve permanecer na aplicaÃ§Ã£o ou viver na nuvem? Se for o Ãºltimo caso, como o acederias? Desenha um modelo arquitetural para uma soluÃ§Ã£o web aplicada de ML.

## Tarefa

[Experimenta um modelo diferente](assignment.md)

---

**Aviso Legal**:  
Este documento foi traduzido utilizando o serviÃ§o de traduÃ§Ã£o automÃ¡tica [Co-op Translator](https://github.com/Azure/co-op-translator). Embora nos esforcemos para garantir a precisÃ£o, esteja ciente de que traduÃ§Ãµes automÃ¡ticas podem conter erros ou imprecisÃµes. O documento original na sua lÃ­ngua nativa deve ser considerado a fonte oficial. Para informaÃ§Ãµes crÃ­ticas, recomenda-se a traduÃ§Ã£o profissional realizada por humanos. NÃ£o nos responsabilizamos por quaisquer mal-entendidos ou interpretaÃ§Ãµes incorretas resultantes do uso desta traduÃ§Ã£o.