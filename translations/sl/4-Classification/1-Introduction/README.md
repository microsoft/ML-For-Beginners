<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "aaf391d922bd6de5efba871d514c6d47",
  "translation_date": "2025-09-05T13:18:08+00:00",
  "source_file": "4-Classification/1-Introduction/README.md",
  "language_code": "sl"
}
-->
# Uvod v klasifikacijo

V teh ≈°tirih lekcijah boste raziskovali eno temeljnih podroƒçij klasiƒçnega strojnega uƒçenja - _klasifikacijo_. Preuƒçili bomo uporabo razliƒçnih algoritmov za klasifikacijo z uporabo nabora podatkov o vseh ƒçudovitih azijskih in indijskih kuhinjah. Upam, da ste laƒçni!

![samo ≈°ƒçepec!](../../../../4-Classification/1-Introduction/images/pinch.png)

> Praznujte panazijske kuhinje v teh lekcijah! Slika: [Jen Looper](https://twitter.com/jenlooper)

Klasifikacija je oblika [nadzorovanega uƒçenja](https://wikipedia.org/wiki/Supervised_learning), ki ima veliko skupnega s tehnikami regresije. ƒåe je strojno uƒçenje namenjeno napovedovanju vrednosti ali imen stvari z uporabo naborov podatkov, potem klasifikacijo obiƒçajno delimo v dve skupini: _binarna klasifikacija_ in _veƒçrazredna klasifikacija_.

[![Uvod v klasifikacijo](https://img.youtube.com/vi/eg8DJYwdMyg/0.jpg)](https://youtu.be/eg8DJYwdMyg "Uvod v klasifikacijo")

> üé• Kliknite zgornjo sliko za video: MIT-jev John Guttag predstavlja klasifikacijo

Zapomnite si:

- **Linearna regresija** vam je pomagala napovedati odnose med spremenljivkami in natanƒçno predvideti, kam bo padla nova podatkovna toƒçka glede na to ƒçrto. Na primer, lahko ste napovedali _kak≈°na bo cena buƒçe septembra v primerjavi z decembrom_.
- **Logistiƒçna regresija** vam je pomagala odkriti "binarne kategorije": pri tej ceni, _ali je ta buƒça oran≈æna ali ne-oran≈æna_?

Klasifikacija uporablja razliƒçne algoritme za doloƒçanje drugih naƒçinov ugotavljanja oznake ali razreda podatkovne toƒçke. Delali bomo s temi podatki o kuhinjah, da ugotovimo, ali lahko na podlagi skupine sestavin doloƒçimo izvorno kuhinjo.

## [Predlekcijski kviz](https://ff-quizzes.netlify.app/en/ml/)

> ### [Ta lekcija je na voljo tudi v jeziku R!](../../../../4-Classification/1-Introduction/solution/R/lesson_10.html)

### Uvod

Klasifikacija je ena temeljnih dejavnosti raziskovalcev strojnega uƒçenja in podatkovnih znanstvenikov. Od osnovne klasifikacije binarne vrednosti ("ali je to e-po≈°tno sporoƒçilo vsiljena po≈°ta ali ne?") do zapletene klasifikacije slik in segmentacije s pomoƒçjo raƒçunalni≈°kega vida, je vedno koristno znati razvrstiti podatke v razrede in jim zastaviti vpra≈°anja.

ƒåe proces opi≈°emo na bolj znanstven naƒçin, va≈°a metoda klasifikacije ustvari napovedni model, ki vam omogoƒça, da preslikate odnos med vhodnimi in izhodnimi spremenljivkami.

![binarna vs. veƒçrazredna klasifikacija](../../../../4-Classification/1-Introduction/images/binary-multiclass.png)

> Binarni in veƒçrazredni problemi za algoritme klasifikacije. Infografika: [Jen Looper](https://twitter.com/jenlooper)

Preden zaƒçnemo s procesom ƒçi≈°ƒçenja podatkov, njihove vizualizacije in priprave za naloge strojnega uƒçenja, se nauƒçimo nekaj veƒç o razliƒçnih naƒçinih, kako lahko strojno uƒçenje uporabimo za klasifikacijo podatkov.

Izpeljana iz [statistike](https://wikipedia.org/wiki/Statistical_classification), klasifikacija s klasiƒçnim strojnim uƒçenjem uporablja znaƒçilnosti, kot so `kadilec`, `te≈æa` in `starost`, za doloƒçanje _verjetnosti razvoja doloƒçene bolezni_. Kot tehnika nadzorovanega uƒçenja, podobna regresijskim vajam, ki ste jih izvajali prej, so va≈°i podatki oznaƒçeni, algoritmi strojnega uƒçenja pa te oznake uporabljajo za klasifikacijo in napovedovanje razredov (ali 'znaƒçilnosti') nabora podatkov ter njihovo dodelitev skupini ali izidu.

‚úÖ Vzemite si trenutek in si zamislite nabor podatkov o kuhinjah. Na katera vpra≈°anja bi lahko odgovoril veƒçrazredni model? Na katera vpra≈°anja bi lahko odgovoril binarni model? Kaj ƒçe bi ≈æeleli ugotoviti, ali doloƒçena kuhinja uporablja sabljiko? Kaj ƒçe bi ≈æeleli preveriti, ali bi lahko iz vreƒçke zvezdastega jane≈æa, artiƒçok, cvetaƒçe in hrena pripravili tipiƒçno indijsko jed?

[![Nore skrivnostne ko≈°are](https://img.youtube.com/vi/GuTeDbaNoEU/0.jpg)](https://youtu.be/GuTeDbaNoEU "Nore skrivnostne ko≈°are")

> üé• Kliknite zgornjo sliko za video. Celoten koncept oddaje 'Chopped' temelji na 'skrivnostni ko≈°ari', kjer morajo kuharji iz nakljuƒçnih sestavin pripraviti jed. Zagotovo bi jim model strojnega uƒçenja pomagal!

## Pozdravljen 'klasifikator'

Vpra≈°anje, ki si ga ≈æelimo zastaviti o tem naboru podatkov o kuhinjah, je pravzaprav **veƒçrazredno vpra≈°anje**, saj imamo na voljo veƒç potencialnih nacionalnih kuhinj. Glede na skupino sestavin, v kateri od teh ≈°tevilnih razredov bodo podatki ustrezali?

Scikit-learn ponuja veƒç razliƒçnih algoritmov za klasifikacijo podatkov, odvisno od vrste problema, ki ga ≈æelite re≈°iti. V naslednjih dveh lekcijah se boste nauƒçili veƒç o teh algoritmih.

## Vaja - oƒçistite in uravnote≈æite svoje podatke

Prva naloga, preden zaƒçnemo s tem projektom, je oƒçistiti in **uravnote≈æiti** podatke za bolj≈°e rezultate. Zaƒçnite z prazno datoteko _notebook.ipynb_ v korenski mapi te mape.

Prva stvar, ki jo morate namestiti, je [imblearn](https://imbalanced-learn.org/stable/). To je paket Scikit-learn, ki vam bo omogoƒçil bolj≈°e uravnote≈æenje podatkov (veƒç o tej nalogi boste izvedeli v nadaljevanju).

1. Za namestitev `imblearn` za≈æenite `pip install`, kot sledi:

    ```python
    pip install imblearn
    ```

1. Uvozite pakete, ki jih potrebujete za uvoz in vizualizacijo podatkov, prav tako uvozite `SMOTE` iz `imblearn`.

    ```python
    import pandas as pd
    import matplotlib.pyplot as plt
    import matplotlib as mpl
    import numpy as np
    from imblearn.over_sampling import SMOTE
    ```

    Zdaj ste pripravljeni na uvoz podatkov.

1. Naslednja naloga je uvoz podatkov:

    ```python
    df  = pd.read_csv('../data/cuisines.csv')
    ```

   Z uporabo `read_csv()` boste prebrali vsebino csv datoteke _cusines.csv_ in jo shranili v spremenljivko `df`.

1. Preverite obliko podatkov:

    ```python
    df.head()
    ```

   Prvih pet vrstic izgleda takole:

    ```output
    |     | Unnamed: 0 | cuisine | almond | angelica | anise | anise_seed | apple | apple_brandy | apricot | armagnac | ... | whiskey | white_bread | white_wine | whole_grain_wheat_flour | wine | wood | yam | yeast | yogurt | zucchini |
    | --- | ---------- | ------- | ------ | -------- | ----- | ---------- | ----- | ------------ | ------- | -------- | --- | ------- | ----------- | ---------- | ----------------------- | ---- | ---- | --- | ----- | ------ | -------- |
    | 0   | 65         | indian  | 0      | 0        | 0     | 0          | 0     | 0            | 0       | 0        | ... | 0       | 0           | 0          | 0                       | 0    | 0    | 0   | 0     | 0      | 0        |
    | 1   | 66         | indian  | 1      | 0        | 0     | 0          | 0     | 0            | 0       | 0        | ... | 0       | 0           | 0          | 0                       | 0    | 0    | 0   | 0     | 0      | 0        |
    | 2   | 67         | indian  | 0      | 0        | 0     | 0          | 0     | 0            | 0       | 0        | ... | 0       | 0           | 0          | 0                       | 0    | 0    | 0   | 0     | 0      | 0        |
    | 3   | 68         | indian  | 0      | 0        | 0     | 0          | 0     | 0            | 0       | 0        | ... | 0       | 0           | 0          | 0                       | 0    | 0    | 0   | 0     | 0      | 0        |
    | 4   | 69         | indian  | 0      | 0        | 0     | 0          | 0     | 0            | 0       | 0        | ... | 0       | 0           | 0          | 0                       | 0    | 0    | 0   | 0     | 1      | 0        |
    ```

1. Pridobite informacije o teh podatkih z uporabo `info()`:

    ```python
    df.info()
    ```

    Va≈° izpis je podoben:

    ```output
    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 2448 entries, 0 to 2447
    Columns: 385 entries, Unnamed: 0 to zucchini
    dtypes: int64(384), object(1)
    memory usage: 7.2+ MB
    ```

## Vaja - spoznavanje kuhinj

Zdaj postane delo bolj zanimivo. Odkrijmo porazdelitev podatkov po kuhinjah.

1. Prikaz podatkov kot stolpce z uporabo `barh()`:

    ```python
    df.cuisine.value_counts().plot.barh()
    ```

    ![porazdelitev podatkov o kuhinjah](../../../../4-Classification/1-Introduction/images/cuisine-dist.png)

    ≈†tevilo kuhinj je omejeno, vendar je porazdelitev podatkov neenakomerna. To lahko popravite! Preden to storite, razi≈°ƒçite ≈°e malo.

1. Ugotovite, koliko podatkov je na voljo za vsako kuhinjo, in jih izpi≈°ite:

    ```python
    thai_df = df[(df.cuisine == "thai")]
    japanese_df = df[(df.cuisine == "japanese")]
    chinese_df = df[(df.cuisine == "chinese")]
    indian_df = df[(df.cuisine == "indian")]
    korean_df = df[(df.cuisine == "korean")]
    
    print(f'thai df: {thai_df.shape}')
    print(f'japanese df: {japanese_df.shape}')
    print(f'chinese df: {chinese_df.shape}')
    print(f'indian df: {indian_df.shape}')
    print(f'korean df: {korean_df.shape}')
    ```

    Izpis izgleda takole:

    ```output
    thai df: (289, 385)
    japanese df: (320, 385)
    chinese df: (442, 385)
    indian df: (598, 385)
    korean df: (799, 385)
    ```

## Odkrijte sestavine

Zdaj lahko globlje razi≈°ƒçete podatke in ugotovite, katere so tipiƒçne sestavine za posamezno kuhinjo. Odstraniti morate ponavljajoƒçe se podatke, ki povzroƒçajo zmedo med kuhinjami, zato se lotimo tega problema.

1. Ustvarite funkcijo `create_ingredient()` v Pythonu za ustvarjanje podatkovnega okvira sestavin. Ta funkcija bo zaƒçela z odstranitvijo neuporabnega stolpca in razvrstila sestavine po njihovem ≈°tevilu:

    ```python
    def create_ingredient_df(df):
        ingredient_df = df.T.drop(['cuisine','Unnamed: 0']).sum(axis=1).to_frame('value')
        ingredient_df = ingredient_df[(ingredient_df.T != 0).any()]
        ingredient_df = ingredient_df.sort_values(by='value', ascending=False,
        inplace=False)
        return ingredient_df
    ```

   Zdaj lahko uporabite to funkcijo, da dobite idejo o desetih najbolj priljubljenih sestavinah po kuhinji.

1. Pokliƒçite `create_ingredient()` in jo prika≈æite z uporabo `barh()`:

    ```python
    thai_ingredient_df = create_ingredient_df(thai_df)
    thai_ingredient_df.head(10).plot.barh()
    ```

    ![tajska](../../../../4-Classification/1-Introduction/images/thai.png)

1. Enako storite za japonske podatke:

    ```python
    japanese_ingredient_df = create_ingredient_df(japanese_df)
    japanese_ingredient_df.head(10).plot.barh()
    ```

    ![japonska](../../../../4-Classification/1-Introduction/images/japanese.png)

1. Zdaj za kitajske sestavine:

    ```python
    chinese_ingredient_df = create_ingredient_df(chinese_df)
    chinese_ingredient_df.head(10).plot.barh()
    ```

    ![kitajska](../../../../4-Classification/1-Introduction/images/chinese.png)

1. Prika≈æite indijske sestavine:

    ```python
    indian_ingredient_df = create_ingredient_df(indian_df)
    indian_ingredient_df.head(10).plot.barh()
    ```

    ![indijska](../../../../4-Classification/1-Introduction/images/indian.png)

1. Na koncu prika≈æite korejske sestavine:

    ```python
    korean_ingredient_df = create_ingredient_df(korean_df)
    korean_ingredient_df.head(10).plot.barh()
    ```

    ![korejska](../../../../4-Classification/1-Introduction/images/korean.png)

1. Zdaj odstranite najpogostej≈°e sestavine, ki povzroƒçajo zmedo med razliƒçnimi kuhinjami, z uporabo `drop()`:

   Vsi imajo radi ri≈æ, ƒçesen in ingver!

    ```python
    feature_df= df.drop(['cuisine','Unnamed: 0','rice','garlic','ginger'], axis=1)
    labels_df = df.cuisine #.unique()
    feature_df.head()
    ```

## Uravnote≈æite nabor podatkov

Zdaj, ko ste oƒçistili podatke, uporabite [SMOTE](https://imbalanced-learn.org/dev/references/generated/imblearn.over_sampling.SMOTE.html) - "Synthetic Minority Over-sampling Technique" - za njihovo uravnote≈æenje.

1. Pokliƒçite `fit_resample()`, ta strategija ustvari nove vzorce z interpolacijo.

    ```python
    oversample = SMOTE()
    transformed_feature_df, transformed_label_df = oversample.fit_resample(feature_df, labels_df)
    ```

    Z uravnote≈æenjem podatkov boste dosegli bolj≈°e rezultate pri klasifikaciji. Pomislite na binarno klasifikacijo. ƒåe je veƒçina va≈°ih podatkov enega razreda, bo model strojnega uƒçenja ta razred pogosteje napovedal, zgolj zato, ker je zanj veƒç podatkov. Uravnote≈æenje podatkov odstrani to neravnovesje.

1. Zdaj lahko preverite ≈°tevilo oznak na sestavino:

    ```python
    print(f'new label count: {transformed_label_df.value_counts()}')
    print(f'old label count: {df.cuisine.value_counts()}')
    ```

    Va≈° izpis izgleda takole:

    ```output
    new label count: korean      799
    chinese     799
    indian      799
    japanese    799
    thai        799
    Name: cuisine, dtype: int64
    old label count: korean      799
    indian      598
    chinese     442
    japanese    320
    thai        289
    Name: cuisine, dtype: int64
    ```

    Podatki so zdaj ƒçisti, uravnote≈æeni in zelo okusni!

1. Zadnji korak je shranjevanje uravnote≈æenih podatkov, vkljuƒçno z oznakami in znaƒçilnostmi, v nov podatkovni okvir, ki ga lahko izvozite v datoteko:

    ```python
    transformed_df = pd.concat([transformed_label_df,transformed_feature_df],axis=1, join='outer')
    ```

1. ≈†e enkrat si oglejte podatke z uporabo `transformed_df.head()` in `transformed_df.info()`. Shranite kopijo teh podatkov za uporabo v prihodnjih lekcijah:

    ```python
    transformed_df.head()
    transformed_df.info()
    transformed_df.to_csv("../data/cleaned_cuisines.csv")
    ```

    Ta sve≈æ CSV je zdaj na voljo v korenski mapi podatkov.

---

## üöÄIzziv

Ta uƒçni naƒçrt vsebuje veƒç zanimivih naborov podatkov. Prebrskajte mape `data` in preverite, ali katera vsebuje nabore podatkov, ki bi bili primerni za binarno ali veƒçrazredno klasifikacijo? Na katera vpra≈°anja bi lahko odgovorili s tem naborom podatkov?

## [Po-lekcijski kviz](https://ff-quizzes.netlify.app/en/ml/)

## Pregled in samostojno uƒçenje

Razi≈°ƒçite API za SMOTE. Za katere primere uporabe je najbolj primeren? Katere te≈æave re≈°uje?

## Naloga 

[Razi≈°ƒçite metode klasifikacije](assignment.md)

---

**Omejitev odgovornosti**:  
Ta dokument je bil preveden z uporabo storitve za strojno prevajanje [Co-op Translator](https://github.com/Azure/co-op-translator). ƒåeprav si prizadevamo za natanƒçnost, vas prosimo, da upo≈°tevate, da lahko avtomatizirani prevodi vsebujejo napake ali netoƒçnosti. Izvirni dokument v njegovem izvirnem jeziku je treba obravnavati kot avtoritativni vir. Za kljuƒçne informacije priporoƒçamo strokovno ƒçlove≈°ko prevajanje. Ne prevzemamo odgovornosti za morebitna nesporazumevanja ali napaƒçne razlage, ki izhajajo iz uporabe tega prevoda.