<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "e0b75f73e4a90d45181dc5581fe2ef5c",
  "translation_date": "2025-09-05T21:47:31+00:00",
  "source_file": "3-Web-App/1-Web-App/README.md",
  "language_code": "no"
}
-->
# Bygg en webapplikasjon for Ã¥ bruke en ML-modell

I denne leksjonen skal du trene en ML-modell pÃ¥ et datasett som er helt utenomjordisk: _UFO-observasjoner fra det siste Ã¥rhundret_, hentet fra NUFORCs database.

Du vil lÃ¦re:

- Hvordan 'pickle' en trent modell
- Hvordan bruke den modellen i en Flask-applikasjon

Vi fortsetter Ã¥ bruke notebooks for Ã¥ rense data og trene modellen vÃ¥r, men du kan ta prosessen et steg videre ved Ã¥ utforske hvordan man bruker en modell "ute i det fri", sÃ¥ Ã¥ si: i en webapplikasjon.

For Ã¥ gjÃ¸re dette mÃ¥ du bygge en webapplikasjon ved hjelp av Flask.

## [Quiz fÃ¸r leksjonen](https://ff-quizzes.netlify.app/en/ml/)

## Bygge en applikasjon

Det finnes flere mÃ¥ter Ã¥ bygge webapplikasjoner som kan bruke maskinlÃ¦ringsmodeller. Din webarkitektur kan pÃ¥virke hvordan modellen din blir trent. Tenk deg at du jobber i en bedrift der data science-gruppen har trent en modell som de vil at du skal bruke i en applikasjon.

### Vurderinger

Det er mange spÃ¸rsmÃ¥l du mÃ¥ stille:

- **Er det en webapplikasjon eller en mobilapplikasjon?** Hvis du bygger en mobilapplikasjon eller trenger Ã¥ bruke modellen i en IoT-sammenheng, kan du bruke [TensorFlow Lite](https://www.tensorflow.org/lite/) og bruke modellen i en Android- eller iOS-applikasjon.
- **Hvor skal modellen ligge?** I skyen eller lokalt?
- **StÃ¸tte for offline bruk.** MÃ¥ applikasjonen fungere offline?
- **Hvilken teknologi ble brukt til Ã¥ trene modellen?** Den valgte teknologien kan pÃ¥virke verktÃ¸yene du mÃ¥ bruke.
    - **Bruke TensorFlow.** Hvis du trener en modell med TensorFlow, for eksempel, gir det Ã¸kosystemet muligheten til Ã¥ konvertere en TensorFlow-modell for bruk i en webapplikasjon ved hjelp av [TensorFlow.js](https://www.tensorflow.org/js/).
    - **Bruke PyTorch.** Hvis du bygger en modell med et bibliotek som [PyTorch](https://pytorch.org/), har du muligheten til Ã¥ eksportere den i [ONNX](https://onnx.ai/) (Open Neural Network Exchange)-format for bruk i JavaScript-webapplikasjoner som kan bruke [Onnx Runtime](https://www.onnxruntime.ai/). Denne muligheten vil bli utforsket i en fremtidig leksjon for en Scikit-learn-trent modell.
    - **Bruke Lobe.ai eller Azure Custom Vision.** Hvis du bruker et ML SaaS (Software as a Service)-system som [Lobe.ai](https://lobe.ai/) eller [Azure Custom Vision](https://azure.microsoft.com/services/cognitive-services/custom-vision-service/?WT.mc_id=academic-77952-leestott) for Ã¥ trene en modell, gir denne typen programvare mÃ¥ter Ã¥ eksportere modellen for mange plattformer, inkludert Ã¥ bygge en skreddersydd API som kan forespÃ¸rres i skyen av din online-applikasjon.

Du har ogsÃ¥ muligheten til Ã¥ bygge en hel Flask-webapplikasjon som kan trene modellen selv i en nettleser. Dette kan ogsÃ¥ gjÃ¸res ved hjelp av TensorFlow.js i en JavaScript-sammenheng.

For vÃ¥rt formÃ¥l, siden vi har jobbet med Python-baserte notebooks, la oss utforske trinnene du mÃ¥ ta for Ã¥ eksportere en trent modell fra en slik notebook til et format som kan leses av en Python-bygget webapplikasjon.

## VerktÃ¸y

For denne oppgaven trenger du to verktÃ¸y: Flask og Pickle, begge som kjÃ¸rer pÃ¥ Python.

âœ… Hva er [Flask](https://palletsprojects.com/p/flask/)? Definert som et 'mikro-rammeverk' av sine skapere, gir Flask de grunnleggende funksjonene til webrammeverk ved bruk av Python og en templatemotor for Ã¥ bygge nettsider. Ta en titt pÃ¥ [denne lÃ¦ringsmodulen](https://docs.microsoft.com/learn/modules/python-flask-build-ai-web-app?WT.mc_id=academic-77952-leestott) for Ã¥ Ã¸ve pÃ¥ Ã¥ bygge med Flask.

âœ… Hva er [Pickle](https://docs.python.org/3/library/pickle.html)? Pickle ðŸ¥’ er et Python-modul som serialiserer og de-serialiserer en Python-objektstruktur. NÃ¥r du 'pickler' en modell, serialiserer eller flater du ut strukturen dens for bruk pÃ¥ nettet. VÃ¦r forsiktig: pickle er ikke iboende sikkert, sÃ¥ vÃ¦r forsiktig hvis du blir bedt om Ã¥ 'un-pickle' en fil. En picklet fil har suffikset `.pkl`.

## Ã˜velse - rense dataene dine

I denne leksjonen skal du bruke data fra 80,000 UFO-observasjoner, samlet av [NUFORC](https://nuforc.org) (The National UFO Reporting Center). Disse dataene har noen interessante beskrivelser av UFO-observasjoner, for eksempel:

- **Lang beskrivelse.** "En mann kommer ut fra en lysstrÃ¥le som skinner pÃ¥ en gresslette om natten, og han lÃ¸per mot Texas Instruments parkeringsplass".
- **Kort beskrivelse.** "lysene jaget oss".

Regnearket [ufos.csv](../../../../3-Web-App/1-Web-App/data/ufos.csv) inkluderer kolonner om `city`, `state` og `country` der observasjonen fant sted, objektets `shape` og dets `latitude` og `longitude`.

I den tomme [notebook](../../../../3-Web-App/1-Web-App/notebook.ipynb) som er inkludert i denne leksjonen:

1. importer `pandas`, `matplotlib` og `numpy` som du gjorde i tidligere leksjoner, og importer UFO-regnearket. Du kan ta en titt pÃ¥ et eksempel pÃ¥ datasettet:

    ```python
    import pandas as pd
    import numpy as np
    
    ufos = pd.read_csv('./data/ufos.csv')
    ufos.head()
    ```

1. Konverter UFO-dataene til en liten dataframe med nye titler. Sjekk de unike verdiene i `Country`-feltet.

    ```python
    ufos = pd.DataFrame({'Seconds': ufos['duration (seconds)'], 'Country': ufos['country'],'Latitude': ufos['latitude'],'Longitude': ufos['longitude']})
    
    ufos.Country.unique()
    ```

1. NÃ¥ kan du redusere mengden data vi trenger Ã¥ hÃ¥ndtere ved Ã¥ fjerne eventuelle nullverdier og kun importere observasjoner mellom 1-60 sekunder:

    ```python
    ufos.dropna(inplace=True)
    
    ufos = ufos[(ufos['Seconds'] >= 1) & (ufos['Seconds'] <= 60)]
    
    ufos.info()
    ```

1. Importer Scikit-learns `LabelEncoder`-bibliotek for Ã¥ konvertere tekstverdier for land til et tall:

    âœ… LabelEncoder koder data alfabetisk

    ```python
    from sklearn.preprocessing import LabelEncoder
    
    ufos['Country'] = LabelEncoder().fit_transform(ufos['Country'])
    
    ufos.head()
    ```

    Dataene dine bÃ¸r se slik ut:

    ```output
    	Seconds	Country	Latitude	Longitude
    2	20.0	3		53.200000	-2.916667
    3	20.0	4		28.978333	-96.645833
    14	30.0	4		35.823889	-80.253611
    23	60.0	4		45.582778	-122.352222
    24	3.0		3		51.783333	-0.783333
    ```

## Ã˜velse - bygg modellen din

NÃ¥ kan du gjÃ¸re deg klar til Ã¥ trene en modell ved Ã¥ dele dataene inn i trenings- og testgrupper.

1. Velg de tre funksjonene du vil trene pÃ¥ som din X-vektor, og y-vektoren vil vÃ¦re `Country`. Du vil kunne legge inn `Seconds`, `Latitude` og `Longitude` og fÃ¥ en land-ID tilbake.

    ```python
    from sklearn.model_selection import train_test_split
    
    Selected_features = ['Seconds','Latitude','Longitude']
    
    X = ufos[Selected_features]
    y = ufos['Country']
    
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)
    ```

1. Tren modellen din ved hjelp av logistisk regresjon:

    ```python
    from sklearn.metrics import accuracy_score, classification_report
    from sklearn.linear_model import LogisticRegression
    model = LogisticRegression()
    model.fit(X_train, y_train)
    predictions = model.predict(X_test)
    
    print(classification_report(y_test, predictions))
    print('Predicted labels: ', predictions)
    print('Accuracy: ', accuracy_score(y_test, predictions))
    ```

NÃ¸yaktigheten er ikke dÃ¥rlig **(rundt 95%)**, ikke overraskende, siden `Country` og `Latitude/Longitude` korrelerer.

Modellen du opprettet er ikke veldig revolusjonerende, siden du burde kunne utlede et `Country` fra dets `Latitude` og `Longitude`, men det er en god Ã¸velse Ã¥ prÃ¸ve Ã¥ trene fra rÃ¥data som du renset, eksporterte, og deretter bruke denne modellen i en webapplikasjon.

## Ã˜velse - 'pickle' modellen din

NÃ¥ er det pÃ¥ tide Ã¥ _pickle_ modellen din! Du kan gjÃ¸re det med noen fÃ¥ linjer kode. NÃ¥r den er _picklet_, last inn den picklete modellen og test den mot et eksempeldataarray som inneholder verdier for sekunder, breddegrad og lengdegrad.

```python
import pickle
model_filename = 'ufo-model.pkl'
pickle.dump(model, open(model_filename,'wb'))

model = pickle.load(open('ufo-model.pkl','rb'))
print(model.predict([[50,44,-12]]))
```

Modellen returnerer **'3'**, som er landkoden for Storbritannia. Utrolig! ðŸ‘½

## Ã˜velse - bygg en Flask-applikasjon

NÃ¥ kan du bygge en Flask-applikasjon for Ã¥ kalle modellen din og returnere lignende resultater, men pÃ¥ en mer visuelt tiltalende mÃ¥te.

1. Start med Ã¥ opprette en mappe kalt **web-app** ved siden av _notebook.ipynb_-filen der _ufo-model.pkl_-filen ligger.

1. I den mappen opprett tre flere mapper: **static**, med en mappe **css** inni, og **templates**. Du bÃ¸r nÃ¥ ha fÃ¸lgende filer og kataloger:

    ```output
    web-app/
      static/
        css/
      templates/
    notebook.ipynb
    ufo-model.pkl
    ```

    âœ… Se lÃ¸sningsmappen for en visning av den ferdige applikasjonen

1. Den fÃ¸rste filen du oppretter i _web-app_-mappen er **requirements.txt**-filen. Som _package.json_ i en JavaScript-applikasjon, lister denne filen opp avhengigheter som kreves av applikasjonen. I **requirements.txt** legg til linjene:

    ```text
    scikit-learn
    pandas
    numpy
    flask
    ```

1. NÃ¥, kjÃ¸r denne filen ved Ã¥ navigere til _web-app_:

    ```bash
    cd web-app
    ```

1. I terminalen din, skriv `pip install` for Ã¥ installere bibliotekene som er oppfÃ¸rt i _requirements.txt_:

    ```bash
    pip install -r requirements.txt
    ```

1. NÃ¥ er du klar til Ã¥ opprette tre flere filer for Ã¥ fullfÃ¸re applikasjonen:

    1. Opprett **app.py** i roten.
    2. Opprett **index.html** i _templates_-katalogen.
    3. Opprett **styles.css** i _static/css_-katalogen.

1. Bygg ut _styles.css_-filen med noen fÃ¥ stiler:

    ```css
    body {
    	width: 100%;
    	height: 100%;
    	font-family: 'Helvetica';
    	background: black;
    	color: #fff;
    	text-align: center;
    	letter-spacing: 1.4px;
    	font-size: 30px;
    }
    
    input {
    	min-width: 150px;
    }
    
    .grid {
    	width: 300px;
    	border: 1px solid #2d2d2d;
    	display: grid;
    	justify-content: center;
    	margin: 20px auto;
    }
    
    .box {
    	color: #fff;
    	background: #2d2d2d;
    	padding: 12px;
    	display: inline-block;
    }
    ```

1. Deretter bygger du ut _index.html_-filen:

    ```html
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>ðŸ›¸ UFO Appearance Prediction! ðŸ‘½</title>
        <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
      </head>
    
      <body>
        <div class="grid">
    
          <div class="box">
    
            <p>According to the number of seconds, latitude and longitude, which country is likely to have reported seeing a UFO?</p>
    
            <form action="{{ url_for('predict')}}" method="post">
              <input type="number" name="seconds" placeholder="Seconds" required="required" min="0" max="60" />
              <input type="text" name="latitude" placeholder="Latitude" required="required" />
              <input type="text" name="longitude" placeholder="Longitude" required="required" />
              <button type="submit" class="btn">Predict country where the UFO is seen</button>
            </form>
    
            <p>{{ prediction_text }}</p>
    
          </div>
    
        </div>
    
      </body>
    </html>
    ```

    Ta en titt pÃ¥ templatingen i denne filen. Legg merke til 'mustache'-syntaksen rundt variabler som vil bli levert av applikasjonen, som prediksjonsteksten: `{{}}`. Det er ogsÃ¥ et skjema som sender en prediksjon til `/predict`-ruten.

    Til slutt er du klar til Ã¥ bygge Python-filen som driver forbruket av modellen og visningen av prediksjoner:

1. I `app.py` legg til:

    ```python
    import numpy as np
    from flask import Flask, request, render_template
    import pickle
    
    app = Flask(__name__)
    
    model = pickle.load(open("./ufo-model.pkl", "rb"))
    
    
    @app.route("/")
    def home():
        return render_template("index.html")
    
    
    @app.route("/predict", methods=["POST"])
    def predict():
    
        int_features = [int(x) for x in request.form.values()]
        final_features = [np.array(int_features)]
        prediction = model.predict(final_features)
    
        output = prediction[0]
    
        countries = ["Australia", "Canada", "Germany", "UK", "US"]
    
        return render_template(
            "index.html", prediction_text="Likely country: {}".format(countries[output])
        )
    
    
    if __name__ == "__main__":
        app.run(debug=True)
    ```

    > ðŸ’¡ Tips: nÃ¥r du legger til [`debug=True`](https://www.askpython.com/python-modules/flask/flask-debug-mode) mens du kjÃ¸rer webapplikasjonen ved hjelp av Flask, vil eventuelle endringer du gjÃ¸r i applikasjonen bli reflektert umiddelbart uten behov for Ã¥ starte serveren pÃ¥ nytt. VÃ¦r oppmerksom! Ikke aktiver denne modusen i en produksjonsapplikasjon.

Hvis du kjÃ¸rer `python app.py` eller `python3 app.py` - starter webserveren din opp lokalt, og du kan fylle ut et kort skjema for Ã¥ fÃ¥ svar pÃ¥ ditt brennende spÃ¸rsmÃ¥l om hvor UFO-er har blitt observert!

FÃ¸r du gjÃ¸r det, ta en titt pÃ¥ delene av `app.py`:

1. FÃ¸rst lastes avhengighetene og applikasjonen starter.
1. Deretter importeres modellen.
1. Deretter rendres index.html pÃ¥ hjemmeruten.

PÃ¥ `/predict`-ruten skjer flere ting nÃ¥r skjemaet sendes inn:

1. Skjemavariablene samles og konverteres til et numpy-array. De sendes deretter til modellen, og en prediksjon returneres.
2. Landene som vi Ã¸nsker skal vises, rendres pÃ¥ nytt som lesbar tekst fra deres predikerte landkode, og den verdien sendes tilbake til index.html for Ã¥ bli rendret i templaten.

Ã… bruke en modell pÃ¥ denne mÃ¥ten, med Flask og en picklet modell, er relativt enkelt. Det vanskeligste er Ã¥ forstÃ¥ hvilken form dataene mÃ¥ ha for Ã¥ bli sendt til modellen for Ã¥ fÃ¥ en prediksjon. Det avhenger helt av hvordan modellen ble trent. Denne har tre datapunkter som mÃ¥ legges inn for Ã¥ fÃ¥ en prediksjon.

I en profesjonell setting kan du se hvor viktig god kommunikasjon er mellom de som trener modellen og de som bruker den i en web- eller mobilapplikasjon. I vÃ¥rt tilfelle er det bare Ã©n person, deg!

---

## ðŸš€ Utfordring

I stedet for Ã¥ jobbe i en notebook og importere modellen til Flask-applikasjonen, kan du trene modellen direkte i Flask-applikasjonen! PrÃ¸v Ã¥ konvertere Python-koden din i notebooken, kanskje etter at dataene dine er renset, for Ã¥ trene modellen fra applikasjonen pÃ¥ en rute kalt `train`. Hva er fordeler og ulemper med Ã¥ bruke denne metoden?

## [Quiz etter leksjonen](https://ff-quizzes.netlify.app/en/ml/)

## Gjennomgang og selvstudium

Det finnes mange mÃ¥ter Ã¥ bygge en webapplikasjon for Ã¥ bruke ML-modeller. Lag en liste over mÃ¥tene du kan bruke JavaScript eller Python til Ã¥ bygge en webapplikasjon som utnytter maskinlÃ¦ring. Tenk pÃ¥ arkitektur: bÃ¸r modellen bli vÃ¦rende i applikasjonen eller ligge i skyen? Hvis det siste, hvordan ville du fÃ¥ tilgang til den? Tegn opp en arkitekturmodell for en anvendt ML-weblÃ¸sning.

## Oppgave

[PrÃ¸v en annen modell](assignment.md)

---

**Ansvarsfraskrivelse**:  
Dette dokumentet er oversatt ved hjelp av AI-oversettelsestjenesten [Co-op Translator](https://github.com/Azure/co-op-translator). Selv om vi streber etter nÃ¸yaktighet, vÃ¦r oppmerksom pÃ¥ at automatiserte oversettelser kan inneholde feil eller unÃ¸yaktigheter. Det originale dokumentet pÃ¥ sitt opprinnelige sprÃ¥k bÃ¸r anses som den autoritative kilden. For kritisk informasjon anbefales profesjonell menneskelig oversettelse. Vi er ikke ansvarlige for misforstÃ¥elser eller feiltolkninger som oppstÃ¥r ved bruk av denne oversettelsen.