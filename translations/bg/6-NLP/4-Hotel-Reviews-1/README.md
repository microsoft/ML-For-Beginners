<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8d32dadeda93c6fb5c43619854882ab1",
  "translation_date": "2025-09-05T01:24:22+00:00",
  "source_file": "6-NLP/4-Hotel-Reviews-1/README.md",
  "language_code": "bg"
}
-->
# Анализ на настроения с хотелски ревюта - обработка на данни

В този раздел ще използвате техниките от предишните уроци, за да направите изследователски анализ на голям набор от данни. След като придобиете добро разбиране за полезността на различните колони, ще научите:

- как да премахнете ненужните колони
- как да изчислите нови данни на базата на съществуващите колони
- как да запазите получения набор от данни за използване в крайната задача

## [Тест преди лекцията](https://ff-quizzes.netlify.app/en/ml/)

### Въведение

Досега научихте как текстовите данни се различават от числовите типове данни. Ако текстът е написан или изговорен от човек, той може да бъде анализиран за откриване на модели, честоти, настроения и значения. Този урок ви въвежда в реален набор от данни с реално предизвикателство: **[515K Хотелски ревюта в Европа](https://www.kaggle.com/jiashenliu/515k-hotel-reviews-data-in-europe)**, който включва [CC0: Лиценз за обществено достояние](https://creativecommons.org/publicdomain/zero/1.0/). Данните са събрани от Booking.com от публични източници. Създателят на набора от данни е Jiashen Liu.

### Подготовка

Ще ви е необходимо:

* Възможност за изпълнение на .ipynb файлове с Python 3
* pandas
* NLTK, [което трябва да инсталирате локално](https://www.nltk.org/install.html)
* Наборът от данни, който е наличен в Kaggle [515K Хотелски ревюта в Европа](https://www.kaggle.com/jiashenliu/515k-hotel-reviews-data-in-europe). Размерът му е около 230 MB след разархивиране. Изтеглете го в основната папка `/data`, свързана с тези уроци по NLP.

## Изследователски анализ на данни

Това предизвикателство предполага, че изграждате бот за препоръки на хотели, използвайки анализ на настроения и оценки от гостите. Наборът от данни, който ще използвате, включва ревюта на 1493 различни хотела в 6 града.

С помощта на Python, набор от данни с хотелски ревюта и анализа на настроенията на NLTK можете да откриете:

* Кои са най-често използваните думи и фрази в ревютата?
* Дали официалните *тагове*, описващи хотел, корелират с оценките на ревютата (например, дали има повече негативни ревюта за определен хотел от *Семейства с малки деца* отколкото от *Самостоятелни пътници*, което може да показва, че хотелът е по-подходящ за *Самостоятелни пътници*)?
* Дали оценките за настроенията на NLTK "съвпадат" с числовата оценка на хотелските ревюта?

#### Набор от данни

Нека разгледаме набора от данни, който сте изтеглили и запазили локално. Отворете файла в редактор като VS Code или дори Excel.

Заглавията в набора от данни са следните:

*Hotel_Address, Additional_Number_of_Scoring, Review_Date, Average_Score, Hotel_Name, Reviewer_Nationality, Negative_Review, Review_Total_Negative_Word_Counts, Total_Number_of_Reviews, Positive_Review, Review_Total_Positive_Word_Counts, Total_Number_of_Reviews_Reviewer_Has_Given, Reviewer_Score, Tags, days_since_review, lat, lng*

Ето ги групирани по начин, който може да е по-лесен за разглеждане:
##### Колони за хотели

* `Hotel_Name`, `Hotel_Address`, `lat` (ширина), `lng` (дължина)
  * С помощта на *lat* и *lng* можете да създадете карта с Python, показваща местоположенията на хотелите (може би оцветени според негативните и позитивните ревюта)
  * Hotel_Address не е очевидно полезен за нас и вероятно ще го заменим с държава за по-лесно сортиране и търсене

**Колони за мета-ревюта на хотели**

* `Average_Score`
  * Според създателя на набора от данни, тази колона представлява *Средна оценка на хотела, изчислена на базата на последния коментар през последната година*. Това изглежда като необичаен начин за изчисляване на оценката, но това са данните, които са събрани, така че засега ще ги приемем за достоверни.

  ✅ На базата на другите колони в тези данни, можете ли да измислите друг начин за изчисляване на средната оценка?

* `Total_Number_of_Reviews`
  * Общият брой ревюта, които този хотел е получил - не е ясно (без да напишем код) дали това се отнася за ревютата в набора от данни.
* `Additional_Number_of_Scoring`
  * Това означава, че е дадена оценка, но не е написано позитивно или негативно ревю от рецензента.

**Колони за ревюта**

- `Reviewer_Score`
  - Това е числова стойност с максимум 1 десетична цифра между минималната и максималната стойност 2.5 и 10
  - Не е обяснено защо 2.5 е най-ниската възможна оценка
- `Negative_Review`
  - Ако рецензентът не е написал нищо, това поле ще съдържа "**No Negative**"
  - Имайте предвид, че рецензент може да напише позитивно ревю в колоната за негативни ревюта (например "няма нищо лошо в този хотел")
- `Review_Total_Negative_Word_Counts`
  - По-голям брой негативни думи показва по-ниска оценка (без да се проверява настроението)
- `Positive_Review`
  - Ако рецензентът не е написал нищо, това поле ще съдържа "**No Positive**"
  - Имайте предвид, че рецензент може да напише негативно ревю в колоната за позитивни ревюта (например "няма нищо добро в този хотел")
- `Review_Total_Positive_Word_Counts`
  - По-голям брой позитивни думи показва по-висока оценка (без да се проверява настроението)
- `Review_Date` и `days_since_review`
  - Може да се приложи мярка за свежест или остарялост на ревюто (по-старите ревюта може да не са толкова точни, защото управлението на хотела се е променило, направени са ремонти, добавен е басейн и т.н.)
- `Tags`
  - Това са кратки описания, които рецензентът може да избере, за да опише типа гост, който е бил (например самостоятелен или семейство), типа стая, която е имал, продължителността на престоя и как е подадено ревюто.
  - За съжаление, използването на тези тагове е проблематично, вижте секцията по-долу, която обсъжда тяхната полезност.

**Колони за рецензенти**

- `Total_Number_of_Reviews_Reviewer_Has_Given`
  - Това може да бъде фактор в модел за препоръки, например, ако можете да определите, че по-продуктивните рецензенти със стотици ревюта са по-склонни да бъдат негативни, отколкото позитивни. Въпреки това, рецензентът на всяко конкретно ревю не е идентифициран с уникален код и следователно не може да бъде свързан с набор от ревюта. Има 30 рецензенти със 100 или повече ревюта, но е трудно да се види как това може да помогне на модела за препоръки.
- `Reviewer_Nationality`
  - Някои хора може да мислят, че определени националности са по-склонни да дават позитивни или негативни ревюта поради национална склонност. Бъдете внимателни при изграждането на такива анекдотични възгледи в моделите си. Това са национални (а понякога и расови) стереотипи, и всеки рецензент е индивидуалност, която е написала ревю на базата на своя опит. То може да е било филтрирано през много призми като предишни хотелски престои, изминато разстояние и личен темперамент. Да се мисли, че националността е причината за оценката на ревюто, е трудно да се оправдае.

##### Примери

| Средна оценка | Общо ревюта | Оценка на рецензента | Негативно ревю                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Позитивно ревю                 | Тагове                                                                                      |
| -------------- | ---------------------- | ---------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------- | ----------------------------------------------------------------------------------------- |
| 7.8            | 1945                   | 2.5              | Това в момента не е хотел, а строителна площадка. Бях тероризиран от рано сутринта и през целия ден с неприемлив строителен шум, докато си почивах след дълго пътуване и работех в стаята. Хората работеха през целия ден, например с къртачи в съседните стаи. Помолих за смяна на стаята, но не беше налична тиха стая. За да стане още по-лошо, ми беше начислена допълнителна такса. Напуснах вечерта, тъй като трябваше да тръгна рано сутринта, и получих подходяща сметка. Ден по-късно хотелът направи друга такса без мое съгласие, надвишаваща резервираната цена. Това е ужасно място. Не си причинявайте това, като резервирате тук. | Нищо. Ужасно място. Стойте далеч | Бизнес пътуване, двойка, стандартна двойна стая, престой 2 нощи |

Както виждате, този гост не е имал щастлив престой в този хотел. Хотелът има добра средна оценка от 7.8 и 1945 ревюта, но този рецензент му е дал 2.5 и е написал 115 думи за това колко негативен е бил престоят му. Ако не е написал нищо в колоната за позитивни ревюта, може да предположите, че няма нищо позитивно, но той е написал 7 думи на предупреждение. Ако просто броим думите вместо значението или настроението на думите, може да имаме изкривено виждане за намерението на рецензента. Странно, оценката му от 2.5 е объркваща, защото ако престоят в хотела е бил толкова лош, защо изобщо дава точки? При разглеждане на набора от данни отблизо ще видите, че най-ниската възможна оценка е 2.5, а не 0. Най-високата възможна оценка е 10.

##### Тагове

Както беше споменато по-горе, на пръв поглед идеята за използване на `Tags` за категоризиране на данните изглежда логична. За съжаление, тези тагове не са стандартизирани, което означава, че в даден хотел опциите може да са *Единична стая*, *Двойна стая* и *Тройна стая*, но в следващия хотел те са *Делукс единична стая*, *Класическа двойна стая* и *Екзекютив стая с кралско легло*. Това може да са едни и същи неща, но има толкова много вариации, че изборът става:

1. Опит за промяна на всички термини към един стандарт, което е много трудно, защото не е ясно какъв би бил пътят на конверсия във всеки случай (например *Класическа единична стая* се свързва с *Единична стая*, но *Супериорна стая с кралско легло и изглед към градина или град* е много по-трудно да се свърже)

1. Можем да вземем подход на NLP и да измерим честотата на определени термини като *Самостоятелен*, *Бизнес пътник* или *Семейство с малки деца*, както се отнасят за всеки хотел, и да включим това в препоръката.

Таговете обикновено (но не винаги) са едно поле, съдържащо списък от 5 до 6 стойности, разделени със запетаи, съответстващи на *Тип на пътуването*, *Тип на гостите*, *Тип на стаята*, *Брой нощи* и *Тип на устройството, от което е подадено ревюто*. Въпреки това, тъй като някои рецензенти не попълват всяко поле (може да оставят едно празно), стойностите не винаги са в същия ред.

Например, вземете *Тип на групата*. Има 1025 уникални възможности в това поле в колоната `Tags`, и за съжаление само някои от тях се отнасят за група (някои са тип стая и т.н.). Ако филтрирате само тези, които споменават семейство, резултатите съдържат много типове стаи *Семейна стая*. Ако включите термина *с*, т.е. броите стойностите *Семейство с*, резултатите са по-добри, с над 80,000 от 515,000 резултата, съдържащи фразата "Семейство с малки деца" или "Семейство с по-големи деца".

Това означава, че колоната за тагове не е напълно безполезна за нас, но ще изисква известна работа, за да я направим полезна.

##### Средна оценка на хотела

Има редица странности или несъответствия в набора от данни, които не мога да разбера, но са илюстрирани тук, за да сте наясно с тях, когато изграждате моделите си. Ако ги разберете, моля, уведомете ни в секцията за дискусии!

Наборът от данни има следните колони, свързани със средната оценка и броя на ревютата:

1. Hotel_Name
2. Additional_Number_of_Scoring
3. Average_Score
4. Total_Number_of_Reviews
5. Reviewer_Score  

Хотелът с най-много ревюта в този набор от данни е *Britannia International Hotel Canary Wharf* с 4789 ревюта от 515,000. Но ако погледнем стойността на `Total_Number_of_Reviews` за този хотел, тя е 9086. Може да предположите, че има много повече оценки без ревюта, така че може би трябва да добавим стойността от колоната `Additional_Number_of_Scoring`. Тази стойност е 2682, и добавянето й към 4789 ни дава 7471, което все още е с 1615 по-малко от `Total_Number_of_Reviews`.

Ако вземете колоната `Average_Score`, може да предположите, че тя е средната стойност на ревютата в набора от данни, но описанието от Kaggle е "*Средна оценка на хотела, изчислена на базата на последния коментар през последната година*". Това не изглежда много полезно, но можем да изчислим собствена средна стойност на базата на оценките на ревютата в набора от данни. Използвайки същия хотел като пример, средната оценка на хотела е дадена като 7.1, но изчислената оценка (средна оценка на рецензентите *в* набора от данни) е 6.8. Това е близко, но не същата стойност, и можем само да предположим, че оценките, дадени в ревютата от колоната `Additional_Number_of_Scoring`, са увеличили средната стойност до 7.1. За съжаление, без начин да тестваме или докажем това твърдение, е трудно да използваме или да се доверим на `Average_Score`, `Additional_Number_of_Scoring` и `Total_Number_of_Reviews`, когато те се базират на или се отнасят за данни, които нямаме.

За да усложним нещата още повече, хотелът с втория най-голям брой ревюта има изчислена средна оценка от 8.12, а `Average_Score` в набора от данни е 8.1. Дали тази правилна оценка е съвпадение или първият хотел е нес
> 🚨 Забележка за внимание
>
> Когато работите с този набор от данни, ще пишете код, който изчислява нещо от текста, без да се налага да го четете или анализирате сами. Това е същността на NLP – интерпретиране на смисъл или настроение, без да е необходимо човек да го прави. Въпреки това, е възможно да прочетете някои от негативните отзиви. Бих ви посъветвал да не го правите, защото няма нужда. Някои от тях са глупави или неуместни негативни отзиви за хотели, като например "Времето не беше хубаво" – нещо извън контрола на хотела или на когото и да било. Но има и тъмна страна на някои отзиви. Понякога негативните отзиви са расистки, сексистки или дискриминиращи по възраст. Това е неприятно, но очаквано в набор от данни, събран от публичен уебсайт. Някои рецензенти оставят отзиви, които биха ви се сторили отблъскващи, неудобни или разстройващи. По-добре е кодът да измери настроението, отколкото да ги четете сами и да се разстройвате. Това казано, малцинство са тези, които пишат такива неща, но те все пак съществуват.
## Упражнение - Изследване на данни
### Зареждане на данните

Достатъчно е визуално разглеждане на данните, сега ще напишете малко код и ще получите отговори! Тази секция използва библиотеката pandas. Вашата първа задача е да се уверите, че можете да заредите и прочетете CSV данните. Библиотеката pandas има бърз CSV зареждач, а резултатът се поставя в dataframe, както в предишните уроци. CSV файлът, който зареждаме, има над половин милион реда, но само 17 колони. Pandas ви предоставя много мощни начини за взаимодействие с dataframe, включително възможността да извършвате операции върху всеки ред.

Оттук нататък в този урок ще има кодови фрагменти, обяснения на кода и дискусия за значението на резултатите. Използвайте включения _notebook.ipynb_ за вашия код.

Нека започнем със зареждането на файла с данни, който ще използвате:

```python
# Load the hotel reviews from CSV
import pandas as pd
import time
# importing time so the start and end time can be used to calculate file loading time
print("Loading data file now, this could take a while depending on file size")
start = time.time()
# df is 'DataFrame' - make sure you downloaded the file to the data folder
df = pd.read_csv('../../data/Hotel_Reviews.csv')
end = time.time()
print("Loading took " + str(round(end - start, 2)) + " seconds")
```

След като данните са заредени, можем да извършим някои операции върху тях. Дръжте този код в началото на програмата си за следващата част.

## Изследване на данните

В този случай данните вече са *чисти*, което означава, че са готови за работа и не съдържат символи на други езици, които биха могли да затруднят алгоритми, очакващи само английски символи.

✅ Може да се наложи да работите с данни, които изискват първоначална обработка, за да бъдат форматирани преди прилагането на NLP техники, но не и този път. Ако трябваше, как бихте се справили с неанглийски символи?

Отделете момент, за да се уверите, че след като данните са заредени, можете да ги изследвате с код. Много лесно е да се фокусирате върху колоните `Negative_Review` и `Positive_Review`. Те са изпълнени с естествен текст за вашите NLP алгоритми. Но изчакайте! Преди да се впуснете в NLP и анализ на настроенията, следвайте кода по-долу, за да проверите дали стойностите, дадени в набора от данни, съответстват на стойностите, които изчислявате с pandas.

## Операции с dataframe

Първата задача в този урок е да проверите дали следните твърдения са верни, като напишете код, който изследва dataframe (без да го променяте).

> Както при много задачи за програмиране, има няколко начина да ги изпълните, но добър съвет е да го направите по най-простия и лесен начин, особено ако ще бъде по-лесно да разберете кода, когато се върнете към него в бъдеще. С dataframe има изчерпателен API, който често ще има начин да направите това, което искате, ефективно.

Третирайте следните въпроси като задачи за програмиране и се опитайте да им отговорите, без да гледате решението.

1. Изведете *формата* на dataframe, който току-що заредихте (формата е броят на редовете и колоните).
2. Изчислете честотата на националностите на рецензентите:
   1. Колко различни стойности има за колоната `Reviewer_Nationality` и кои са те?
   2. Коя националност на рецензентите е най-често срещана в набора от данни (изведете държава и брой рецензии)?
   3. Кои са следващите топ 10 най-често срещани националности и техният честотен брой?
3. Кой е най-често рецензираният хотел за всяка от топ 10 най-често срещани националности на рецензентите?
4. Колко рецензии има на хотел (честотен брой на хотел) в набора от данни?
5. Въпреки че има колона `Average_Score` за всеки хотел в набора от данни, можете също да изчислите средна оценка (като вземете средната стойност на всички оценки на рецензентите в набора от данни за всеки хотел). Добавете нова колона към вашия dataframe с заглавие на колоната `Calc_Average_Score`, която съдържа тази изчислена средна стойност.
6. Има ли хотели със същата (закръглена до 1 десетична точка) `Average_Score` и `Calc_Average_Score`?
   1. Опитайте да напишете Python функция, която приема Series (ред) като аргумент и сравнява стойностите, като извежда съобщение, когато стойностите не са равни. След това използвайте метода `.apply()`, за да обработите всеки ред с функцията.
7. Изчислете и изведете колко реда имат стойности "No Negative" в колоната `Negative_Review`.
8. Изчислете и изведете колко реда имат стойности "No Positive" в колоната `Positive_Review`.
9. Изчислете и изведете колко реда имат стойности "No Positive" в колоната `Positive_Review` **и** стойности "No Negative" в колоната `Negative_Review`.

### Отговори с код

1. Изведете *формата* на dataframe, който току-що заредихте (формата е броят на редовете и колоните).

   ```python
   print("The shape of the data (rows, cols) is " + str(df.shape))
   > The shape of the data (rows, cols) is (515738, 17)
   ```

2. Изчислете честотата на националностите на рецензентите:

   1. Колко различни стойности има за колоната `Reviewer_Nationality` и кои са те?
   2. Коя националност на рецензентите е най-често срещана в набора от данни (изведете държава и брой рецензии)?

   ```python
   # value_counts() creates a Series object that has index and values in this case, the country and the frequency they occur in reviewer nationality
   nationality_freq = df["Reviewer_Nationality"].value_counts()
   print("There are " + str(nationality_freq.size) + " different nationalities")
   # print first and last rows of the Series. Change to nationality_freq.to_string() to print all of the data
   print(nationality_freq) 
   
   There are 227 different nationalities
    United Kingdom               245246
    United States of America      35437
    Australia                     21686
    Ireland                       14827
    United Arab Emirates          10235
                                  ...  
    Comoros                           1
    Palau                             1
    Northern Mariana Islands          1
    Cape Verde                        1
    Guinea                            1
   Name: Reviewer_Nationality, Length: 227, dtype: int64
   ```

   3. Кои са следващите топ 10 най-често срещани националности и техният честотен брой?

      ```python
      print("The highest frequency reviewer nationality is " + str(nationality_freq.index[0]).strip() + " with " + str(nationality_freq[0]) + " reviews.")
      # Notice there is a leading space on the values, strip() removes that for printing
      # What is the top 10 most common nationalities and their frequencies?
      print("The next 10 highest frequency reviewer nationalities are:")
      print(nationality_freq[1:11].to_string())
      
      The highest frequency reviewer nationality is United Kingdom with 245246 reviews.
      The next 10 highest frequency reviewer nationalities are:
       United States of America     35437
       Australia                    21686
       Ireland                      14827
       United Arab Emirates         10235
       Saudi Arabia                  8951
       Netherlands                   8772
       Switzerland                   8678
       Germany                       7941
       Canada                        7894
       France                        7296
      ```

3. Кой е най-често рецензираният хотел за всяка от топ 10 най-често срещани националности на рецензентите?

   ```python
   # What was the most frequently reviewed hotel for the top 10 nationalities
   # Normally with pandas you will avoid an explicit loop, but wanted to show creating a new dataframe using criteria (don't do this with large amounts of data because it could be very slow)
   for nat in nationality_freq[:10].index:
      # First, extract all the rows that match the criteria into a new dataframe
      nat_df = df[df["Reviewer_Nationality"] == nat]   
      # Now get the hotel freq
      freq = nat_df["Hotel_Name"].value_counts()
      print("The most reviewed hotel for " + str(nat).strip() + " was " + str(freq.index[0]) + " with " + str(freq[0]) + " reviews.") 
      
   The most reviewed hotel for United Kingdom was Britannia International Hotel Canary Wharf with 3833 reviews.
   The most reviewed hotel for United States of America was Hotel Esther a with 423 reviews.
   The most reviewed hotel for Australia was Park Plaza Westminster Bridge London with 167 reviews.
   The most reviewed hotel for Ireland was Copthorne Tara Hotel London Kensington with 239 reviews.
   The most reviewed hotel for United Arab Emirates was Millennium Hotel London Knightsbridge with 129 reviews.
   The most reviewed hotel for Saudi Arabia was The Cumberland A Guoman Hotel with 142 reviews.
   The most reviewed hotel for Netherlands was Jaz Amsterdam with 97 reviews.
   The most reviewed hotel for Switzerland was Hotel Da Vinci with 97 reviews.
   The most reviewed hotel for Germany was Hotel Da Vinci with 86 reviews.
   The most reviewed hotel for Canada was St James Court A Taj Hotel London with 61 reviews.
   ```

4. Колко рецензии има на хотел (честотен брой на хотел) в набора от данни?

   ```python
   # First create a new dataframe based on the old one, removing the uneeded columns
   hotel_freq_df = df.drop(["Hotel_Address", "Additional_Number_of_Scoring", "Review_Date", "Average_Score", "Reviewer_Nationality", "Negative_Review", "Review_Total_Negative_Word_Counts", "Positive_Review", "Review_Total_Positive_Word_Counts", "Total_Number_of_Reviews_Reviewer_Has_Given", "Reviewer_Score", "Tags", "days_since_review", "lat", "lng"], axis = 1)
   
   # Group the rows by Hotel_Name, count them and put the result in a new column Total_Reviews_Found
   hotel_freq_df['Total_Reviews_Found'] = hotel_freq_df.groupby('Hotel_Name').transform('count')
   
   # Get rid of all the duplicated rows
   hotel_freq_df = hotel_freq_df.drop_duplicates(subset = ["Hotel_Name"])
   display(hotel_freq_df) 
   ```
   |                 Hotel_Name                 | Total_Number_of_Reviews | Total_Reviews_Found |
   | :----------------------------------------: | :---------------------: | :-----------------: |
   | Britannia International Hotel Canary Wharf |          9086           |        4789         |
   |    Park Plaza Westminster Bridge London    |          12158          |        4169         |
   |   Copthorne Tara Hotel London Kensington   |          7105           |        3578         |
   |                    ...                     |           ...           |         ...         |
   |       Mercure Paris Porte d Orleans        |           110           |         10          |
   |                Hotel Wagner                |           135           |         10          |
   |            Hotel Gallitzinberg             |           173           |          8          |

   Може да забележите, че резултатите *изчислени в набора от данни* не съвпадат със стойността в `Total_Number_of_Reviews`. Не е ясно дали тази стойност в набора от данни представлява общия брой рецензии, които хотелът е имал, но не всички са били извлечени, или някакво друго изчисление. `Total_Number_of_Reviews` не се използва в модела поради тази неяснота.

5. Въпреки че има колона `Average_Score` за всеки хотел в набора от данни, можете също да изчислите средна оценка (като вземете средната стойност на всички оценки на рецензентите в набора от данни за всеки хотел). Добавете нова колона към вашия dataframe с заглавие на колоната `Calc_Average_Score`, която съдържа тази изчислена средна стойност. Изведете колоните `Hotel_Name`, `Average_Score` и `Calc_Average_Score`.

   ```python
   # define a function that takes a row and performs some calculation with it
   def get_difference_review_avg(row):
     return row["Average_Score"] - row["Calc_Average_Score"]
   
   # 'mean' is mathematical word for 'average'
   df['Calc_Average_Score'] = round(df.groupby('Hotel_Name').Reviewer_Score.transform('mean'), 1)
   
   # Add a new column with the difference between the two average scores
   df["Average_Score_Difference"] = df.apply(get_difference_review_avg, axis = 1)
   
   # Create a df without all the duplicates of Hotel_Name (so only 1 row per hotel)
   review_scores_df = df.drop_duplicates(subset = ["Hotel_Name"])
   
   # Sort the dataframe to find the lowest and highest average score difference
   review_scores_df = review_scores_df.sort_values(by=["Average_Score_Difference"])
   
   display(review_scores_df[["Average_Score_Difference", "Average_Score", "Calc_Average_Score", "Hotel_Name"]])
   ```

   Може също да се чудите за стойността `Average_Score` и защо понякога тя се различава от изчислената средна стойност. Тъй като не можем да знаем защо някои от стойностите съвпадат, но други имат разлика, най-безопасно в този случай е да използваме оценките на рецензентите, които имаме, за да изчислим средната стойност сами. Това каза, разликите обикновено са много малки, ето хотелите с най-голямо отклонение между средната стойност от набора от данни и изчислената средна стойност:

   | Average_Score_Difference | Average_Score | Calc_Average_Score |                                  Hotel_Name |
   | :----------------------: | :-----------: | :----------------: | ------------------------------------------: |
   |           -0.8           |      7.7      |        8.5         |                  Best Western Hotel Astoria |
   |           -0.7           |      8.8      |        9.5         | Hotel Stendhal Place Vend me Paris MGallery |
   |           -0.7           |      7.5      |        8.2         |               Mercure Paris Porte d Orleans |
   |           -0.7           |      7.9      |        8.6         |             Renaissance Paris Vendome Hotel |
   |           -0.5           |      7.0      |        7.5         |                         Hotel Royal Elys es |
   |           ...            |      ...      |        ...         |                                         ... |
   |           0.7            |      7.5      |        6.8         |     Mercure Paris Op ra Faubourg Montmartre |
   |           0.8            |      7.1      |        6.3         |      Holiday Inn Paris Montparnasse Pasteur |
   |           0.9            |      6.8      |        5.9         |                               Villa Eugenie |
   |           0.9            |      8.6      |        7.7         |   MARQUIS Faubourg St Honor Relais Ch teaux |
   |           1.3            |      7.2      |        5.9         |                          Kube Hotel Ice Bar |

   С само 1 хотел с разлика в оценката, по-голяма от 1, това означава, че вероятно можем да игнорираме разликата и да използваме изчислената средна стойност.

6. Изчислете и изведете колко реда имат стойности "No Negative" в колоната `Negative_Review`.

7. Изчислете и изведете колко реда имат стойности "No Positive" в колоната `Positive_Review`.

8. Изчислете и изведете колко реда имат стойности "No Positive" в колоната `Positive_Review` **и** стойности "No Negative" в колоната `Negative_Review`.

   ```python
   # with lambdas:
   start = time.time()
   no_negative_reviews = df.apply(lambda x: True if x['Negative_Review'] == "No Negative" else False , axis=1)
   print("Number of No Negative reviews: " + str(len(no_negative_reviews[no_negative_reviews == True].index)))
   
   no_positive_reviews = df.apply(lambda x: True if x['Positive_Review'] == "No Positive" else False , axis=1)
   print("Number of No Positive reviews: " + str(len(no_positive_reviews[no_positive_reviews == True].index)))
   
   both_no_reviews = df.apply(lambda x: True if x['Negative_Review'] == "No Negative" and x['Positive_Review'] == "No Positive" else False , axis=1)
   print("Number of both No Negative and No Positive reviews: " + str(len(both_no_reviews[both_no_reviews == True].index)))
   end = time.time()
   print("Lambdas took " + str(round(end - start, 2)) + " seconds")
   
   Number of No Negative reviews: 127890
   Number of No Positive reviews: 35946
   Number of both No Negative and No Positive reviews: 127
   Lambdas took 9.64 seconds
   ```

## Друг начин

Друг начин за броене на елементи без Lambdas и използване на sum за броене на редовете:

   ```python
   # without lambdas (using a mixture of notations to show you can use both)
   start = time.time()
   no_negative_reviews = sum(df.Negative_Review == "No Negative")
   print("Number of No Negative reviews: " + str(no_negative_reviews))
   
   no_positive_reviews = sum(df["Positive_Review"] == "No Positive")
   print("Number of No Positive reviews: " + str(no_positive_reviews))
   
   both_no_reviews = sum((df.Negative_Review == "No Negative") & (df.Positive_Review == "No Positive"))
   print("Number of both No Negative and No Positive reviews: " + str(both_no_reviews))
   
   end = time.time()
   print("Sum took " + str(round(end - start, 2)) + " seconds")
   
   Number of No Negative reviews: 127890
   Number of No Positive reviews: 35946
   Number of both No Negative and No Positive reviews: 127
   Sum took 0.19 seconds
   ```

   Може да сте забелязали, че има 127 реда, които имат както "No Negative", така и "No Positive" стойности за колоните `Negative_Review` и `Positive_Review` съответно. Това означава, че рецензентът е дал на хотела числова оценка, но е отказал да напише както положителен, така и отрицателен отзив. За щастие това е малък брой редове (127 от 515738, или 0.02%), така че вероятно няма да изкриви нашия модел или резултати в определена посока, но може би не сте очаквали набор от данни с рецензии да има редове без рецензии, така че си струва да изследвате данните, за да откриете такива редове.

Сега, след като сте изследвали набора от данни, в следващия урок ще филтрирате данните и ще добавите анализ на настроенията.

---
## 🚀Предизвикателство

Този урок демонстрира, както видяхме в предишните уроци, колко критично важно е да разбирате вашите данни и техните особености, преди да извършвате операции върху тях. Данните, базирани на текст, в частност изискват внимателно разглеждане. Разгледайте различни набори от данни, богати на текст, и вижте дали можете да откриете области, които биха могли да въведат пристрастия или изкривени настроения в модела.

## [Тест след лекцията](https://ff-quizzes.netlify.app/en/ml/)

## Преглед и самостоятелно обучение

Вземете [този учебен път за NLP](https://docs.microsoft.com/learn/paths/explore-natural-language-processing/?WT.mc_id=academic-77952-leestott), за да откриете инструменти, които да опитате при изграждането на модели, базирани на реч и текст.

## Задание

[NLTK](assignment.md)

---

**Отказ от отговорност**:  
Този документ е преведен с помощта на AI услуга за превод [Co-op Translator](https://github.com/Azure/co-op-translator). Въпреки че се стремим към точност, моля, имайте предвид, че автоматизираните преводи може да съдържат грешки или неточности. Оригиналният документ на неговия роден език трябва да се счита за авторитетен източник. За критична информация се препоръчва професионален човешки превод. Ние не носим отговорност за каквито и да е недоразумения или погрешни интерпретации, произтичащи от използването на този превод.