<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "911efd5e595089000cb3c16fce1beab8",
  "translation_date": "2025-09-06T08:57:34+00:00",
  "source_file": "8-Reinforcement/1-QLearning/README.md",
  "language_code": "ur"
}
-->
# تعارف ری انفورسمنٹ لرننگ اور کیو لرننگ

![مشین لرننگ میں ری انفورسمنٹ کا خلاصہ ایک خاکے میں](../../../../sketchnotes/ml-reinforcement.png)
> خاکہ: [Tomomi Imura](https://www.twitter.com/girlie_mac)

ری انفورسمنٹ لرننگ تین اہم تصورات پر مشتمل ہے: ایجنٹ، کچھ حالتیں، اور ہر حالت کے لیے اعمال کا ایک مجموعہ۔ کسی مخصوص حالت میں عمل انجام دے کر، ایجنٹ کو انعام دیا جاتا ہے۔ ایک بار پھر کمپیوٹر گیم سپر ماریو کا تصور کریں۔ آپ ماریو ہیں، آپ ایک گیم لیول میں ہیں، اور ایک کھائی کے کنارے پر کھڑے ہیں۔ آپ کے اوپر ایک سکہ ہے۔ آپ، ماریو، ایک گیم لیول میں، ایک خاص مقام پر ... یہ آپ کی حالت ہے۔ دائیں طرف ایک قدم بڑھانا (ایک عمل) آپ کو کھائی میں لے جائے گا، اور یہ آپ کو کم عددی اسکور دے گا۔ تاہم، جمپ بٹن دبانے سے آپ کو ایک پوائنٹ ملے گا اور آپ زندہ رہیں گے۔ یہ ایک مثبت نتیجہ ہے اور اس کے لیے آپ کو ایک مثبت عددی اسکور ملنا چاہیے۔

ری انفورسمنٹ لرننگ اور ایک سمیولیٹر (گیم) کا استعمال کرتے ہوئے، آپ یہ سیکھ سکتے ہیں کہ گیم کو کیسے کھیلا جائے تاکہ انعام کو زیادہ سے زیادہ کیا جا سکے، جو کہ زندہ رہنا اور زیادہ سے زیادہ پوائنٹس حاصل کرنا ہے۔

[![ری انفورسمنٹ لرننگ کا تعارف](https://img.youtube.com/vi/lDq_en8RNOo/0.jpg)](https://www.youtube.com/watch?v=lDq_en8RNOo)

> 🎥 اوپر دی گئی تصویر پر کلک کریں تاکہ دمتری کی ری انفورسمنٹ لرننگ پر گفتگو سن سکیں۔

## [لیکچر سے پہلے کا کوئز](https://ff-quizzes.netlify.app/en/ml/)

## ضروریات اور سیٹ اپ

اس سبق میں، ہم Python میں کچھ کوڈ کے ساتھ تجربہ کریں گے۔ آپ کو اس سبق کے Jupyter Notebook کوڈ کو اپنے کمپیوٹر پر یا کلاؤڈ میں کہیں بھی چلانے کے قابل ہونا چاہیے۔

آپ [سبق کا نوٹ بک](https://github.com/microsoft/ML-For-Beginners/blob/main/8-Reinforcement/1-QLearning/notebook.ipynb) کھول سکتے ہیں اور اس سبق کے ذریعے چل سکتے ہیں۔

> **نوٹ:** اگر آپ یہ کوڈ کلاؤڈ سے کھول رہے ہیں، تو آپ کو [`rlboard.py`](https://github.com/microsoft/ML-For-Beginners/blob/main/8-Reinforcement/1-QLearning/rlboard.py) فائل بھی حاصل کرنی ہوگی، جو نوٹ بک کوڈ میں استعمال ہوتی ہے۔ اسے نوٹ بک کے ساتھ اسی ڈائریکٹری میں شامل کریں۔

## تعارف

اس سبق میں، ہم **[پیٹر اینڈ دی وولف](https://en.wikipedia.org/wiki/Peter_and_the_Wolf)** کی دنیا کو دریافت کریں گے، جو ایک روسی موسیقار [سرگئی پروکوفیف](https://en.wikipedia.org/wiki/Sergei_Prokofiev) کی ایک موسیقی پر مبنی کہانی سے متاثر ہے۔ ہم **ری انفورسمنٹ لرننگ** کا استعمال کریں گے تاکہ پیٹر اپنے ماحول کو دریافت کرے، مزیدار سیب جمع کرے اور بھیڑیے سے بچ سکے۔

**ری انفورسمنٹ لرننگ** (RL) ایک سیکھنے کی تکنیک ہے جو ہمیں کسی **ایجنٹ** کے کسی **ماحول** میں بہترین رویے کو سیکھنے کی اجازت دیتی ہے، بہت سے تجربات چلا کر۔ اس ماحول میں ایک ایجنٹ کا کچھ **مقصد** ہونا چاہیے، جو ایک **انعامی فنکشن** کے ذریعے متعین کیا جاتا ہے۔

## ماحول

سادگی کے لیے، آئیے پیٹر کی دنیا کو `width` x `height` کے سائز کے ایک مربع بورڈ کے طور پر تصور کریں، جیسے یہ:

![پیٹر کا ماحول](../../../../8-Reinforcement/1-QLearning/images/environment.png)

اس بورڈ میں ہر سیل یا تو:

* **زمین**، جس پر پیٹر اور دیگر مخلوقات چل سکتی ہیں۔
* **پانی**، جس پر آپ ظاہر ہے نہیں چل سکتے۔
* ایک **درخت** یا **گھاس**، ایک جگہ جہاں آپ آرام کر سکتے ہیں۔
* ایک **سیب**، جو پیٹر کے لیے خوشی کا باعث ہوگا۔
* ایک **بھیڑیا**، جو خطرناک ہے اور اس سے بچنا چاہیے۔

ایک علیحدہ Python ماڈیول، [`rlboard.py`](https://github.com/microsoft/ML-For-Beginners/blob/main/8-Reinforcement/1-QLearning/rlboard.py)، اس ماحول کے ساتھ کام کرنے کے لیے کوڈ پر مشتمل ہے۔ چونکہ یہ کوڈ ہمارے تصورات کو سمجھنے کے لیے اہم نہیں ہے، ہم ماڈیول کو درآمد کریں گے اور اس کا استعمال نمونہ بورڈ بنانے کے لیے کریں گے (کوڈ بلاک 1):

```python
from rlboard import *

width, height = 8,8
m = Board(width,height)
m.randomize(seed=13)
m.plot()
```

یہ کوڈ ماحول کی ایک تصویر پرنٹ کرے گا جو اوپر کی تصویر سے ملتی جلتی ہے۔

## اعمال اور پالیسی

ہمارے مثال میں، پیٹر کا مقصد سیب تلاش کرنا ہوگا، بھیڑیے اور دیگر رکاوٹوں سے بچتے ہوئے۔ ایسا کرنے کے لیے، وہ بنیادی طور پر اس وقت تک چل سکتا ہے جب تک کہ وہ سیب نہ پا لے۔

لہذا، کسی بھی مقام پر، وہ درج ذیل اعمال میں سے ایک کا انتخاب کر سکتا ہے: اوپر، نیچے، بائیں اور دائیں۔

ہم ان اعمال کو ایک لغت کے طور پر متعین کریں گے، اور انہیں متعلقہ کوآرڈینیٹ تبدیلیوں کے جوڑوں سے نقشہ کریں گے۔ مثال کے طور پر، دائیں طرف حرکت کرنا (`R`) ایک جوڑے `(1,0)` کے مطابق ہوگا۔ (کوڈ بلاک 2):

```python
actions = { "U" : (0,-1), "D" : (0,1), "L" : (-1,0), "R" : (1,0) }
action_idx = { a : i for i,a in enumerate(actions.keys()) }
```

خلاصہ کرنے کے لیے، اس منظر نامے کی حکمت عملی اور مقصد درج ذیل ہیں:

- **حکمت عملی**، ہمارے ایجنٹ (پیٹر) کی، ایک **پالیسی** کے ذریعے متعین کی جاتی ہے۔ پالیسی ایک فنکشن ہے جو کسی بھی دی گئی حالت میں عمل واپس کرتی ہے۔ ہمارے معاملے میں، مسئلے کی حالت بورڈ کے ذریعے نمائندگی کی جاتی ہے، بشمول کھلاڑی کی موجودہ پوزیشن۔

- **مقصد**، ری انفورسمنٹ لرننگ کا، بالآخر ایک اچھی پالیسی سیکھنا ہے جو ہمیں مسئلے کو مؤثر طریقے سے حل کرنے کی اجازت دے۔

## بے ترتیب چال

آئیے پہلے بے ترتیب چال کی حکمت عملی کو نافذ کرکے اپنے مسئلے کو حل کریں۔ بے ترتیب چال کے ساتھ، ہم اجازت شدہ اعمال میں سے اگلا عمل بے ترتیب طور پر منتخب کریں گے، جب تک کہ ہم سیب تک نہ پہنچ جائیں (کوڈ بلاک 3)۔

1. نیچے دیے گئے کوڈ کے ساتھ بے ترتیب چال کو نافذ کریں:

    ```python
    def random_policy(m):
        return random.choice(list(actions))
    
    def walk(m,policy,start_position=None):
        n = 0 # number of steps
        # set initial position
        if start_position:
            m.human = start_position 
        else:
            m.random_start()
        while True:
            if m.at() == Board.Cell.apple:
                return n # success!
            if m.at() in [Board.Cell.wolf, Board.Cell.water]:
                return -1 # eaten by wolf or drowned
            while True:
                a = actions[policy(m)]
                new_pos = m.move_pos(m.human,a)
                if m.is_valid(new_pos) and m.at(new_pos)!=Board.Cell.water:
                    m.move(a) # do the actual move
                    break
            n+=1
    
    walk(m,random_policy)
    ```

    `walk` کو کال کرنے سے متعلقہ راستے کی لمبائی واپس آنا چاہیے، جو ایک رن سے دوسرے رن تک مختلف ہو سکتی ہے۔

1. چال کے تجربے کو کئی بار چلائیں (کہیں، 100 بار)، اور نتیجے کے اعدادوشمار پرنٹ کریں (کوڈ بلاک 4):

    ```python
    def print_statistics(policy):
        s,w,n = 0,0,0
        for _ in range(100):
            z = walk(m,policy)
            if z<0:
                w+=1
            else:
                s += z
                n += 1
        print(f"Average path length = {s/n}, eaten by wolf: {w} times")
    
    print_statistics(random_policy)
    ```

    نوٹ کریں کہ راستے کی اوسط لمبائی تقریباً 30-40 قدم ہے، جو کہ کافی زیادہ ہے، اس حقیقت کو مدنظر رکھتے ہوئے کہ قریب ترین سیب تک اوسط فاصلہ تقریباً 5-6 قدم ہے۔

    آپ یہ بھی دیکھ سکتے ہیں کہ بے ترتیب چال کے دوران پیٹر کی حرکت کیسی لگتی ہے:

    ![پیٹر کی بے ترتیب چال](../../../../8-Reinforcement/1-QLearning/images/random_walk.gif)

## انعامی فنکشن

ہماری پالیسی کو زیادہ ذہین بنانے کے لیے، ہمیں یہ سمجھنے کی ضرورت ہے کہ کون سی حرکتیں دوسروں سے "بہتر" ہیں۔ ایسا کرنے کے لیے، ہمیں اپنے مقصد کی وضاحت کرنے کی ضرورت ہے۔

مقصد کو ایک **انعامی فنکشن** کے لحاظ سے بیان کیا جا سکتا ہے، جو ہر حالت کے لیے کچھ اسکور ویلیو واپس کرے گا۔ جتنا زیادہ نمبر ہوگا، انعامی فنکشن اتنا ہی بہتر ہوگا۔ (کوڈ بلاک 5)

```python
move_reward = -0.1
goal_reward = 10
end_reward = -10

def reward(m,pos=None):
    pos = pos or m.human
    if not m.is_valid(pos):
        return end_reward
    x = m.at(pos)
    if x==Board.Cell.water or x == Board.Cell.wolf:
        return end_reward
    if x==Board.Cell.apple:
        return goal_reward
    return move_reward
```

انعامی فنکشنز کے بارے میں دلچسپ بات یہ ہے کہ زیادہ تر معاملات میں، *ہمیں صرف کھیل کے اختتام پر ایک اہم انعام دیا جاتا ہے*۔ اس کا مطلب یہ ہے کہ ہمارا الگورتھم کسی طرح ان "اچھی" حرکتوں کو یاد رکھے جو آخر میں مثبت انعام کی طرف لے جاتی ہیں، اور ان کی اہمیت کو بڑھائے۔ اسی طرح، وہ تمام حرکتیں جو برے نتائج کی طرف لے جاتی ہیں، ان کی حوصلہ شکنی کی جانی چاہیے۔

## کیو لرننگ

ایک الگورتھم جس پر ہم یہاں بات کریں گے اسے **کیو لرننگ** کہا جاتا ہے۔ اس الگورتھم میں، پالیسی ایک فنکشن (یا ڈیٹا اسٹرکچر) کے ذریعے متعین کی جاتی ہے جسے **کیو ٹیبل** کہا جاتا ہے۔ یہ ہر حالت میں اعمال کی "اچھی" ہونے کی ریکارڈنگ کرتا ہے۔

یہ کیو ٹیبل کہلاتا ہے کیونکہ اسے اکثر ایک ٹیبل یا کثیر جہتی صف کے طور پر پیش کرنا آسان ہوتا ہے۔ چونکہ ہمارے بورڈ کے ابعاد `width` x `height` ہیں، ہم کیو ٹیبل کو ایک numpy صف کے طور پر پیش کر سکتے ہیں جس کی شکل `width` x `height` x `len(actions)` ہے: (کوڈ بلاک 6)

```python
Q = np.ones((width,height,len(actions)),dtype=np.float)*1.0/len(actions)
```

نوٹ کریں کہ ہم کیو ٹیبل کی تمام قدروں کو برابر ویلیو سے شروع کرتے ہیں، ہمارے معاملے میں - 0.25۔ یہ "بے ترتیب چال" پالیسی کے مطابق ہے، کیونکہ ہر حالت میں تمام حرکتیں یکساں طور پر اچھی ہیں۔ ہم کیو ٹیبل کو بورڈ پر دیکھنے کے لیے `plot` فنکشن کو پاس کر سکتے ہیں: `m.plot(Q)`۔

![پیٹر کا ماحول](../../../../8-Reinforcement/1-QLearning/images/env_init.png)

ہر سیل کے مرکز میں ایک "تیر" ہے جو حرکت کی ترجیحی سمت کی نشاندہی کرتا ہے۔ چونکہ تمام سمتیں برابر ہیں، ایک نقطہ دکھایا گیا ہے۔

اب ہمیں سمیولیشن چلانے، اپنے ماحول کو دریافت کرنے، اور کیو ٹیبل کی قدروں کی ایک بہتر تقسیم سیکھنے کی ضرورت ہے، جو ہمیں سیب تک پہنچنے کے لیے زیادہ تیزی سے راستہ تلاش کرنے کی اجازت دے گی۔

## کیو لرننگ کا نچوڑ: بیل مین مساوات

ایک بار جب ہم حرکت شروع کرتے ہیں، تو ہر عمل کا ایک متعلقہ انعام ہوگا، یعنی ہم نظریاتی طور پر سب سے زیادہ فوری انعام کی بنیاد پر اگلا عمل منتخب کر سکتے ہیں۔ تاہم، زیادہ تر حالات میں، حرکت ہمارے مقصد کو حاصل نہیں کرے گی، اور اس طرح ہم فوری طور پر فیصلہ نہیں کر سکتے کہ کون سی سمت بہتر ہے۔

> یاد رکھیں کہ فوری نتیجہ اہم نہیں ہے، بلکہ حتمی نتیجہ اہم ہے، جو ہمیں سمیولیشن کے اختتام پر حاصل ہوگا۔

تاخیر شدہ انعام کو مدنظر رکھنے کے لیے، ہمیں **[ڈائنامک پروگرامنگ](https://en.wikipedia.org/wiki/Dynamic_programming)** کے اصولوں کا استعمال کرنے کی ضرورت ہے، جو ہمیں اپنے مسئلے کے بارے میں تجزیاتی طور پر سوچنے کی اجازت دیتے ہیں۔

فرض کریں کہ ہم اب حالت *s* پر ہیں، اور ہم اگلی حالت *s'* پر جانا چاہتے ہیں۔ ایسا کرنے سے، ہمیں فوری انعام *r(s,a)* ملے گا، جو انعامی فنکشن کے ذریعے متعین کیا گیا ہے، اور کچھ مستقبل کا انعام بھی۔ اگر ہم فرض کریں کہ ہماری کیو ٹیبل اعمال کی "دلکشی" کو درست طریقے سے ظاہر کرتی ہے، تو حالت *s'* پر ہم وہ عمل *a* منتخب کریں گے جو *Q(s',a')* کی زیادہ سے زیادہ قیمت کے مطابق ہوگا۔ اس طرح، حالت *s* پر ہمیں ممکنہ بہترین مستقبل کا انعام `max`

## پالیسی کی جانچ

چونکہ Q-Table ہر حالت میں ہر عمل کی "دلکشی" کو ظاہر کرتی ہے، اس کا استعمال کرتے ہوئے ہماری دنیا میں مؤثر نیویگیشن کو بیان کرنا کافی آسان ہے۔ سب سے سادہ صورت میں، ہم اس عمل کو منتخب کر سکتے ہیں جو Q-Table کی سب سے زیادہ قدر کے مطابق ہو: (کوڈ بلاک 9)

```python
def qpolicy_strict(m):
        x,y = m.human
        v = probs(Q[x,y])
        a = list(actions)[np.argmax(v)]
        return a

walk(m,qpolicy_strict)
```

> اگر آپ اوپر دیے گئے کوڈ کو کئی بار آزمائیں، تو آپ دیکھ سکتے ہیں کہ کبھی کبھار یہ "رک" جاتا ہے، اور آپ کو نوٹ بک میں STOP بٹن دبانے کی ضرورت ہوتی ہے تاکہ اسے روکا جا سکے۔ ایسا اس وقت ہوتا ہے جب دو حالتیں ایک دوسرے کی طرف "اشارہ" کرتی ہیں بہترین Q-Value کے لحاظ سے، جس صورت میں ایجنٹ ان حالتوں کے درمیان غیر معینہ مدت تک حرکت کرتا رہتا ہے۔

## 🚀چیلنج

> **ٹاسک 1:** `walk` فنکشن میں ترمیم کریں تاکہ راستے کی زیادہ سے زیادہ لمبائی کو ایک خاص تعداد کے قدموں (مثلاً 100) تک محدود کیا جا سکے، اور اوپر دیا گیا کوڈ وقتاً فوقتاً یہ قدر واپس کرے۔

> **ٹاسک 2:** `walk` فنکشن میں ترمیم کریں تاکہ وہ ان جگہوں پر واپس نہ جائے جہاں وہ پہلے جا چکا ہو۔ یہ `walk` کو لوپنگ سے روک دے گا، تاہم، ایجنٹ پھر بھی ایسی جگہ پر "پھنس" سکتا ہے جہاں سے وہ باہر نکلنے کے قابل نہ ہو۔

## نیویگیشن

ایک بہتر نیویگیشن پالیسی وہ ہوگی جو ہم نے تربیت کے دوران استعمال کی تھی، جو استحصال اور دریافت کو یکجا کرتی ہے۔ اس پالیسی میں، ہم ہر عمل کو ایک خاص احتمال کے ساتھ منتخب کریں گے، جو Q-Table میں موجود قدروں کے تناسب سے ہوگا۔ یہ حکمت عملی ایجنٹ کو پہلے سے دریافت شدہ مقام پر واپس جانے کا نتیجہ دے سکتی ہے، لیکن جیسا کہ آپ نیچے دیے گئے کوڈ سے دیکھ سکتے ہیں، یہ مطلوبہ مقام تک بہت مختصر اوسط راستہ فراہم کرتی ہے (یاد رکھیں کہ `print_statistics` 100 بار سیمولیشن چلاتا ہے): (کوڈ بلاک 10)

```python
def qpolicy(m):
        x,y = m.human
        v = probs(Q[x,y])
        a = random.choices(list(actions),weights=v)[0]
        return a

print_statistics(qpolicy)
```

اس کوڈ کو چلانے کے بعد، آپ کو پہلے کے مقابلے میں بہت چھوٹا اوسط راستہ ملنا چاہیے، جو 3-6 کی حد میں ہوگا۔

## سیکھنے کے عمل کی تحقیق

جیسا کہ ہم نے ذکر کیا، سیکھنے کا عمل دریافت اور مسئلے کی جگہ کے ڈھانچے کے بارے میں حاصل کردہ علم کے استحصال کے درمیان توازن ہے۔ ہم نے دیکھا کہ سیکھنے کے نتائج (ایجنٹ کو ہدف تک مختصر راستہ تلاش کرنے کی صلاحیت) بہتر ہوئے ہیں، لیکن یہ بھی دلچسپ ہے کہ سیکھنے کے عمل کے دوران اوسط راستے کی لمبائی کیسے تبدیل ہوتی ہے:

## سیکھنے کے خلاصے

- **اوسط راستے کی لمبائی بڑھتی ہے**۔ شروع میں، اوسط راستے کی لمبائی بڑھتی ہے۔ اس کی وجہ یہ ہے کہ جب ہمیں ماحول کے بارے میں کچھ معلوم نہیں ہوتا، تو ہم ممکنہ طور پر خراب حالتوں، پانی یا بھیڑیے میں پھنس جاتے ہیں۔ جیسے جیسے ہم زیادہ سیکھتے ہیں اور اس علم کو استعمال کرتے ہیں، ہم ماحول کو زیادہ دیر تک دریافت کر سکتے ہیں، لیکن ہمیں ابھی بھی سیبوں کے مقام کا اچھی طرح علم نہیں ہوتا۔

- **راستے کی لمبائی کم ہوتی ہے، جیسے جیسے ہم زیادہ سیکھتے ہیں**۔ جب ہم کافی سیکھ لیتے ہیں، تو ایجنٹ کے لیے ہدف حاصل کرنا آسان ہو جاتا ہے، اور راستے کی لمبائی کم ہونے لگتی ہے۔ تاہم، ہم ابھی بھی دریافت کے لیے کھلے ہیں، اس لیے ہم اکثر بہترین راستے سے ہٹ جاتے ہیں اور نئے اختیارات دریافت کرتے ہیں، جس سے راستہ مثالی سے زیادہ لمبا ہو جاتا ہے۔

- **لمبائی اچانک بڑھتی ہے**۔ ہم اس گراف پر یہ بھی دیکھتے ہیں کہ کسی وقت، لمبائی اچانک بڑھ گئی۔ یہ عمل کی غیر یقینی نوعیت کو ظاہر کرتا ہے، اور یہ کہ ہم کسی وقت Q-Table کے coefficients کو نئے قدروں سے اووررائٹ کر کے "خراب" کر سکتے ہیں۔ اس کو کم سے کم کرنے کے لیے، سیکھنے کی شرح کو کم کرنا ضروری ہے (مثال کے طور پر، تربیت کے آخر میں، ہم Q-Table کی قدروں کو صرف ایک چھوٹے قدر سے ایڈجسٹ کرتے ہیں)۔

مجموعی طور پر، یہ یاد رکھنا ضروری ہے کہ سیکھنے کے عمل کی کامیابی اور معیار کا انحصار پیرامیٹرز پر ہوتا ہے، جیسے سیکھنے کی شرح، سیکھنے کی شرح میں کمی، اور ڈسکاؤنٹ فیکٹر۔ ان کو اکثر **ہائپرپیرامیٹرز** کہا جاتا ہے، تاکہ انہیں **پیرامیٹرز** سے الگ کیا جا سکے، جنہیں ہم تربیت کے دوران بہتر بناتے ہیں (مثال کے طور پر، Q-Table coefficients)۔ بہترین ہائپرپیرامیٹر قدروں کو تلاش کرنے کے عمل کو **ہائپرپیرامیٹر آپٹیمائزیشن** کہا جاتا ہے، اور یہ ایک الگ موضوع کا مستحق ہے۔

## [لیکچر کے بعد کا کوئز](https://ff-quizzes.netlify.app/en/ml/)

## اسائنمنٹ 
[ایک زیادہ حقیقت پسندانہ دنیا](assignment.md)

---

**ڈسکلیمر**:  
یہ دستاویز AI ترجمہ سروس [Co-op Translator](https://github.com/Azure/co-op-translator) کا استعمال کرتے ہوئے ترجمہ کی گئی ہے۔ ہم درستگی کے لیے کوشش کرتے ہیں، لیکن براہ کرم آگاہ رہیں کہ خودکار ترجمے میں غلطیاں یا غیر درستیاں ہو سکتی ہیں۔ اصل دستاویز کو اس کی اصل زبان میں مستند ذریعہ سمجھا جانا چاہیے۔ اہم معلومات کے لیے، پیشہ ور انسانی ترجمہ کی سفارش کی جاتی ہے۔ ہم اس ترجمے کے استعمال سے پیدا ہونے والی کسی بھی غلط فہمی یا غلط تشریح کے ذمہ دار نہیں ہیں۔