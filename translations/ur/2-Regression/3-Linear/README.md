<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "40e64f004f3cb50aa1d8661672d3cd92",
  "translation_date": "2025-09-06T08:43:17+00:00",
  "source_file": "2-Regression/3-Linear/README.md",
  "language_code": "ur"
}
-->
# سکائٹ لرن کے ذریعے ریگریشن ماڈل بنائیں: ریگریشن کے چار طریقے

![لینیئر بمقابلہ پولینومیل ریگریشن انفوگرافک](../../../../2-Regression/3-Linear/images/linear-polynomial.png)
> انفوگرافک از [دسانی مادیپالی](https://twitter.com/dasani_decoded)
## [لیکچر سے پہلے کا کوئز](https://ff-quizzes.netlify.app/en/ml/)

> ### [یہ سبق R میں دستیاب ہے!](../../../../2-Regression/3-Linear/solution/R/lesson_3.html)
### تعارف

اب تک آپ نے ریگریشن کے بارے میں جانا ہے، جس میں کدو کی قیمتوں کے ڈیٹا سیٹ سے نمونہ ڈیٹا استعمال کیا گیا ہے، جو ہم اس سبق میں استعمال کریں گے۔ آپ نے اسے میٹپلاٹ لِب کے ذریعے بصری طور پر بھی دیکھا ہے۔

اب آپ مشین لرننگ کے لیے ریگریشن کو مزید گہرائی سے سمجھنے کے لیے تیار ہیں۔ جبکہ بصری تجزیہ ڈیٹا کو سمجھنے میں مدد دیتا ہے، مشین لرننگ کی اصل طاقت _ماڈلز کی تربیت_ میں ہے۔ ماڈلز تاریخی ڈیٹا پر تربیت یافتہ ہوتے ہیں تاکہ ڈیٹا کی وابستگی کو خودکار طور پر سمجھ سکیں، اور یہ آپ کو نئے ڈیٹا کے نتائج کی پیش گوئی کرنے کی اجازت دیتے ہیں، جو ماڈل نے پہلے نہیں دیکھا ہوتا۔

اس سبق میں، آپ ریگریشن کی دو اقسام کے بارے میں مزید جانیں گے: _بنیادی لینیئر ریگریشن_ اور _پولینومیل ریگریشن_، اور ان تکنیکوں کے پیچھے کچھ ریاضی۔ یہ ماڈلز ہمیں مختلف ان پٹ ڈیٹا کے مطابق کدو کی قیمتوں کی پیش گوئی کرنے کی اجازت دیں گے۔

[![مشین لرننگ کے لیے ابتدائی - لینیئر ریگریشن کو سمجھنا](https://img.youtube.com/vi/CRxFT8oTDMg/0.jpg)](https://youtu.be/CRxFT8oTDMg "مشین لرننگ کے لیے ابتدائی - لینیئر ریگریشن کو سمجھنا")

> 🎥 اوپر دی گئی تصویر پر کلک کریں تاکہ لینیئر ریگریشن کا مختصر ویڈیو جائزہ دیکھ سکیں۔

> اس نصاب میں، ہم ریاضی کے کم سے کم علم کو فرض کرتے ہیں اور طلباء کے لیے اسے قابل رسائی بنانے کی کوشش کرتے ہیں، جو دیگر شعبوں سے آتے ہیں۔ نوٹس، 🧮 کال آؤٹس، ڈایاگرامز، اور دیگر سیکھنے کے اوزار پر نظر رکھیں تاکہ سمجھنے میں مدد ملے۔

### پیشگی شرط

اب تک آپ کو کدو کے ڈیٹا کی ساخت سے واقف ہونا چاہیے، جسے ہم جانچ رہے ہیں۔ آپ اسے اس سبق کے _notebook.ipynb_ فائل میں پہلے سے لوڈ اور صاف شدہ حالت میں دیکھ سکتے ہیں۔ اس فائل میں، کدو کی قیمت فی بوشل ایک نئے ڈیٹا فریم میں دکھائی گئی ہے۔ یقینی بنائیں کہ آپ ان نوٹ بکس کو ویژول اسٹوڈیو کوڈ کے کرنلز میں چلا سکتے ہیں۔

### تیاری

یاد دہانی کے طور پر، آپ یہ ڈیٹا اس لیے لوڈ کر رہے ہیں تاکہ اس سے سوالات پوچھ سکیں۔

- کدو خریدنے کا بہترین وقت کب ہے؟
- چھوٹے کدو کے کیس کی قیمت کیا ہو سکتی ہے؟
- کیا مجھے انہیں آدھے بوشل کے ٹوکریوں میں خریدنا چاہیے یا 1 1/9 بوشل کے ڈبے میں؟
آئیے اس ڈیٹا میں مزید کھوج کریں۔

پچھلے سبق میں، آپ نے ایک پانڈاز ڈیٹا فریم بنایا اور اسے اصل ڈیٹا سیٹ کے ایک حصے سے بھرا، قیمتوں کو بوشل کے مطابق معیاری بنایا۔ ایسا کرنے سے، تاہم، آپ صرف تقریباً 400 ڈیٹا پوائنٹس جمع کر سکے اور وہ بھی صرف خزاں کے مہینوں کے لیے۔

اس سبق کے ساتھ آنے والے نوٹ بک میں پہلے سے لوڈ شدہ ڈیٹا پر ایک نظر ڈالیں۔ ڈیٹا پہلے سے لوڈ شدہ ہے اور ایک ابتدائی اسکیٹر پلاٹ چارٹ کیا گیا ہے تاکہ مہینے کے ڈیٹا کو دکھایا جا سکے۔ شاید ہم ڈیٹا کی نوعیت کے بارے میں مزید تفصیل حاصل کر سکیں اگر اسے مزید صاف کریں۔

## ایک لینیئر ریگریشن لائن

جیسا کہ آپ نے سبق 1 میں سیکھا، لینیئر ریگریشن کی مشق کا مقصد ایک لائن کو پلاٹ کرنا ہے تاکہ:

- **متغیرات کے تعلقات دکھائیں**۔ متغیرات کے درمیان تعلق دکھائیں
- **پیش گوئیاں کریں**۔ یہ پیش گوئی کریں کہ ایک نیا ڈیٹا پوائنٹ اس لائن کے تعلق میں کہاں آئے گا۔

یہ عام طور پر **لیسٹ-اسکوائرز ریگریشن** کے ذریعے اس قسم کی لائن کھینچنے کے لیے کیا جاتا ہے۔ 'لیسٹ-اسکوائرز' کا مطلب ہے کہ ریگریشن لائن کے ارد گرد کے تمام ڈیٹا پوائنٹس کو مربع کیا جاتا ہے اور پھر جمع کیا جاتا ہے۔ مثالی طور پر، وہ حتمی مجموعہ جتنا چھوٹا ہو، اتنا ہی بہتر ہے، کیونکہ ہم غلطیوں کی کم تعداد چاہتے ہیں، یا `لیسٹ-اسکوائرز`۔

ہم ایسا اس لیے کرتے ہیں کیونکہ ہم ایک ایسی لائن کا ماڈل بنانا چاہتے ہیں جس کا تمام ڈیٹا پوائنٹس سے کم سے کم مجموعی فاصلہ ہو۔ ہم ان شرائط کو مربع بھی کرتے ہیں کیونکہ ہم اس کی شدت کے بارے میں فکر مند ہیں، نہ کہ اس کی سمت کے بارے میں۔

> **🧮 مجھے ریاضی دکھائیں**
>
> اس لائن، جسے _بہترین فٹ کی لائن_ کہا جاتا ہے، کو [ایک مساوات](https://en.wikipedia.org/wiki/Simple_linear_regression) کے ذریعے ظاہر کیا جا سکتا ہے:
>
> ```
> Y = a + bX
> ```
>
> `X` 'وضاحتی متغیر' ہے۔ `Y` 'منحصر متغیر' ہے۔ لائن کی ڈھلوان `b` ہے اور `a` y-انٹرسپٹ ہے، جو اس وقت `Y` کی قدر کو ظاہر کرتا ہے جب `X = 0` ہو۔
>
>![ڈھلوان کا حساب لگائیں](../../../../2-Regression/3-Linear/images/slope.png)
>
> پہلے، ڈھلوان `b` کا حساب لگائیں۔ انفوگرافک از [جین لوپر](https://twitter.com/jenlooper)
>
> دوسرے الفاظ میں، اور ہمارے کدو کے ڈیٹا کے اصل سوال کا حوالہ دیتے ہوئے: "مہینے کے لحاظ سے کدو کی قیمت فی بوشل کی پیش گوئی کریں"، `X` قیمت کو ظاہر کرے گا اور `Y` فروخت کے مہینے کو۔
>
>![مساوات مکمل کریں](../../../../2-Regression/3-Linear/images/calculation.png)
>
> `Y` کی قدر کا حساب لگائیں۔ اگر آپ تقریباً $4 ادا کر رہے ہیں، تو یہ اپریل ہونا چاہیے! انفوگرافک از [جین لوپر](https://twitter.com/jenlooper)
>
> لائن کا حساب لگانے والی ریاضی کو لائن کی ڈھلوان ظاہر کرنی چاہیے، جو انٹرسپٹ پر بھی منحصر ہے، یا جہاں `Y` واقع ہے جب `X = 0`۔
>
> آپ ان اقدار کے حساب کے طریقے کو [Math is Fun](https://www.mathsisfun.com/data/least-squares-regression.html) ویب سائٹ پر دیکھ سکتے ہیں۔ [Least-squares calculator](https://www.mathsisfun.com/data/least-squares-calculator.html) پر بھی جائیں تاکہ دیکھ سکیں کہ نمبروں کی اقدار لائن پر کیسے اثر ڈالتی ہیں۔

## تعلق

ایک اور اصطلاح کو سمجھنا ضروری ہے، وہ ہے **تعلق کا گتانک** دیے گئے X اور Y متغیرات کے درمیان۔ اسکیٹر پلاٹ کا استعمال کرتے ہوئے، آپ اس گتانک کو جلدی سے بصری طور پر دیکھ سکتے ہیں۔ ایک پلاٹ جس میں ڈیٹا پوائنٹس ایک صاف لائن میں بکھرے ہوئے ہوں، اس کا تعلق زیادہ ہوتا ہے، لیکن ایک پلاٹ جس میں ڈیٹا پوائنٹس X اور Y کے درمیان ہر جگہ بکھرے ہوئے ہوں، اس کا تعلق کم ہوتا ہے۔

ایک اچھا لینیئر ریگریشن ماڈل وہ ہوگا جس کا تعلق کا گتانک زیادہ ہو (1 کے قریب ہو، 0 کے مقابلے میں) لیسٹ-اسکوائرز ریگریشن طریقہ کے ساتھ ریگریشن لائن کے ذریعے۔

✅ اس سبق کے ساتھ آنے والے نوٹ بک کو چلائیں اور مہینے سے قیمت کے اسکیٹر پلاٹ کو دیکھیں۔ کیا کدو کی فروخت کے لیے مہینے سے قیمت کا ڈیٹا آپ کے بصری تجزیے کے مطابق زیادہ یا کم تعلق رکھتا ہے؟ کیا یہ تبدیل ہوتا ہے اگر آپ مہینے کے بجائے زیادہ باریک پیمائش استعمال کریں، جیسے *سال کا دن* (یعنی سال کے آغاز سے دنوں کی تعداد)؟

نیچے دیے گئے کوڈ میں، ہم فرض کریں گے کہ ہم نے ڈیٹا صاف کر لیا ہے، اور ایک ڈیٹا فریم حاصل کیا ہے جسے `new_pumpkins` کہا جاتا ہے، جو درج ذیل کے مشابہ ہے:

ID | Month | DayOfYear | Variety | City | Package | Low Price | High Price | Price
---|-------|-----------|---------|------|---------|-----------|------------|-------
70 | 9 | 267 | PIE TYPE | BALTIMORE | 1 1/9 bushel cartons | 15.0 | 15.0 | 13.636364
71 | 9 | 267 | PIE TYPE | BALTIMORE | 1 1/9 bushel cartons | 18.0 | 18.0 | 16.363636
72 | 10 | 274 | PIE TYPE | BALTIMORE | 1 1/9 bushel cartons | 18.0 | 18.0 | 16.363636
73 | 10 | 274 | PIE TYPE | BALTIMORE | 1 1/9 bushel cartons | 17.0 | 17.0 | 15.454545
74 | 10 | 281 | PIE TYPE | BALTIMORE | 1 1/9 bushel cartons | 15.0 | 15.0 | 13.636364

> ڈیٹا صاف کرنے کا کوڈ [`notebook.ipynb`](../../../../2-Regression/3-Linear/notebook.ipynb) میں دستیاب ہے۔ ہم نے پچھلے سبق میں کیے گئے وہی صاف کرنے کے اقدامات کیے ہیں، اور `DayOfYear` کالم کا حساب درج ذیل اظہار کے ذریعے لگایا ہے:

```python
day_of_year = pd.to_datetime(pumpkins['Date']).apply(lambda dt: (dt-datetime(dt.year,1,1)).days)
```

اب جب کہ آپ لینیئر ریگریشن کے پیچھے ریاضی کو سمجھ چکے ہیں، آئیے ایک ریگریشن ماڈل بنائیں تاکہ دیکھ سکیں کہ ہم کدو کے پیکجز میں سے کون سا بہترین قیمتوں کے لیے منتخب کر سکتے ہیں۔ کوئی شخص جو چھٹی کے کدو کے باغ کے لیے کدو خرید رہا ہو، وہ یہ معلومات چاہے گا تاکہ باغ کے لیے کدو کے پیکجز کی خریداری کو بہتر بنا سکے۔

## تعلق کی تلاش

[![مشین لرننگ کے لیے ابتدائی - تعلق کی تلاش: لینیئر ریگریشن کی کلید](https://img.youtube.com/vi/uoRq-lW2eQo/0.jpg)](https://youtu.be/uoRq-lW2eQo "مشین لرننگ کے لیے ابتدائی - تعلق کی تلاش: لینیئر ریگریشن کی کلید")

> 🎥 اوپر دی گئی تصویر پر کلک کریں تاکہ تعلق کا مختصر ویڈیو جائزہ دیکھ سکیں۔

پچھلے سبق سے آپ نے شاید دیکھا ہو کہ مختلف مہینوں کے لیے اوسط قیمت کچھ اس طرح نظر آتی ہے:

<img alt="مہینے کے لحاظ سے اوسط قیمت" src="../2-Data/images/barchart.png" width="50%"/>

یہ ظاہر کرتا ہے کہ کچھ تعلق ہونا چاہیے، اور ہم `Month` اور `Price` کے درمیان یا `DayOfYear` اور `Price` کے درمیان تعلق کی پیش گوئی کرنے کے لیے لینیئر ریگریشن ماڈل کی تربیت کرنے کی کوشش کر سکتے ہیں۔ یہاں اسکیٹر پلاٹ ہے جو مؤخر الذکر تعلق کو دکھاتا ہے:

<img alt="قیمت بمقابلہ سال کے دن کا اسکیٹر پلاٹ" src="images/scatter-dayofyear.png" width="50%" /> 

آئیے `corr` فنکشن کا استعمال کرتے ہوئے دیکھیں کہ کیا کوئی تعلق ہے:

```python
print(new_pumpkins['Month'].corr(new_pumpkins['Price']))
print(new_pumpkins['DayOfYear'].corr(new_pumpkins['Price']))
```

ایسا لگتا ہے کہ تعلق کافی کم ہے، `Month` کے لحاظ سے -0.15 اور `DayOfMonth` کے لحاظ سے -0.17، لیکن ایک اور اہم تعلق ہو سکتا ہے۔ ایسا لگتا ہے کہ مختلف کدو کی اقسام کے مطابق قیمتوں کے مختلف کلسٹرز ہیں۔ اس مفروضے کی تصدیق کے لیے، آئیے ہر کدو کی قسم کو مختلف رنگ کے ساتھ پلاٹ کریں۔ `scatter` پلاٹنگ فنکشن کو `ax` پیرامیٹر پاس کرکے ہم تمام پوائنٹس کو ایک ہی گراف پر پلاٹ کر سکتے ہیں:

```python
ax=None
colors = ['red','blue','green','yellow']
for i,var in enumerate(new_pumpkins['Variety'].unique()):
    df = new_pumpkins[new_pumpkins['Variety']==var]
    ax = df.plot.scatter('DayOfYear','Price',ax=ax,c=colors[i],label=var)
```

<img alt="قیمت بمقابلہ سال کے دن کا اسکیٹر پلاٹ" src="images/scatter-dayofyear-color.png" width="50%" /> 

ہماری تحقیق سے پتہ چلتا ہے کہ قسم کا اثر قیمت پر فروخت کی اصل تاریخ سے زیادہ ہے۔ ہم اسے بار گراف کے ذریعے دیکھ سکتے ہیں:

```python
new_pumpkins.groupby('Variety')['Price'].mean().plot(kind='bar')
```

<img alt="قسم کے لحاظ سے قیمت کا بار گراف" src="images/price-by-variety.png" width="50%" /> 

آئیے فی الحال صرف ایک کدو کی قسم، 'پائی ٹائپ' پر توجہ مرکوز کریں، اور دیکھیں کہ تاریخ کا قیمت پر کیا اثر پڑتا ہے:

```python
pie_pumpkins = new_pumpkins[new_pumpkins['Variety']=='PIE TYPE']
pie_pumpkins.plot.scatter('DayOfYear','Price') 
```
<img alt="قیمت بمقابلہ سال کے دن کا اسکیٹر پلاٹ" src="images/pie-pumpkins-scatter.png" width="50%" /> 

اگر ہم اب `corr` فنکشن کا استعمال کرتے ہوئے `Price` اور `DayOfYear` کے درمیان تعلق کا حساب لگائیں، تو ہمیں کچھ `-0.27` جیسا ملے گا - جس کا مطلب ہے کہ پیش گوئی کرنے والے ماڈل کی تربیت کرنا معنی رکھتا ہے۔

> لینیئر ریگریشن ماڈل کی تربیت سے پہلے، یہ یقینی بنانا ضروری ہے کہ ہمارا ڈیٹا صاف ہے۔ لینیئر ریگریشن خالی اقدار کے ساتھ اچھا کام نہیں کرتا، اس لیے خالی سیلز کو ختم کرنا سمجھ میں آتا ہے:

```python
pie_pumpkins.dropna(inplace=True)
pie_pumpkins.info()
```

ایک اور طریقہ یہ ہوگا کہ ان خالی اقدار کو متعلقہ کالم سے اوسط اقدار کے ساتھ پُر کریں۔

## سادہ لینیئر ریگریشن

[![مشین لرننگ کے لیے ابتدائی - سکائٹ لرن کا استعمال کرتے ہوئے لینیئر اور پولینومیل ریگریشن](https://img.youtube.com/vi/e4c_UP2fSjg/0.jpg)](https://youtu.be/e4c_UP2fSjg "مشین لرننگ کے لیے ابتدائی - سکائٹ لرن کا استعمال کرتے ہوئے لینیئر اور پولینومیل ریگریشن")

> 🎥 اوپر دی گئی تصویر پر کلک کریں تاکہ لینیئر اور پولینومیل ریگریشن کا مختصر ویڈیو جائزہ دیکھ سکیں۔

اپنے لینیئر ریگریشن ماڈل کی تربیت کے لیے، ہم **سکائٹ لرن** لائبریری استعمال کریں گے۔

```python
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split
```

ہم ان پٹ اقدار (فیچرز) اور متوقع آؤٹ پٹ (لیبل) کو الگ الگ numpy arrays میں تقسیم کرتے ہیں:

```python
X = pie_pumpkins['DayOfYear'].to_numpy().reshape(-1,1)
y = pie_pumpkins['Price']
```

> نوٹ کریں کہ ہمیں ان پٹ ڈیٹا پر `reshape` انجام دینا پڑا تاکہ لینیئر ریگریشن پیکیج اسے صحیح طریقے سے سمجھ سکے۔ لینیئر ریگریشن ایک 2D-array کو ان پٹ کے طور پر توقع کرتا ہے، جہاں array کی ہر قطار ان پٹ فیچرز کے ویکٹر سے مطابقت رکھتی ہے۔ ہمارے معاملے میں، چونکہ ہمارے پاس صرف ایک ان پٹ ہے - ہمیں N×1 شکل کے ساتھ ایک array کی ضرورت ہے، جہاں N ڈیٹا سیٹ کا سائز ہے۔

پھر، ہمیں ڈیٹا کو ٹرین اور ٹیسٹ ڈیٹا سیٹس میں تقسیم کرنے کی ضرورت ہے، تاکہ ہم تربیت کے بعد اپنے ماڈل کی توثیق کر سکیں:

```python
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)
```

آخر میں، اصل لینیئر ریگریشن ماڈل کی تربیت صرف دو لائنوں کے کوڈ میں ہوتی ہے۔ ہم `LinearRegression` آبجیکٹ کی وضاحت کرتے ہیں، اور اسے `fit` طریقہ استعمال کرتے ہوئے اپنے ڈیٹا پر فٹ کرتے ہیں:

```python
lin_reg = LinearRegression()
lin_reg.fit(X_train,y_train)
```

`LinearRegression` آبجیکٹ `fit`-نگ کے بعد ریگریشن کے تمام گتانک پر مشتمل ہوتا ہے، جن تک `.coef_` پراپرٹی کا استعمال کرتے ہوئے رسائی حاصل کی جا سکتی ہے۔ ہمارے معاملے میں، صرف ایک گتانک ہے، جو تقریباً `-0.017` ہونا چاہیے۔ اس کا مطلب ہے کہ وقت کے ساتھ قیمتیں تھوڑی کم ہوتی دکھائی دیتی ہیں، لیکن زیادہ نہیں، تقریباً 2 سینٹ فی دن۔ ہم ریگریشن کے Y-axis کے ساتھ انٹرسیکشن پوائنٹ تک بھی رسائی حاصل کر سکتے ہیں `lin_reg.intercept_` کا استعمال کرتے ہوئے - یہ ہمارے معاملے میں تقریباً `21` ہوگا، جو سال کے آغاز میں قیمت کو ظاہر کرتا ہے۔

یہ دیکھنے کے لیے کہ ہمارا ماڈل کتنا درست ہے، ہم ٹیسٹ ڈیٹا سیٹ پر قیمتوں کی پیش گوئی کر سکتے ہیں، اور پھر یہ پیمائش کر سکتے ہیں کہ ہماری پیش گوئیاں متوقع اقدار کے کتنی قریب ہیں۔ یہ mean square error (MSE) میٹرکس کا استعمال کرتے ہوئے کیا جا سکتا ہے، جو متوقع اور پیش گوئی شدہ قدر کے درمیان تمام مربع فرق کا اوسط ہے۔

```python
pred = lin_reg.predict(X_test)

mse = np.sqrt(mean_squared_error(y_test,pred))
print(f'Mean error: {mse:3.3} ({mse/np.mean(pred)*100:3.3}%)')
```
ہماری غلطی تقریباً 2 پوائنٹس کے ارد گرد ہے، جو کہ ~17% ہے۔ یہ زیادہ اچھا نہیں ہے۔ ماڈل کے معیار کا ایک اور اشارہ **coefficient of determination** ہے، جسے اس طرح حاصل کیا جا سکتا ہے:

```python
score = lin_reg.score(X_train,y_train)
print('Model determination: ', score)
```  
اگر قدر 0 ہو، تو اس کا مطلب ہے کہ ماڈل ان پٹ ڈیٹا کو مدنظر نہیں رکھتا اور *بدترین لکیری پیش گو* کے طور پر کام کرتا ہے، جو صرف نتیجے کی اوسط قدر ہے۔ قدر 1 کا مطلب ہے کہ ہم تمام متوقع نتائج کو مکمل طور پر پیش گوئی کر سکتے ہیں۔ ہمارے معاملے میں، coefficient تقریباً 0.06 ہے، جو کہ کافی کم ہے۔

ہم ٹیسٹ ڈیٹا کو ریگریشن لائن کے ساتھ بھی پلاٹ کر سکتے ہیں تاکہ بہتر طور پر دیکھ سکیں کہ ہمارے معاملے میں ریگریشن کیسے کام کرتا ہے:

```python
plt.scatter(X_test,y_test)
plt.plot(X_test,pred)
```  

<img alt="Linear regression" src="images/linear-results.png" width="50%" />

## پولینومیل ریگریشن  

لکیری ریگریشن کی ایک اور قسم پولینومیل ریگریشن ہے۔ کبھی کبھار متغیرات کے درمیان لکیری تعلق ہوتا ہے - جیسے کدو کا حجم جتنا بڑا ہوگا، قیمت اتنی زیادہ ہوگی - لیکن کبھی کبھار ان تعلقات کو ایک سیدھی لائن یا سطح کے طور پر پلاٹ نہیں کیا جا سکتا۔

✅ یہاں [کچھ مزید مثالیں](https://online.stat.psu.edu/stat501/lesson/9/9.8) ہیں جو پولینومیل ریگریشن استعمال کر سکتی ہیں۔

تاریخ اور قیمت کے تعلق پر دوبارہ نظر ڈالیں۔ کیا یہ scatterplot ایسا لگتا ہے کہ اسے لازمی طور پر ایک سیدھی لائن کے ذریعے تجزیہ کیا جانا چاہیے؟ کیا قیمتیں اتار چڑھاؤ نہیں کر سکتیں؟ اس صورت میں، آپ پولینومیل ریگریشن آزما سکتے ہیں۔

✅ پولینومیلز ریاضیاتی اظہار ہیں جو ایک یا زیادہ متغیرات اور coefficients پر مشتمل ہو سکتے ہیں۔

پولینومیل ریگریشن ایک خمیدہ لائن بناتا ہے تاکہ غیر لکیری ڈیٹا کو بہتر طور پر فٹ کیا جا سکے۔ ہمارے معاملے میں، اگر ہم ان پٹ ڈیٹا میں `DayOfYear` متغیر کو مربع کریں، تو ہم اپنے ڈیٹا کو ایک parabolic curve کے ساتھ فٹ کر سکتے ہیں، جس کا ایک کم از کم نقطہ سال کے اندر ہوگا۔

Scikit-learn ایک مفید [pipeline API](https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.make_pipeline.html?highlight=pipeline#sklearn.pipeline.make_pipeline) شامل کرتا ہے تاکہ ڈیٹا پروسیسنگ کے مختلف مراحل کو ایک ساتھ جوڑا جا سکے۔ **پائپ لائن** **estimators** کی ایک زنجیر ہے۔ ہمارے معاملے میں، ہم ایک پائپ لائن بنائیں گے جو پہلے ہمارے ماڈل میں پولینومیل فیچرز شامل کرے گی، اور پھر ریگریشن کو تربیت دے گی:

```python
from sklearn.preprocessing import PolynomialFeatures
from sklearn.pipeline import make_pipeline

pipeline = make_pipeline(PolynomialFeatures(2), LinearRegression())

pipeline.fit(X_train,y_train)
```  

`PolynomialFeatures(2)` استعمال کرنے کا مطلب ہے کہ ہم ان پٹ ڈیٹا سے تمام دوسرے درجے کے پولینومیلز شامل کریں گے۔ ہمارے معاملے میں، یہ صرف `DayOfYear`<sup>2</sup> ہوگا، لیکن دو ان پٹ متغیرات X اور Y دیے گئے، یہ X<sup>2</sup>, XY اور Y<sup>2</sup> شامل کرے گا۔ اگر ہم چاہیں تو ہم اعلی درجے کے پولینومیلز بھی استعمال کر سکتے ہیں۔

پائپ لائنز کو اسی طرح استعمال کیا جا سکتا ہے جیسے اصل `LinearRegression` آبجیکٹ، یعنی ہم پائپ لائن کو `fit` کر سکتے ہیں، اور پھر `predict` استعمال کر کے پیش گوئی کے نتائج حاصل کر سکتے ہیں۔ یہاں گراف ہے جو ٹیسٹ ڈیٹا اور approximation curve دکھاتا ہے:

<img alt="Polynomial regression" src="images/poly-results.png" width="50%" />

پولینومیل ریگریشن استعمال کرتے ہوئے، ہم قدرے کم MSE اور زیادہ determination حاصل کر سکتے ہیں، لیکن زیادہ نہیں۔ ہمیں دیگر فیچرز کو مدنظر رکھنا ہوگا!

> آپ دیکھ سکتے ہیں کہ کدو کی کم از کم قیمتیں کہیں ہالووین کے ارد گرد دیکھی جاتی ہیں۔ آپ اس کی وضاحت کیسے کریں گے؟

🎃 مبارک ہو، آپ نے ایک ماڈل بنایا ہے جو پائی کدو کی قیمت کی پیش گوئی کرنے میں مدد کر سکتا ہے۔ آپ شاید تمام کدو کی اقسام کے لیے یہی طریقہ کار دہرا سکتے ہیں، لیکن یہ تھکا دینے والا ہوگا۔ آئیے اب سیکھتے ہیں کہ اپنے ماڈل میں کدو کی قسم کو کیسے مدنظر رکھا جائے!

## کیٹیگوریکل فیچرز  

ایک مثالی دنیا میں، ہم مختلف کدو کی اقسام کے لیے قیمتوں کی پیش گوئی کرنے کے قابل ہونا چاہتے ہیں، ایک ہی ماڈل استعمال کرتے ہوئے۔ تاہم، `Variety` کالم `Month` جیسے کالمز سے کچھ مختلف ہے، کیونکہ اس میں غیر عددی اقدار شامل ہیں۔ ایسے کالمز کو **categorical** کہا جاتا ہے۔

[![ML for beginners - Categorical Feature Predictions with Linear Regression](https://img.youtube.com/vi/DYGliioIAE0/0.jpg)](https://youtu.be/DYGliioIAE0 "ML for beginners - Categorical Feature Predictions with Linear Regression")

> 🎥 اوپر دی گئی تصویر پر کلک کریں تاکہ کیٹیگوریکل فیچرز کے استعمال پر ایک مختصر ویڈیو دیکھ سکیں۔

یہاں آپ دیکھ سکتے ہیں کہ اوسط قیمت قسم پر کیسے منحصر ہے:

<img alt="Average price by variety" src="images/price-by-variety.png" width="50%" />

قسم کو مدنظر رکھنے کے لیے، ہمیں پہلے اسے عددی شکل میں تبدیل کرنا ہوگا، یا **encode** کرنا ہوگا۔ ہم اسے کرنے کے کئی طریقے ہیں:

* سادہ **numeric encoding** مختلف اقسام کی ایک جدول بنائے گا، اور پھر قسم کے نام کو اس جدول میں ایک انڈیکس سے بدل دے گا۔ یہ لکیری ریگریشن کے لیے بہترین خیال نہیں ہے، کیونکہ لکیری ریگریشن انڈیکس کی اصل عددی قدر کو لیتا ہے، اور اسے نتیجے میں شامل کرتا ہے، کسی coefficient سے ضرب دے کر۔ ہمارے معاملے میں، انڈیکس نمبر اور قیمت کے درمیان تعلق واضح طور پر غیر لکیری ہے، چاہے ہم یہ یقینی بنائیں کہ انڈیکسز کسی مخصوص ترتیب میں ہیں۔
* **One-hot encoding** `Variety` کالم کو 4 مختلف کالمز سے بدل دے گا، ہر قسم کے لیے ایک۔ ہر کالم میں `1` ہوگا اگر متعلقہ قطار دی گئی قسم کی ہو، اور `0` ورنہ۔ اس کا مطلب ہے کہ لکیری ریگریشن میں چار coefficients ہوں گے، ہر کدو کی قسم کے لیے ایک، جو اس مخصوص قسم کے لیے "ابتدائی قیمت" (یا "اضافی قیمت") کے لیے ذمہ دار ہوگا۔

نیچے دیا گیا کوڈ دکھاتا ہے کہ ہم قسم کو one-hot encode کیسے کر سکتے ہیں:

```python
pd.get_dummies(new_pumpkins['Variety'])
```  

 ID | FAIRYTALE | MINIATURE | MIXED HEIRLOOM VARIETIES | PIE TYPE  
----|-----------|-----------|--------------------------|----------  
70 | 0 | 0 | 0 | 1  
71 | 0 | 0 | 0 | 1  
... | ... | ... | ... | ...  
1738 | 0 | 1 | 0 | 0  
1739 | 0 | 1 | 0 | 0  
1740 | 0 | 1 | 0 | 0  
1741 | 0 | 1 | 0 | 0  
1742 | 0 | 1 | 0 | 0  

one-hot encoded قسم کو ان پٹ کے طور پر استعمال کرتے ہوئے لکیری ریگریشن کو تربیت دینے کے لیے، ہمیں صرف `X` اور `y` ڈیٹا کو صحیح طریقے سے initialize کرنے کی ضرورت ہے:

```python
X = pd.get_dummies(new_pumpkins['Variety'])
y = new_pumpkins['Price']
```  

باقی کوڈ وہی ہے جو ہم نے اوپر لکیری ریگریشن کو تربیت دینے کے لیے استعمال کیا۔ اگر آپ اسے آزمائیں، تو آپ دیکھیں گے کہ mean squared error تقریباً وہی ہے، لیکن ہمیں بہت زیادہ coefficient of determination (~77%) ملتا ہے۔ مزید درست پیش گوئی حاصل کرنے کے لیے، ہم مزید کیٹیگوریکل فیچرز کو مدنظر رکھ سکتے ہیں، اور عددی فیچرز جیسے `Month` یا `DayOfYear` کو بھی۔ ایک بڑے فیچرز کے array کو حاصل کرنے کے لیے، ہم `join` استعمال کر سکتے ہیں:

```python
X = pd.get_dummies(new_pumpkins['Variety']) \
        .join(new_pumpkins['Month']) \
        .join(pd.get_dummies(new_pumpkins['City'])) \
        .join(pd.get_dummies(new_pumpkins['Package']))
y = new_pumpkins['Price']
```  

یہاں ہم `City` اور `Package` قسم کو بھی مدنظر رکھتے ہیں، جو ہمیں MSE 2.84 (10%) اور determination 0.94 دیتا ہے!

## سب کچھ ایک ساتھ رکھنا  

بہترین ماڈل بنانے کے لیے، ہم اوپر دی گئی مثال سے مشترکہ (one-hot encoded کیٹیگوریکل + عددی) ڈیٹا کو پولینومیل ریگریشن کے ساتھ استعمال کر سکتے ہیں۔ آپ کی سہولت کے لیے یہاں مکمل کوڈ ہے:

```python
# set up training data
X = pd.get_dummies(new_pumpkins['Variety']) \
        .join(new_pumpkins['Month']) \
        .join(pd.get_dummies(new_pumpkins['City'])) \
        .join(pd.get_dummies(new_pumpkins['Package']))
y = new_pumpkins['Price']

# make train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)

# setup and train the pipeline
pipeline = make_pipeline(PolynomialFeatures(2), LinearRegression())
pipeline.fit(X_train,y_train)

# predict results for test data
pred = pipeline.predict(X_test)

# calculate MSE and determination
mse = np.sqrt(mean_squared_error(y_test,pred))
print(f'Mean error: {mse:3.3} ({mse/np.mean(pred)*100:3.3}%)')

score = pipeline.score(X_train,y_train)
print('Model determination: ', score)
```  

یہ ہمیں تقریباً 97% کا بہترین determination coefficient اور MSE=2.23 (~8% پیش گوئی کی غلطی) دے گا۔

| ماڈل | MSE | Determination |  
|-------|-----|---------------|  
| `DayOfYear` Linear | 2.77 (17.2%) | 0.07 |  
| `DayOfYear` Polynomial | 2.73 (17.0%) | 0.08 |  
| `Variety` Linear | 5.24 (19.7%) | 0.77 |  
| All features Linear | 2.84 (10.5%) | 0.94 |  
| All features Polynomial | 2.23 (8.25%) | 0.97 |  

🏆 شاباش! آپ نے ایک سبق میں چار ریگریشن ماڈلز بنائے، اور ماڈل کے معیار کو 97% تک بہتر کیا۔ ریگریشن کے آخری حصے میں، آپ سیکھیں گے کہ زمرے کا تعین کرنے کے لیے Logistic Regression کیسے استعمال کریں۔

---
## 🚀چیلنج  

اس نوٹ بک میں مختلف متغیرات کو آزمائیں تاکہ دیکھ سکیں کہ correlation ماڈل کی درستگی سے کیسے مطابقت رکھتا ہے۔

## [لیکچر کے بعد کا کوئز](https://ff-quizzes.netlify.app/en/ml/)

## جائزہ اور خود مطالعہ  

اس سبق میں ہم نے لکیری ریگریشن کے بارے میں سیکھا۔ ریگریشن کی دیگر اہم اقسام بھی ہیں۔ Stepwise, Ridge, Lasso اور Elasticnet تکنیک کے بارے میں پڑھیں۔ مزید سیکھنے کے لیے ایک اچھا کورس [Stanford Statistical Learning course](https://online.stanford.edu/courses/sohs-ystatslearning-statistical-learning) ہے۔

## اسائنمنٹ  

[ماڈل بنائیں](assignment.md)  

---

**ڈسکلیمر**:  
یہ دستاویز AI ترجمہ سروس [Co-op Translator](https://github.com/Azure/co-op-translator) کا استعمال کرتے ہوئے ترجمہ کی گئی ہے۔ ہم درستگی کے لیے کوشش کرتے ہیں، لیکن براہ کرم آگاہ رہیں کہ خودکار ترجمے میں غلطیاں یا غیر درستیاں ہو سکتی ہیں۔ اصل دستاویز کو اس کی اصل زبان میں مستند ذریعہ سمجھا جانا چاہیے۔ اہم معلومات کے لیے، پیشہ ور انسانی ترجمہ کی سفارش کی جاتی ہے۔ ہم اس ترجمے کے استعمال سے پیدا ہونے والی کسی بھی غلط فہمی یا غلط تشریح کے ذمہ دار نہیں ہیں۔