<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "730225ea274c9174fe688b21d421539d",
  "translation_date": "2025-09-05T15:43:36+00:00",
  "source_file": "5-Clustering/1-Visualize/README.md",
  "language_code": "ro"
}
-->
# Introducere √Æn clustering

Clustering-ul este un tip de [√énvƒÉ»õare NesupervizatƒÉ](https://wikipedia.org/wiki/Unsupervised_learning) care presupune cƒÉ un set de date nu este etichetat sau cƒÉ intrƒÉrile sale nu sunt asociate cu ie»ôiri predefinite. Folose»ôte diverse algoritmi pentru a analiza datele neetichetate »ôi a oferi grupƒÉri bazate pe tiparele identificate √Æn date.

[![No One Like You de PSquare](https://img.youtube.com/vi/ty2advRiWJM/0.jpg)](https://youtu.be/ty2advRiWJM "No One Like You de PSquare")

> üé• Click pe imaginea de mai sus pentru un videoclip. √én timp ce studiezi √ÆnvƒÉ»õarea automatƒÉ cu clustering, bucurƒÉ-te de c√¢teva piese de Dance Hall nigerian - aceasta este o melodie foarte apreciatƒÉ din 2014 de PSquare.

## [Quiz √Ænainte de lec»õie](https://ff-quizzes.netlify.app/en/ml/)

### Introducere

[Clustering-ul](https://link.springer.com/referenceworkentry/10.1007%2F978-0-387-30164-8_124) este foarte util pentru explorarea datelor. SƒÉ vedem dacƒÉ poate ajuta la descoperirea tendin»õelor »ôi tiparelor √Æn modul √Æn care publicul nigerian consumƒÉ muzicƒÉ.

‚úÖ Ia un minut sƒÉ te g√¢nde»ôti la utilizƒÉrile clustering-ului. √én via»õa realƒÉ, clustering-ul se √Ænt√¢mplƒÉ ori de c√¢te ori ai o grƒÉmadƒÉ de rufe »ôi trebuie sƒÉ sortezi hainele membrilor familiei üß¶üëïüëñü©≤. √én »ôtiin»õa datelor, clustering-ul se √Ænt√¢mplƒÉ atunci c√¢nd √Æncerci sƒÉ analizezi preferin»õele unui utilizator sau sƒÉ determini caracteristicile unui set de date neetichetat. Clustering-ul, √Æntr-un fel, ajutƒÉ la a face ordine √Æn haos, ca un sertar de »ôosete.

[![Introducere √Æn ML](https://img.youtube.com/vi/esmzYhuFnds/0.jpg)](https://youtu.be/esmzYhuFnds "Introducere √Æn Clustering")

> üé• Click pe imaginea de mai sus pentru un videoclip: John Guttag de la MIT introduce clustering-ul.

√éntr-un mediu profesional, clustering-ul poate fi utilizat pentru a determina lucruri precum segmentarea pie»õei, identificarea grupelor de v√¢rstƒÉ care cumpƒÉrƒÉ anumite produse, de exemplu. O altƒÉ utilizare ar fi detectarea anomaliilor, poate pentru a identifica fraude √Æntr-un set de date cu tranzac»õii de carduri de credit. Sau ai putea folosi clustering-ul pentru a identifica tumori √Æntr-un lot de scanƒÉri medicale.

‚úÖ G√¢nde»ôte-te un minut la cum ai putea √Ænt√¢lni clustering-ul '√Æn sƒÉlbƒÉticie', √Æntr-un mediu bancar, de e-commerce sau de afaceri.

> üéì Interesant, analiza clusterelor a apƒÉrut √Æn domeniile Antropologiei »ôi Psihologiei √Æn anii 1930. √é»õi po»õi imagina cum ar fi fost utilizatƒÉ?

Alternativ, ai putea sƒÉ-l folose»ôti pentru gruparea rezultatelor cƒÉutƒÉrii - de exemplu, dupƒÉ linkuri de cumpƒÉrƒÉturi, imagini sau recenzii. Clustering-ul este util atunci c√¢nd ai un set de date mare pe care vrei sƒÉ-l reduci »ôi pe care vrei sƒÉ efectuezi o analizƒÉ mai detaliatƒÉ, astfel √Ænc√¢t tehnica poate fi utilizatƒÉ pentru a √ÆnvƒÉ»õa despre date √Ænainte de a construi alte modele.

‚úÖ OdatƒÉ ce datele tale sunt organizate √Æn clustere, le atribui un Id de cluster, iar aceastƒÉ tehnicƒÉ poate fi utilƒÉ pentru a pƒÉstra confiden»õialitatea unui set de date; po»õi sƒÉ te referi la un punct de date prin Id-ul sƒÉu de cluster, mai degrabƒÉ dec√¢t prin date identificabile mai revelatoare. Po»õi sƒÉ te g√¢nde»ôti la alte motive pentru care ai prefera sƒÉ te referi la un Id de cluster √Æn loc de alte elemente ale clusterului pentru a-l identifica?

AprofundeazƒÉ-»õi √Æn»õelegerea tehnicilor de clustering √Æn acest [modul de √ÆnvƒÉ»õare](https://docs.microsoft.com/learn/modules/train-evaluate-cluster-models?WT.mc_id=academic-77952-leestott).

## √énceperea cu clustering

[Scikit-learn oferƒÉ o gamƒÉ largƒÉ](https://scikit-learn.org/stable/modules/clustering.html) de metode pentru a efectua clustering. Tipul pe care √Æl alegi va depinde de cazul tƒÉu de utilizare. Conform documenta»õiei, fiecare metodƒÉ are diverse beneficii. IatƒÉ un tabel simplificat al metodelor suportate de Scikit-learn »ôi cazurile lor de utilizare adecvate:

| Numele metodei               | Caz de utilizare                                                     |
| :--------------------------- | :------------------------------------------------------------------- |
| K-Means                      | scop general, inductiv                                               |
| Propagarea afinitƒÉ»õii        | multe, clustere inegale, inductiv                                    |
| Mean-shift                   | multe, clustere inegale, inductiv                                    |
| Clustering spectral          | pu»õine, clustere egale, transductiv                                 |
| Clustering ierarhic Ward     | multe, clustere constr√¢nse, transductiv                             |
| Clustering aglomerativ       | multe, constr√¢nse, distan»õe non-euclidiene, transductiv             |
| DBSCAN                       | geometrie non-planƒÉ, clustere inegale, transductiv                  |
| OPTICS                       | geometrie non-planƒÉ, clustere inegale cu densitate variabilƒÉ, transductiv |
| Amestecuri Gaussiene         | geometrie planƒÉ, inductiv                                           |
| BIRCH                        | set de date mare cu outlieri, inductiv                              |

> üéì Modul √Æn care creƒÉm clustere are mult de-a face cu modul √Æn care grupƒÉm punctele de date √Æn grupuri. SƒÉ descompunem c√¢teva vocabular:
>
> üéì ['Transductiv' vs. 'inductiv'](https://wikipedia.org/wiki/Transduction_(machine_learning))
> 
> Inferen»õa transductivƒÉ este derivatƒÉ din cazuri de antrenament observate care se mapeazƒÉ la cazuri de testare specifice. Inferen»õa inductivƒÉ este derivatƒÉ din cazuri de antrenament care se mapeazƒÉ la reguli generale care sunt aplicate ulterior cazurilor de testare.
> 
> Un exemplu: ImagineazƒÉ-»õi cƒÉ ai un set de date care este doar par»õial etichetat. Unele lucruri sunt 'discuri', altele 'cd-uri', iar unele sunt goale. Sarcina ta este sƒÉ oferi etichete pentru cele goale. DacƒÉ alegi o abordare inductivƒÉ, ai antrena un model cƒÉut√¢nd 'discuri' »ôi 'cd-uri' »ôi ai aplica acele etichete datelor neetichetate. AceastƒÉ abordare va avea dificultƒÉ»õi √Æn clasificarea lucrurilor care sunt de fapt 'casete'. O abordare transductivƒÉ, pe de altƒÉ parte, gestioneazƒÉ aceste date necunoscute mai eficient, deoarece lucreazƒÉ pentru a grupa elemente similare √ÆmpreunƒÉ »ôi apoi aplicƒÉ o etichetƒÉ unui grup. √én acest caz, clusterele ar putea reflecta 'lucruri muzicale rotunde' »ôi 'lucruri muzicale pƒÉtrate'.
> 
> üéì ['Geometrie non-planƒÉ' vs. 'planƒÉ'](https://datascience.stackexchange.com/questions/52260/terminology-flat-geometry-in-the-context-of-clustering)
> 
> Derivat din terminologia matematicƒÉ, geometria non-planƒÉ vs. planƒÉ se referƒÉ la mƒÉsurarea distan»õelor √Æntre puncte fie prin metode geometrice 'plane' ([Euclidiene](https://wikipedia.org/wiki/Euclidean_geometry)), fie 'non-plane' (non-Euclidiene).
>
>'PlanƒÉ' √Æn acest context se referƒÉ la geometria EuclidianƒÉ (pƒÉr»õi din care sunt predate ca geometrie 'planƒÉ'), iar non-planƒÉ se referƒÉ la geometria non-EuclidianƒÉ. Ce legƒÉturƒÉ are geometria cu √ÆnvƒÉ»õarea automatƒÉ? Ei bine, ca douƒÉ domenii care sunt bazate pe matematicƒÉ, trebuie sƒÉ existe o modalitate comunƒÉ de a mƒÉsura distan»õele √Æntre puncte √Æn clustere, iar aceasta poate fi fƒÉcutƒÉ √Æntr-un mod 'plan' sau 'non-plan', √Æn func»õie de natura datelor. [Distan»õele Euclidiene](https://wikipedia.org/wiki/Euclidean_distance) sunt mƒÉsurate ca lungimea unui segment de linie √Æntre douƒÉ puncte. [Distan»õele non-Euclidiene](https://wikipedia.org/wiki/Non-Euclidean_geometry) sunt mƒÉsurate de-a lungul unei curbe. DacƒÉ datele tale, vizualizate, par sƒÉ nu existe pe un plan, s-ar putea sƒÉ fie nevoie sƒÉ folose»ôti un algoritm specializat pentru a le gestiona.
>
![Infografic Geometrie PlanƒÉ vs Non-planƒÉ](../../../../5-Clustering/1-Visualize/images/flat-nonflat.png)
> Infografic de [Dasani Madipalli](https://twitter.com/dasani_decoded)
> 
> üéì ['Distan»õe'](https://web.stanford.edu/class/cs345a/slides/12-clustering.pdf)
> 
> Clusterele sunt definite de matricea lor de distan»õe, de exemplu, distan»õele √Æntre puncte. AceastƒÉ distan»õƒÉ poate fi mƒÉsuratƒÉ √Æn c√¢teva moduri. Clusterele Euclidiene sunt definite de media valorilor punctelor »ôi con»õin un 'centroid' sau punct central. Distan»õele sunt astfel mƒÉsurate prin distan»õa fa»õƒÉ de acel centroid. Distan»õele non-Euclidiene se referƒÉ la 'clustroizi', punctul cel mai apropiat de alte puncte. Clustroizii, la r√¢ndul lor, pot fi defini»õi √Æn diverse moduri.
> 
> üéì ['Constr√¢ns'](https://wikipedia.org/wiki/Constrained_clustering)
> 
> [Clustering-ul Constr√¢ns](https://web.cs.ucdavis.edu/~davidson/Publications/ICDMTutorial.pdf) introduce '√ÆnvƒÉ»õarea semi-supervizatƒÉ' √Æn aceastƒÉ metodƒÉ nesupervizatƒÉ. Rela»õiile dintre puncte sunt marcate ca 'nu se pot lega' sau 'trebuie sƒÉ se lege', astfel √Ænc√¢t unele reguli sunt impuse setului de date.
>
>Un exemplu: DacƒÉ un algoritm este lƒÉsat liber pe un lot de date neetichetate sau semi-etichetate, clusterele pe care le produce pot fi de calitate slabƒÉ. √én exemplul de mai sus, clusterele ar putea grupa 'lucruri muzicale rotunde', 'lucruri muzicale pƒÉtrate', 'lucruri triunghiulare' »ôi 'fursecuri'. DacƒÉ i se oferƒÉ c√¢teva constr√¢ngeri sau reguli de urmat ("elementul trebuie sƒÉ fie din plastic", "elementul trebuie sƒÉ poatƒÉ produce muzicƒÉ"), acest lucru poate ajuta la 'constr√¢ngerea' algoritmului sƒÉ facƒÉ alegeri mai bune.
> 
> üéì 'Densitate'
> 
> Datele care sunt 'zgomotoase' sunt considerate a fi 'dense'. Distan»õele √Æntre punctele din fiecare cluster pot fi, la examinare, mai mult sau mai pu»õin dense sau 'aglomerate', »ôi astfel aceste date trebuie analizate cu metoda de clustering adecvatƒÉ. [Acest articol](https://www.kdnuggets.com/2020/02/understanding-density-based-clustering.html) demonstreazƒÉ diferen»õa dintre utilizarea clustering-ului K-Means vs. algoritmii HDBSCAN pentru a explora un set de date zgomotos cu densitate inegalƒÉ a clusterelor.

## Algoritmi de clustering

ExistƒÉ peste 100 de algoritmi de clustering, iar utilizarea lor depinde de natura datelor disponibile. SƒÉ discutƒÉm despre c√¢»õiva dintre cei mai importan»õi:

- **Clustering ierarhic**. DacƒÉ un obiect este clasificat prin proximitatea sa fa»õƒÉ de un obiect apropiat, mai degrabƒÉ dec√¢t fa»õƒÉ de unul mai √ÆndepƒÉrtat, clusterele sunt formate pe baza distan»õei membrilor fa»õƒÉ de »ôi de la alte obiecte. Clustering-ul aglomerativ din Scikit-learn este ierarhic.

   ![Infografic Clustering Ierarhic](../../../../5-Clustering/1-Visualize/images/hierarchical.png)
   > Infografic de [Dasani Madipalli](https://twitter.com/dasani_decoded)

- **Clustering pe bazƒÉ de centroid**. Acest algoritm popular necesitƒÉ alegerea 'k', sau numƒÉrul de clustere de format, dupƒÉ care algoritmul determinƒÉ punctul central al unui cluster »ôi adunƒÉ date √Æn jurul acelui punct. [Clustering-ul K-means](https://wikipedia.org/wiki/K-means_clustering) este o versiune popularƒÉ a clustering-ului pe bazƒÉ de centroid. Centrul este determinat de media cea mai apropiatƒÉ, de aici »ôi numele. Distan»õa pƒÉtratƒÉ fa»õƒÉ de cluster este minimizatƒÉ.

   ![Infografic Clustering pe bazƒÉ de Centroid](../../../../5-Clustering/1-Visualize/images/centroid.png)
   > Infografic de [Dasani Madipalli](https://twitter.com/dasani_decoded)

- **Clustering bazat pe distribu»õie**. Bazat pe modelarea statisticƒÉ, clustering-ul bazat pe distribu»õie se concentreazƒÉ pe determinarea probabilitƒÉ»õii ca un punct de date sƒÉ apar»õinƒÉ unui cluster »ôi √Æl atribuie corespunzƒÉtor. Metodele de amestecuri Gaussiene apar»õin acestui tip.

- **Clustering bazat pe densitate**. Punctele de date sunt atribuite clusterelor pe baza densitƒÉ»õii lor sau a grupƒÉrii lor √Æn jurul altor puncte. Punctele de date aflate departe de grup sunt considerate outlieri sau zgomot. DBSCAN, Mean-shift »ôi OPTICS apar»õin acestui tip de clustering.

- **Clustering bazat pe grilƒÉ**. Pentru seturi de date multidimensionale, se creeazƒÉ o grilƒÉ, iar datele sunt √ÆmpƒÉr»õite √Æntre celulele grilei, cre√¢nd astfel clustere.

## Exerci»õiu - grupeazƒÉ datele tale

Clustering-ul ca tehnicƒÉ este foarte ajutat de o vizualizare adecvatƒÉ, a»ôa cƒÉ sƒÉ √Æncepem prin a vizualiza datele noastre muzicale. Acest exerci»õiu ne va ajuta sƒÉ decidem care dintre metodele de clustering ar trebui sƒÉ folosim cel mai eficient pentru natura acestor date.

1. Deschide fi»ôierul [_notebook.ipynb_](https://github.com/microsoft/ML-For-Beginners/blob/main/5-Clustering/1-Visualize/notebook.ipynb) din acest folder.

1. ImportƒÉ pachetul `Seaborn` pentru o vizualizare bunƒÉ a datelor.

    ```python
    !pip install seaborn
    ```

1. AdaugƒÉ datele despre melodii din [_nigerian-songs.csv_](https://github.com/microsoft/ML-For-Beginners/blob/main/5-Clustering/data/nigerian-songs.csv). √éncarcƒÉ un dataframe cu c√¢teva date despre melodii. PregƒÉte»ôte-te sƒÉ explorezi aceste date import√¢nd bibliotecile »ôi afi»ô√¢nd datele:

    ```python
    import matplotlib.pyplot as plt
    import pandas as pd
    
    df = pd.read_csv("../data/nigerian-songs.csv")
    df.head()
    ```

    VerificƒÉ primele c√¢teva linii de date:

    |     | name                     | album                        | artist              | artist_top_genre | release_date | length | popularity | danceability | acousticness | energy | instrumentalness | liveness | loudness | speechiness | tempo   | time_signature |
    | --- | ------------------------ | ---------------------------- | ------------------- | ---------------- | ------------ | ------ | ---------- | ------------ | ------------ | ------ | ---------------- | -------- | -------- | ----------- | ------- | -------------- |
    | 0   | Sparky                   | Mandy & The Jungle           | Cruel Santino       | alternative r&b  | 2019         | 144000 | 48         | 0.666        | 0.851        | 0.42   | 0.534            | 0.11     | -6.699   | 0.0829      | 133.015 | 5              |
    | 1   | shuga rush               | EVERYTHING YOU HEARD IS TRUE | Odunsi (The Engine) | afropop          | 2020         | 89488  | 30         | 0.71         | 0.0822       | 0.683  | 0.000169         | 0.101    | -5.64    | 0.36        | 129.993 | 3              |
| 2   | LITT!                    | LITT!                        | AYL√ò                | indie r&b        | 2018         | 207758 | 40         | 0.836        | 0.272        | 0.564  | 0.000537         | 0.11     | -7.127   | 0.0424      | 130.005 | 4              |
| 3   | Confident / Feeling Cool | Enjoy Your Life              | Lady Donli          | nigerian pop     | 2019         | 175135 | 14         | 0.894        | 0.798        | 0.611  | 0.000187         | 0.0964   | -4.961   | 0.113       | 111.087 | 4              |
| 4   | wanted you               | rare.                        | Odunsi (The Engine) | afropop          | 2018         | 152049 | 25         | 0.702        | 0.116        | 0.833  | 0.91             | 0.348    | -6.044   | 0.0447      | 105.115 | 4              |

1. Ob»õine informa»õii despre dataframe, apel√¢nd `info()`:

    ```python
    df.info()
    ```

   Rezultatul aratƒÉ astfel:

    ```output
    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 530 entries, 0 to 529
    Data columns (total 16 columns):
     #   Column            Non-Null Count  Dtype  
    ---  ------            --------------  -----  
     0   name              530 non-null    object 
     1   album             530 non-null    object 
     2   artist            530 non-null    object 
     3   artist_top_genre  530 non-null    object 
     4   release_date      530 non-null    int64  
     5   length            530 non-null    int64  
     6   popularity        530 non-null    int64  
     7   danceability      530 non-null    float64
     8   acousticness      530 non-null    float64
     9   energy            530 non-null    float64
     10  instrumentalness  530 non-null    float64
     11  liveness          530 non-null    float64
     12  loudness          530 non-null    float64
     13  speechiness       530 non-null    float64
     14  tempo             530 non-null    float64
     15  time_signature    530 non-null    int64  
    dtypes: float64(8), int64(4), object(4)
    memory usage: 66.4+ KB
    ```

1. VerificƒÉ din nou valorile nule, apel√¢nd `isnull()` »ôi verific√¢nd cƒÉ suma este 0:

    ```python
    df.isnull().sum()
    ```

    Totul aratƒÉ bine:

    ```output
    name                0
    album               0
    artist              0
    artist_top_genre    0
    release_date        0
    length              0
    popularity          0
    danceability        0
    acousticness        0
    energy              0
    instrumentalness    0
    liveness            0
    loudness            0
    speechiness         0
    tempo               0
    time_signature      0
    dtype: int64
    ```

1. Descrie datele:

    ```python
    df.describe()
    ```

    |       | release_date | length      | popularity | danceability | acousticness | energy   | instrumentalness | liveness | loudness  | speechiness | tempo      | time_signature |
    | ----- | ------------ | ----------- | ---------- | ------------ | ------------ | -------- | ---------------- | -------- | --------- | ----------- | ---------- | -------------- |
    | count | 530          | 530         | 530        | 530          | 530          | 530      | 530              | 530      | 530       | 530         | 530        | 530            |
    | mean  | 2015.390566  | 222298.1698 | 17.507547  | 0.741619     | 0.265412     | 0.760623 | 0.016305         | 0.147308 | -4.953011 | 0.130748    | 116.487864 | 3.986792       |
    | std   | 3.131688     | 39696.82226 | 18.992212  | 0.117522     | 0.208342     | 0.148533 | 0.090321         | 0.123588 | 2.464186  | 0.092939    | 23.518601  | 0.333701       |
    | min   | 1998         | 89488       | 0          | 0.255        | 0.000665     | 0.111    | 0                | 0.0283   | -19.362   | 0.0278      | 61.695     | 3              |
    | 25%   | 2014         | 199305      | 0          | 0.681        | 0.089525     | 0.669    | 0                | 0.07565  | -6.29875  | 0.0591      | 102.96125  | 4              |
    | 50%   | 2016         | 218509      | 13         | 0.761        | 0.2205       | 0.7845   | 0.000004         | 0.1035   | -4.5585   | 0.09795     | 112.7145   | 4              |
    | 75%   | 2017         | 242098.5    | 31         | 0.8295       | 0.403        | 0.87575  | 0.000234         | 0.164    | -3.331    | 0.177       | 125.03925  | 4              |
    | max   | 2020         | 511738      | 73         | 0.966        | 0.954        | 0.995    | 0.91             | 0.811    | 0.582     | 0.514       | 206.007    | 5              |

> ü§î DacƒÉ lucrƒÉm cu clustering, o metodƒÉ nesupravegheatƒÉ care nu necesitƒÉ date etichetate, de ce arƒÉtƒÉm aceste date cu etichete? √én faza de explorare a datelor, acestea sunt utile, dar nu sunt necesare pentru ca algoritmii de clustering sƒÉ func»õioneze. Ai putea la fel de bine sƒÉ elimini anteturile coloanelor »ôi sƒÉ te referi la date prin numƒÉrul coloanei.

Prive»ôte valorile generale ale datelor. ObservƒÉ cƒÉ popularitatea poate fi '0', ceea ce indicƒÉ melodii care nu au un clasament. SƒÉ eliminƒÉm aceste valori √Æn cur√¢nd.

1. Folose»ôte un barplot pentru a afla cele mai populare genuri:

    ```python
    import seaborn as sns
    
    top = df['artist_top_genre'].value_counts()
    plt.figure(figsize=(10,7))
    sns.barplot(x=top[:5].index,y=top[:5].values)
    plt.xticks(rotation=45)
    plt.title('Top genres',color = 'blue')
    ```

    ![most popular](../../../../5-Clustering/1-Visualize/images/popular.png)

‚úÖ DacƒÉ dore»ôti sƒÉ vezi mai multe valori de top, schimbƒÉ topul `[:5]` la o valoare mai mare sau eliminƒÉ-l pentru a vedea totul.

ObservƒÉ cƒÉ atunci c√¢nd genul de top este descris ca 'Missing', √ÆnseamnƒÉ cƒÉ Spotify nu l-a clasificat, a»ôa cƒÉ sƒÉ scƒÉpƒÉm de acesta.

1. EliminƒÉ datele lipsƒÉ prin filtrarea lor

    ```python
    df = df[df['artist_top_genre'] != 'Missing']
    top = df['artist_top_genre'].value_counts()
    plt.figure(figsize=(10,7))
    sns.barplot(x=top.index,y=top.values)
    plt.xticks(rotation=45)
    plt.title('Top genres',color = 'blue')
    ```

    Acum verificƒÉ din nou genurile:

    ![most popular](../../../../5-Clustering/1-Visualize/images/all-genres.png)

1. Cele trei genuri de top dominƒÉ acest set de date. SƒÉ ne concentrƒÉm pe `afro dancehall`, `afropop` »ôi `nigerian pop`, »ôi sƒÉ filtrƒÉm suplimentar setul de date pentru a elimina orice valoare de popularitate 0 (ceea ce √ÆnseamnƒÉ cƒÉ nu a fost clasificatƒÉ cu o popularitate √Æn setul de date »ôi poate fi consideratƒÉ zgomot pentru scopurile noastre):

    ```python
    df = df[(df['artist_top_genre'] == 'afro dancehall') | (df['artist_top_genre'] == 'afropop') | (df['artist_top_genre'] == 'nigerian pop')]
    df = df[(df['popularity'] > 0)]
    top = df['artist_top_genre'].value_counts()
    plt.figure(figsize=(10,7))
    sns.barplot(x=top.index,y=top.values)
    plt.xticks(rotation=45)
    plt.title('Top genres',color = 'blue')
    ```

1. FƒÉ un test rapid pentru a vedea dacƒÉ datele coreleazƒÉ √Æntr-un mod deosebit de puternic:

    ```python
    corrmat = df.corr(numeric_only=True)
    f, ax = plt.subplots(figsize=(12, 9))
    sns.heatmap(corrmat, vmax=.8, square=True)
    ```

    ![correlations](../../../../5-Clustering/1-Visualize/images/correlation.png)

    Singura corela»õie puternicƒÉ este √Æntre `energy` »ôi `loudness`, ceea ce nu este prea surprinzƒÉtor, av√¢nd √Æn vedere cƒÉ muzica tare este de obicei destul de energicƒÉ. √én rest, corela»õiile sunt relativ slabe. Va fi interesant sƒÉ vedem ce poate face un algoritm de clustering cu aceste date.

    > üéì Re»õine cƒÉ corela»õia nu implicƒÉ cauzalitate! Avem dovada corela»õiei, dar nu »ôi dovada cauzalitƒÉ»õii. Un [site web amuzant](https://tylervigen.com/spurious-correlations) are c√¢teva vizualizƒÉri care subliniazƒÉ acest punct.

ExistƒÉ vreo convergen»õƒÉ √Æn acest set de date √Æn jurul popularitƒÉ»õii percepute a unei melodii »ôi a dansabilitƒÉ»õii? Un FacetGrid aratƒÉ cƒÉ existƒÉ cercuri concentrice care se aliniazƒÉ, indiferent de gen. Ar putea fi cƒÉ gusturile nigeriene converg la un anumit nivel de dansabilitate pentru acest gen?

‚úÖ √éncearcƒÉ diferite puncte de date (energy, loudness, speechiness) »ôi mai multe sau diferite genuri muzicale. Ce po»õi descoperi? Prive»ôte tabelul `df.describe()` pentru a vedea rƒÉsp√¢ndirea generalƒÉ a punctelor de date.

### Exerci»õiu - distribu»õia datelor

Aceste trei genuri sunt semnificativ diferite √Æn percep»õia dansabilitƒÉ»õii lor, bazatƒÉ pe popularitate?

1. ExamineazƒÉ distribu»õia datelor pentru genurile noastre de top √Æn ceea ce prive»ôte popularitatea »ôi dansabilitatea de-a lungul unei axe x »ôi y date.

    ```python
    sns.set_theme(style="ticks")
    
    g = sns.jointplot(
        data=df,
        x="popularity", y="danceability", hue="artist_top_genre",
        kind="kde",
    )
    ```

    Po»õi descoperi cercuri concentrice √Æn jurul unui punct general de convergen»õƒÉ, arƒÉt√¢nd distribu»õia punctelor.

    > üéì Re»õine cƒÉ acest exemplu folose»ôte un grafic KDE (Kernel Density Estimate) care reprezintƒÉ datele folosind o curbƒÉ continuƒÉ de densitate a probabilitƒÉ»õii. Acest lucru ne permite sƒÉ interpretƒÉm datele atunci c√¢nd lucrƒÉm cu distribu»õii multiple.

    √én general, cele trei genuri se aliniazƒÉ vag √Æn ceea ce prive»ôte popularitatea »ôi dansabilitatea. Determinarea clusterelor √Æn aceste date vag aliniate va fi o provocare:

    ![distribution](../../../../5-Clustering/1-Visualize/images/distribution.png)

1. CreeazƒÉ un scatter plot:

    ```python
    sns.FacetGrid(df, hue="artist_top_genre", height=5) \
       .map(plt.scatter, "popularity", "danceability") \
       .add_legend()
    ```

    Un scatterplot pe acelea»ôi axe aratƒÉ un model similar de convergen»õƒÉ

    ![Facetgrid](../../../../5-Clustering/1-Visualize/images/facetgrid.png)

√én general, pentru clustering, po»õi folosi scatterplots pentru a arƒÉta clusterele de date, a»ôa cƒÉ stƒÉp√¢nirea acestui tip de vizualizare este foarte utilƒÉ. √én lec»õia urmƒÉtoare, vom lua aceste date filtrate »ôi vom folosi clustering-ul k-means pentru a descoperi grupuri √Æn aceste date care par sƒÉ se suprapunƒÉ √Æn moduri interesante.

---

## üöÄProvocare

√én pregƒÉtirea pentru lec»õia urmƒÉtoare, creeazƒÉ un grafic despre diferitele algoritmi de clustering pe care i-ai putea descoperi »ôi folosi √Æntr-un mediu de produc»õie. Ce tipuri de probleme √ÆncearcƒÉ sƒÉ abordeze clustering-ul?

## [Post-lecture quiz](https://ff-quizzes.netlify.app/en/ml/)

## Recapitulare & Studiu Individual

√énainte de a aplica algoritmi de clustering, a»ôa cum am √ÆnvƒÉ»õat, este o idee bunƒÉ sƒÉ √Æn»õelegi natura setului tƒÉu de date. Cite»ôte mai multe despre acest subiect [aici](https://www.kdnuggets.com/2019/10/right-clustering-algorithm.html)

[Acest articol util](https://www.freecodecamp.org/news/8-clustering-algorithms-in-machine-learning-that-all-data-scientists-should-know/) te ghideazƒÉ prin diferitele moduri √Æn care algoritmii de clustering se comportƒÉ, av√¢nd √Æn vedere diferite forme de date.

## TemƒÉ

[CerceteazƒÉ alte vizualizƒÉri pentru clustering](assignment.md)

---

**Declinare de responsabilitate**:  
Acest document a fost tradus folosind serviciul de traducere AI [Co-op Translator](https://github.com/Azure/co-op-translator). De»ôi ne strƒÉduim sƒÉ asigurƒÉm acurate»õea, vƒÉ rugƒÉm sƒÉ re»õine»õi cƒÉ traducerile automate pot con»õine erori sau inexactitƒÉ»õi. Documentul original √Æn limba sa natalƒÉ ar trebui considerat sursa autoritarƒÉ. Pentru informa»õii critice, se recomandƒÉ traducerea profesionalƒÉ realizatƒÉ de un specialist uman. Nu ne asumƒÉm responsabilitatea pentru eventualele ne√Æn»õelegeri sau interpretƒÉri gre»ôite care pot apƒÉrea din utilizarea acestei traduceri.