# This file is automatically generated by _generate_pyx.py.
# Do not edit manually!

from libc.math cimport NAN

include "_ufuncs_extra_code_common.pxi"
include "_ufuncs_extra_code.pxi"
__all__ = ['agm', 'airy', 'airye', 'bdtr', 'bdtrc', 'bdtri', 'bdtrik', 'bdtrin', 'bei', 'beip', 'ber', 'berp', 'besselpoly', 'beta', 'betainc', 'betaincc', 'betainccinv', 'betaincinv', 'betaln', 'binom', 'boxcox', 'boxcox1p', 'btdtr', 'btdtri', 'btdtria', 'btdtrib', 'cbrt', 'chdtr', 'chdtrc', 'chdtri', 'chdtriv', 'chndtr', 'chndtridf', 'chndtrinc', 'chndtrix', 'cosdg', 'cosm1', 'cotdg', 'dawsn', 'ellipe', 'ellipeinc', 'ellipj', 'ellipk', 'ellipkinc', 'ellipkm1', 'elliprc', 'elliprd', 'elliprf', 'elliprg', 'elliprj', 'entr', 'erf', 'erfc', 'erfcinv', 'erfcx', 'erfi', 'erfinv', 'eval_chebyc', 'eval_chebys', 'eval_chebyt', 'eval_chebyu', 'eval_gegenbauer', 'eval_genlaguerre', 'eval_hermite', 'eval_hermitenorm', 'eval_jacobi', 'eval_laguerre', 'eval_legendre', 'eval_sh_chebyt', 'eval_sh_chebyu', 'eval_sh_jacobi', 'eval_sh_legendre', 'exp1', 'exp10', 'exp2', 'expi', 'expit', 'expm1', 'expn', 'exprel', 'fdtr', 'fdtrc', 'fdtri', 'fdtridfd', 'fresnel', 'gamma', 'gammainc', 'gammaincc', 'gammainccinv', 'gammaincinv', 'gammaln', 'gammasgn', 'gdtr', 'gdtrc', 'gdtria', 'gdtrib', 'gdtrix', 'hankel1', 'hankel1e', 'hankel2', 'hankel2e', 'huber', 'hyp0f1', 'hyp1f1', 'hyp2f1', 'hyperu', 'i0', 'i0e', 'i1', 'i1e', 'inv_boxcox', 'inv_boxcox1p', 'it2i0k0', 'it2j0y0', 'it2struve0', 'itairy', 'iti0k0', 'itj0y0', 'itmodstruve0', 'itstruve0', 'iv', 'ive', 'j0', 'j1', 'jv', 'jve', 'k0', 'k0e', 'k1', 'k1e', 'kei', 'keip', 'kelvin', 'ker', 'kerp', 'kl_div', 'kn', 'kolmogi', 'kolmogorov', 'kv', 'kve', 'log1p', 'log_expit', 'log_ndtr', 'loggamma', 'logit', 'lpmv', 'mathieu_a', 'mathieu_b', 'mathieu_cem', 'mathieu_modcem1', 'mathieu_modcem2', 'mathieu_modsem1', 'mathieu_modsem2', 'mathieu_sem', 'modfresnelm', 'modfresnelp', 'modstruve', 'nbdtr', 'nbdtrc', 'nbdtri', 'nbdtrik', 'nbdtrin', 'ncfdtr', 'ncfdtri', 'ncfdtridfd', 'ncfdtridfn', 'ncfdtrinc', 'nctdtr', 'nctdtridf', 'nctdtrinc', 'nctdtrit', 'ndtr', 'ndtri', 'ndtri_exp', 'nrdtrimn', 'nrdtrisd', 'obl_ang1', 'obl_ang1_cv', 'obl_cv', 'obl_rad1', 'obl_rad1_cv', 'obl_rad2', 'obl_rad2_cv', 'owens_t', 'pbdv', 'pbvv', 'pbwa', 'pdtr', 'pdtrc', 'pdtri', 'pdtrik', 'poch', 'powm1', 'pro_ang1', 'pro_ang1_cv', 'pro_cv', 'pro_rad1', 'pro_rad1_cv', 'pro_rad2', 'pro_rad2_cv', 'pseudo_huber', 'psi', 'radian', 'rel_entr', 'rgamma', 'round', 'shichi', 'sici', 'sindg', 'smirnov', 'smirnovi', 'spence', 'sph_harm', 'stdtr', 'stdtridf', 'stdtrit', 'struve', 'tandg', 'tklmbda', 'voigt_profile', 'wofz', 'wright_bessel', 'wrightomega', 'xlog1py', 'xlogy', 'y0', 'y1', 'yn', 'yv', 'yve', 'zetac', 'geterr', 'seterr', 'errstate', 'jn']
cdef void loop_D_DDDD__As_DDDD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], <double complex>(<double complex*>ip1)[0], <double complex>(<double complex*>ip2)[0], <double complex>(<double complex*>ip3)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_DDDD__As_FFFF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], <double complex>(<float complex*>ip1)[0], <double complex>(<float complex*>ip2)[0], <double complex>(<float complex*>ip3)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_DDD__As_DDD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], <double complex>(<double complex*>ip1)[0], <double complex>(<double complex*>ip2)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_DDD__As_FFF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], <double complex>(<float complex*>ip1)[0], <double complex>(<float complex*>ip2)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_DD__As_DD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], <double complex>(<double complex*>ip1)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_DD__As_FF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], <double complex>(<float complex*>ip1)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_D__As_D_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_D_D__As_F_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_D_Dld__As_Dld_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, long, double) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], <long>(<long*>ip1)[0], <double>(<double*>ip2)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_dD__As_dD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double complex) noexcept nogil>func)(<double>(<double*>ip0)[0], <double complex>(<double complex*>ip1)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_dD__As_fF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double complex) noexcept nogil>func)(<double>(<float*>ip0)[0], <double complex>(<float complex*>ip1)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_ddD__As_ddD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double complex) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double complex>(<double complex*>ip2)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_ddD__As_ffF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double complex) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double complex>(<float complex*>ip2)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddD__As_dddD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double complex) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double complex>(<double complex*>ip3)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddD__As_fffF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double complex) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double complex>(<float complex*>ip3)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddd__As_dddd_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddd__As_ffff_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_iidd__As_lldd_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        if <int>(<long*>ip0)[0] == (<long*>ip0)[0] and <int>(<long*>ip1)[0] == (<long*>ip1)[0]:
            ov0 = (<double complex(*)(int, int, double, double) noexcept nogil>func)(<int>(<long*>ip0)[0], <int>(<long*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double complex>NAN
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_lD__As_lD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(long, double complex) noexcept nogil>func)(<long>(<long*>ip0)[0], <double complex>(<double complex*>ip1)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_d__As_d_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double) noexcept nogil>func)(<double>(<double*>ip0)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_d_d__As_f_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double) noexcept nogil>func)(<double>(<float*>ip0)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_d_dd__As_dd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_dd__As_ff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddd__As_ddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddd__As_fff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd__As_dddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd__As_ffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd_d_As_dddd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef char *op1 = args[5]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0], &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
        op1 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd_d_As_ffff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef char *op1 = args[5]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0], &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
        op1 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddddddd__As_ddddddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0], <double>(<double*>ip4)[0], <double>(<double*>ip5)[0], <double>(<double*>ip6)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddddddd__As_fffffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double, double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0], <double>(<float*>ip4)[0], <double>(<float*>ip5)[0], <double>(<float*>ip6)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddi_d_As_ddl_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef char *op1 = args[4]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        if <int>(<long*>ip2)[0] == (<long*>ip2)[0]:
            ov0 = (<double(*)(double, double, int, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <int>(<long*>ip2)[0], &ov1)
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NAN
            ov1 = <double>NAN
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
        op1 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddiiddd__As_ddllddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        if <int>(<long*>ip2)[0] == (<long*>ip2)[0] and <int>(<long*>ip3)[0] == (<long*>ip3)[0]:
            ov0 = (<double(*)(double, double, int, int, double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <int>(<long*>ip2)[0], <int>(<long*>ip3)[0], <double>(<double*>ip4)[0], <double>(<double*>ip5)[0], <double>(<double*>ip6)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NAN
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_did__As_dld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        if <int>(<long*>ip1)[0] == (<long*>ip1)[0]:
            ov0 = (<double(*)(double, int, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <int>(<long*>ip1)[0], <double>(<double*>ip2)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NAN
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_id__As_ld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        if <int>(<long*>ip0)[0] == (<long*>ip0)[0]:
            ov0 = (<double(*)(int, double) noexcept nogil>func)(<int>(<long*>ip0)[0], <double>(<double*>ip1)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NAN
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_iid__As_lld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        if <int>(<long*>ip0)[0] == (<long*>ip0)[0] and <int>(<long*>ip1)[0] == (<long*>ip1)[0]:
            ov0 = (<double(*)(int, int, double) noexcept nogil>func)(<int>(<long*>ip0)[0], <int>(<long*>ip1)[0], <double>(<double*>ip2)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NAN
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_ld__As_ld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(long, double) noexcept nogil>func)(<long>(<long*>ip0)[0], <double>(<double*>ip1)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_ldd__As_ldd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(long, double, double) noexcept nogil>func)(<long>(<long*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_lddd__As_lddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(long, double, double, double) noexcept nogil>func)(<long>(<long*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_f_f__As_f_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float) noexcept nogil>func)(<float>(<float*>ip0)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_f_ff__As_ff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float, float) noexcept nogil>func)(<float>(<float*>ip0)[0], <float>(<float*>ip1)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_f_fff__As_fff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float, float, float) noexcept nogil>func)(<float>(<float*>ip0)[0], <float>(<float*>ip1)[0], <float>(<float*>ip2)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_g_g__As_g_g(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef long double ov0
    for i in range(n):
        ov0 = (<long double(*)(long double) noexcept nogil>func)(<long double>(<long double*>ip0)[0])
        (<long double *>op0)[0] = <long double>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DDDD_As_D_DDDD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double complex ov0
    cdef double complex ov1
    cdef double complex ov2
    cdef double complex ov3
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *, double complex *, double complex *) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<double complex *>op0)[0] = <double complex>ov0
        (<double complex *>op1)[0] = <double complex>ov1
        (<double complex *>op2)[0] = <double complex>ov2
        (<double complex *>op3)[0] = <double complex>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DDDD_As_F_FFFF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double complex ov0
    cdef double complex ov1
    cdef double complex ov2
    cdef double complex ov3
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *, double complex *, double complex *) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<float complex *>op0)[0] = <float complex>ov0
        (<float complex *>op1)[0] = <float complex>ov1
        (<float complex *>op2)[0] = <float complex>ov2
        (<float complex *>op3)[0] = <float complex>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DD_As_D_DD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], &ov0, &ov1)
        (<double complex *>op0)[0] = <double complex>ov0
        (<double complex *>op1)[0] = <double complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DD_As_F_FF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], &ov0, &ov1)
        (<float complex *>op0)[0] = <float complex>ov0
        (<float complex *>op1)[0] = <float complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_DDDD_As_d_DDDD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double complex ov0
    cdef double complex ov1
    cdef double complex ov2
    cdef double complex ov3
    for i in range(n):
        (<int(*)(double, double complex *, double complex *, double complex *, double complex *) noexcept nogil>func)(<double>(<double*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<double complex *>op0)[0] = <double complex>ov0
        (<double complex *>op1)[0] = <double complex>ov1
        (<double complex *>op2)[0] = <double complex>ov2
        (<double complex *>op3)[0] = <double complex>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_DDDD_As_f_FFFF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double complex ov0
    cdef double complex ov1
    cdef double complex ov2
    cdef double complex ov3
    for i in range(n):
        (<int(*)(double, double complex *, double complex *, double complex *, double complex *) noexcept nogil>func)(<double>(<float*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<float complex *>op0)[0] = <float complex>ov0
        (<float complex *>op1)[0] = <float complex>ov1
        (<float complex *>op2)[0] = <float complex>ov2
        (<float complex *>op3)[0] = <float complex>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_DD_As_d_DD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double, double complex *, double complex *) noexcept nogil>func)(<double>(<double*>ip0)[0], &ov0, &ov1)
        (<double complex *>op0)[0] = <double complex>ov0
        (<double complex *>op1)[0] = <double complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_DD_As_f_FF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double, double complex *, double complex *) noexcept nogil>func)(<double>(<float*>ip0)[0], &ov0, &ov1)
        (<float complex *>op0)[0] = <float complex>ov0
        (<float complex *>op1)[0] = <float complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dd_As_d_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], &ov0, &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dd_As_f_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], &ov0, &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dddd_As_d_dddd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double ov0
    cdef double ov1
    cdef double ov2
    cdef double ov3
    for i in range(n):
        (<int(*)(double, double *, double *, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        (<double *>op2)[0] = <double>ov2
        (<double *>op3)[0] = <double>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dddd_As_f_ffff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double ov0
    cdef double ov1
    cdef double ov2
    cdef double ov3
    for i in range(n):
        (<int(*)(double, double *, double *, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        (<float *>op2)[0] = <float>ov2
        (<float *>op3)[0] = <float>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_dd_dd_As_dd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef char *op1 = args[3]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], &ov0, &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
        op1 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_i_dd_dd_As_ff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef char *op1 = args[3]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], &ov0, &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
        op1 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_i_dd_dddd_As_dd_dddd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef char *op1 = args[3]
    cdef char *op2 = args[4]
    cdef char *op3 = args[5]
    cdef double ov0
    cdef double ov1
    cdef double ov2
    cdef double ov3
    for i in range(n):
        (<int(*)(double, double, double *, double *, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], &ov0, &ov1, &ov2, &ov3)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        (<double *>op2)[0] = <double>ov2
        (<double *>op3)[0] = <double>ov3
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
        op1 += steps[3]
        op2 += steps[4]
        op3 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_i_dd_dddd_As_ff_ffff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef char *op1 = args[3]
    cdef char *op2 = args[4]
    cdef char *op3 = args[5]
    cdef double ov0
    cdef double ov1
    cdef double ov2
    cdef double ov3
    for i in range(n):
        (<int(*)(double, double, double *, double *, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], &ov0, &ov1, &ov2, &ov3)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        (<float *>op2)[0] = <float>ov2
        (<float *>op3)[0] = <float>ov3
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
        op1 += steps[3]
        op2 += steps[4]
        op3 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_i_ddd_dd_As_ddd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef char *op1 = args[4]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], &ov0, &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
        op1 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_ddd_dd_As_fff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef char *op1 = args[4]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], &ov0, &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
        op1 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_ddddd_dd_As_ddddd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *op0 = args[5]
    cdef char *op1 = args[6]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double, double, double, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0], <double>(<double*>ip4)[0], &ov0, &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        op0 += steps[5]
        op1 += steps[6]
    sf_error.check_fpe(func_name)

cdef void loop_i_ddddd_dd_As_fffff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *op0 = args[5]
    cdef char *op1 = args[6]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double, double, double, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0], <double>(<float*>ip4)[0], &ov0, &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        op0 += steps[5]
        op1 += steps[6]
    sf_error.check_fpe(func_name)

cdef void loop_i_i__As_l_l(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef int ov0
    for i in range(n):
        if <int>(<long*>ip0)[0] == (<long*>ip0)[0]:
            ov0 = (<int(*)(int) noexcept nogil>func)(<int>(<long*>ip0)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <int>0xbad0bad0
        (<long *>op0)[0] = <long>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cosine_cdf "cosine_cdf"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cosine_invcdf "cosine_invcdf"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cospi "cospi"(double) noexcept nogil
from ._trig cimport ccospi as _func_ccospi
ctypedef double complex _proto_ccospi_t(double complex) noexcept nogil
cdef _proto_ccospi_t *_proto_ccospi_t_var = &_func_ccospi
from ._ellip_harm cimport ellip_harmonic as _func_ellip_harmonic
ctypedef double _proto_ellip_harmonic_t(double, double, int, int, double, double, double) noexcept nogil
cdef _proto_ellip_harmonic_t *_proto_ellip_harmonic_t_var = &_func_ellip_harmonic
from ._legacy cimport ellip_harmonic_unsafe as _func_ellip_harmonic_unsafe
ctypedef double _proto_ellip_harmonic_unsafe_t(double, double, double, double, double, double, double) noexcept nogil
cdef _proto_ellip_harmonic_unsafe_t *_proto_ellip_harmonic_unsafe_t_var = &_func_ellip_harmonic_unsafe
from ._factorial cimport _factorial as _func__factorial
ctypedef double _proto__factorial_t(double) noexcept nogil
cdef _proto__factorial_t *_proto__factorial_t_var = &_func__factorial
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_igam_fac "igam_fac"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_kolmogc "kolmogc"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_kolmogci "kolmogci"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_kolmogp "kolmogp"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_lanczos_sum_expg_scaled "lanczos_sum_expg_scaled"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_lgam1p "lgam1p"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_log1pmx "log1pmx"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_riemann_zeta "riemann_zeta"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_scaled_exp1 "scaled_exp1"(double) noexcept nogil
from .sf_error cimport _sf_error_test_function as _func__sf_error_test_function
ctypedef int _proto__sf_error_test_function_t(int) noexcept nogil
cdef _proto__sf_error_test_function_t *_proto__sf_error_test_function_t_var = &_func__sf_error_test_function
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_sinpi "sinpi"(double) noexcept nogil
from ._trig cimport csinpi as _func_csinpi
ctypedef double complex _proto_csinpi_t(double complex) noexcept nogil
cdef _proto_csinpi_t *_proto_csinpi_t_var = &_func_csinpi
from ._legacy cimport smirnovc_unsafe as _func_smirnovc_unsafe
ctypedef double _proto_smirnovc_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovc_unsafe_t *_proto_smirnovc_unsafe_t_var = &_func_smirnovc_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_smirnovc "smirnovc"(int, double) noexcept nogil
from ._legacy cimport smirnovci_unsafe as _func_smirnovci_unsafe
ctypedef double _proto_smirnovci_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovci_unsafe_t *_proto_smirnovci_unsafe_t_var = &_func_smirnovci_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_smirnovci "smirnovci"(int, double) noexcept nogil
from ._legacy cimport smirnovp_unsafe as _func_smirnovp_unsafe
ctypedef double _proto_smirnovp_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovp_unsafe_t *_proto_smirnovp_unsafe_t_var = &_func_smirnovp_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_smirnovp "smirnovp"(int, double) noexcept nogil
from ._spherical_bessel cimport spherical_in_complex as _func_spherical_in_complex
ctypedef double complex _proto_spherical_in_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_in_complex_t *_proto_spherical_in_complex_t_var = &_func_spherical_in_complex
from ._spherical_bessel cimport spherical_in_real as _func_spherical_in_real
ctypedef double _proto_spherical_in_real_t(long, double) noexcept nogil
cdef _proto_spherical_in_real_t *_proto_spherical_in_real_t_var = &_func_spherical_in_real
from ._spherical_bessel cimport spherical_in_d_complex as _func_spherical_in_d_complex
ctypedef double complex _proto_spherical_in_d_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_in_d_complex_t *_proto_spherical_in_d_complex_t_var = &_func_spherical_in_d_complex
from ._spherical_bessel cimport spherical_in_d_real as _func_spherical_in_d_real
ctypedef double _proto_spherical_in_d_real_t(long, double) noexcept nogil
cdef _proto_spherical_in_d_real_t *_proto_spherical_in_d_real_t_var = &_func_spherical_in_d_real
from ._spherical_bessel cimport spherical_jn_complex as _func_spherical_jn_complex
ctypedef double complex _proto_spherical_jn_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_jn_complex_t *_proto_spherical_jn_complex_t_var = &_func_spherical_jn_complex
from ._spherical_bessel cimport spherical_jn_real as _func_spherical_jn_real
ctypedef double _proto_spherical_jn_real_t(long, double) noexcept nogil
cdef _proto_spherical_jn_real_t *_proto_spherical_jn_real_t_var = &_func_spherical_jn_real
from ._spherical_bessel cimport spherical_jn_d_complex as _func_spherical_jn_d_complex
ctypedef double complex _proto_spherical_jn_d_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_jn_d_complex_t *_proto_spherical_jn_d_complex_t_var = &_func_spherical_jn_d_complex
from ._spherical_bessel cimport spherical_jn_d_real as _func_spherical_jn_d_real
ctypedef double _proto_spherical_jn_d_real_t(long, double) noexcept nogil
cdef _proto_spherical_jn_d_real_t *_proto_spherical_jn_d_real_t_var = &_func_spherical_jn_d_real
from ._spherical_bessel cimport spherical_kn_complex as _func_spherical_kn_complex
ctypedef double complex _proto_spherical_kn_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_kn_complex_t *_proto_spherical_kn_complex_t_var = &_func_spherical_kn_complex
from ._spherical_bessel cimport spherical_kn_real as _func_spherical_kn_real
ctypedef double _proto_spherical_kn_real_t(long, double) noexcept nogil
cdef _proto_spherical_kn_real_t *_proto_spherical_kn_real_t_var = &_func_spherical_kn_real
from ._spherical_bessel cimport spherical_kn_d_complex as _func_spherical_kn_d_complex
ctypedef double complex _proto_spherical_kn_d_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_kn_d_complex_t *_proto_spherical_kn_d_complex_t_var = &_func_spherical_kn_d_complex
from ._spherical_bessel cimport spherical_kn_d_real as _func_spherical_kn_d_real
ctypedef double _proto_spherical_kn_d_real_t(long, double) noexcept nogil
cdef _proto_spherical_kn_d_real_t *_proto_spherical_kn_d_real_t_var = &_func_spherical_kn_d_real
from ._spherical_bessel cimport spherical_yn_complex as _func_spherical_yn_complex
ctypedef double complex _proto_spherical_yn_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_yn_complex_t *_proto_spherical_yn_complex_t_var = &_func_spherical_yn_complex
from ._spherical_bessel cimport spherical_yn_real as _func_spherical_yn_real
ctypedef double _proto_spherical_yn_real_t(long, double) noexcept nogil
cdef _proto_spherical_yn_real_t *_proto_spherical_yn_real_t_var = &_func_spherical_yn_real
from ._spherical_bessel cimport spherical_yn_d_complex as _func_spherical_yn_d_complex
ctypedef double complex _proto_spherical_yn_d_complex_t(long, double complex) noexcept nogil
cdef _proto_spherical_yn_d_complex_t *_proto_spherical_yn_d_complex_t_var = &_func_spherical_yn_d_complex
from ._spherical_bessel cimport spherical_yn_d_real as _func_spherical_yn_d_real
ctypedef double _proto_spherical_yn_d_real_t(long, double) noexcept nogil
cdef _proto_spherical_yn_d_real_t *_proto_spherical_yn_d_real_t_var = &_func_spherical_yn_d_real
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_struve_asymp_large_z "struve_asymp_large_z"(double, double, int, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_struve_bessel_series "struve_bessel_series"(double, double, int, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_struve_power_series "struve_power_series"(double, double, int, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_zeta "zeta"(double, double) noexcept nogil
from ._agm cimport agm as _func_agm
ctypedef double _proto_agm_t(double, double) noexcept nogil
cdef _proto_agm_t *_proto_agm_t_var = &_func_agm
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_airy_wrap "airy_wrap"(double, double *, double *, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cairy_wrap "cairy_wrap"(double complex, double complex *, double complex *, double complex *, double complex *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cairy_wrap_e "cairy_wrap_e"(double complex, double complex *, double complex *, double complex *, double complex *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cairy_wrap_e_real "cairy_wrap_e_real"(double, double *, double *, double *, double *) noexcept nogil
from ._legacy cimport bdtr_unsafe as _func_bdtr_unsafe
ctypedef double _proto_bdtr_unsafe_t(double, double, double) noexcept nogil
cdef _proto_bdtr_unsafe_t *_proto_bdtr_unsafe_t_var = &_func_bdtr_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_bdtr "bdtr"(double, int, double) noexcept nogil
from ._legacy cimport bdtrc_unsafe as _func_bdtrc_unsafe
ctypedef double _proto_bdtrc_unsafe_t(double, double, double) noexcept nogil
cdef _proto_bdtrc_unsafe_t *_proto_bdtrc_unsafe_t_var = &_func_bdtrc_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_bdtrc "bdtrc"(double, int, double) noexcept nogil
from ._legacy cimport bdtri_unsafe as _func_bdtri_unsafe
ctypedef double _proto_bdtri_unsafe_t(double, double, double) noexcept nogil
cdef _proto_bdtri_unsafe_t *_proto_bdtri_unsafe_t_var = &_func_bdtri_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_bdtri "bdtri"(double, int, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfbin2_wrap "cdfbin2_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfbin3_wrap "cdfbin3_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_bei_wrap "bei_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_beip_wrap "beip_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ber_wrap "ber_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_berp_wrap "berp_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_besselpoly "besselpoly"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_beta "beta"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_lbeta "lbeta"(double, double) noexcept nogil
from ._boxcox cimport boxcox as _func_boxcox
ctypedef double _proto_boxcox_t(double, double) noexcept nogil
cdef _proto_boxcox_t *_proto_boxcox_t_var = &_func_boxcox
from ._boxcox cimport boxcox1p as _func_boxcox1p
ctypedef double _proto_boxcox1p_t(double, double) noexcept nogil
cdef _proto_boxcox1p_t *_proto_boxcox1p_t_var = &_func_boxcox1p
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_btdtr "btdtr"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_incbi "incbi"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfbet3_wrap "cdfbet3_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfbet4_wrap "cdfbet4_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbrt "cbrt"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_chdtr "chdtr"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_chdtrc "chdtrc"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_chdtri "chdtri"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfchi3_wrap "cdfchi3_wrap"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfchn1_wrap "cdfchn1_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfchn3_wrap "cdfchn3_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfchn4_wrap "cdfchn4_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfchn2_wrap "cdfchn2_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cosdg "cosdg"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cosm1 "cosm1"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cotdg "cotdg"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ellpe "ellpe"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ellie "ellie"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_ellpj "ellpj"(double, double, double *, double *, double *, double *) noexcept nogil
from ._ellipk cimport ellipk as _func_ellipk
ctypedef double _proto_ellipk_t(double) noexcept nogil
cdef _proto_ellipk_t *_proto_ellipk_t_var = &_func_ellipk
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ellik "ellik"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ellpk "ellpk"(double) noexcept nogil
from ._convex_analysis cimport entr as _func_entr
ctypedef double _proto_entr_t(double) noexcept nogil
cdef _proto_entr_t *_proto_entr_t_var = &_func_entr
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_erf "erf"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_erfc "erfc"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_erfcinv "erfcinv"(double) noexcept nogil
from .orthogonal_eval cimport eval_chebyc as _func_eval_chebyc
ctypedef double complex _proto_eval_chebyc_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebyc_double_complex__t *_proto_eval_chebyc_double_complex__t_var = &_func_eval_chebyc[double_complex]
from .orthogonal_eval cimport eval_chebyc as _func_eval_chebyc
ctypedef double _proto_eval_chebyc_double__t(double, double) noexcept nogil
cdef _proto_eval_chebyc_double__t *_proto_eval_chebyc_double__t_var = &_func_eval_chebyc[double]
from .orthogonal_eval cimport eval_chebyc_l as _func_eval_chebyc_l
ctypedef double _proto_eval_chebyc_l_t(long, double) noexcept nogil
cdef _proto_eval_chebyc_l_t *_proto_eval_chebyc_l_t_var = &_func_eval_chebyc_l
from .orthogonal_eval cimport eval_chebys as _func_eval_chebys
ctypedef double complex _proto_eval_chebys_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebys_double_complex__t *_proto_eval_chebys_double_complex__t_var = &_func_eval_chebys[double_complex]
from .orthogonal_eval cimport eval_chebys as _func_eval_chebys
ctypedef double _proto_eval_chebys_double__t(double, double) noexcept nogil
cdef _proto_eval_chebys_double__t *_proto_eval_chebys_double__t_var = &_func_eval_chebys[double]
from .orthogonal_eval cimport eval_chebys_l as _func_eval_chebys_l
ctypedef double _proto_eval_chebys_l_t(long, double) noexcept nogil
cdef _proto_eval_chebys_l_t *_proto_eval_chebys_l_t_var = &_func_eval_chebys_l
from .orthogonal_eval cimport eval_chebyt as _func_eval_chebyt
ctypedef double complex _proto_eval_chebyt_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebyt_double_complex__t *_proto_eval_chebyt_double_complex__t_var = &_func_eval_chebyt[double_complex]
from .orthogonal_eval cimport eval_chebyt as _func_eval_chebyt
ctypedef double _proto_eval_chebyt_double__t(double, double) noexcept nogil
cdef _proto_eval_chebyt_double__t *_proto_eval_chebyt_double__t_var = &_func_eval_chebyt[double]
from .orthogonal_eval cimport eval_chebyt_l as _func_eval_chebyt_l
ctypedef double _proto_eval_chebyt_l_t(long, double) noexcept nogil
cdef _proto_eval_chebyt_l_t *_proto_eval_chebyt_l_t_var = &_func_eval_chebyt_l
from .orthogonal_eval cimport eval_chebyu as _func_eval_chebyu
ctypedef double complex _proto_eval_chebyu_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebyu_double_complex__t *_proto_eval_chebyu_double_complex__t_var = &_func_eval_chebyu[double_complex]
from .orthogonal_eval cimport eval_chebyu as _func_eval_chebyu
ctypedef double _proto_eval_chebyu_double__t(double, double) noexcept nogil
cdef _proto_eval_chebyu_double__t *_proto_eval_chebyu_double__t_var = &_func_eval_chebyu[double]
from .orthogonal_eval cimport eval_chebyu_l as _func_eval_chebyu_l
ctypedef double _proto_eval_chebyu_l_t(long, double) noexcept nogil
cdef _proto_eval_chebyu_l_t *_proto_eval_chebyu_l_t_var = &_func_eval_chebyu_l
from .orthogonal_eval cimport eval_gegenbauer as _func_eval_gegenbauer
ctypedef double complex _proto_eval_gegenbauer_double_complex__t(double, double, double complex) noexcept nogil
cdef _proto_eval_gegenbauer_double_complex__t *_proto_eval_gegenbauer_double_complex__t_var = &_func_eval_gegenbauer[double_complex]
from .orthogonal_eval cimport eval_gegenbauer as _func_eval_gegenbauer
ctypedef double _proto_eval_gegenbauer_double__t(double, double, double) noexcept nogil
cdef _proto_eval_gegenbauer_double__t *_proto_eval_gegenbauer_double__t_var = &_func_eval_gegenbauer[double]
from .orthogonal_eval cimport eval_gegenbauer_l as _func_eval_gegenbauer_l
ctypedef double _proto_eval_gegenbauer_l_t(long, double, double) noexcept nogil
cdef _proto_eval_gegenbauer_l_t *_proto_eval_gegenbauer_l_t_var = &_func_eval_gegenbauer_l
from .orthogonal_eval cimport eval_genlaguerre as _func_eval_genlaguerre
ctypedef double complex _proto_eval_genlaguerre_double_complex__t(double, double, double complex) noexcept nogil
cdef _proto_eval_genlaguerre_double_complex__t *_proto_eval_genlaguerre_double_complex__t_var = &_func_eval_genlaguerre[double_complex]
from .orthogonal_eval cimport eval_genlaguerre as _func_eval_genlaguerre
ctypedef double _proto_eval_genlaguerre_double__t(double, double, double) noexcept nogil
cdef _proto_eval_genlaguerre_double__t *_proto_eval_genlaguerre_double__t_var = &_func_eval_genlaguerre[double]
from .orthogonal_eval cimport eval_genlaguerre_l as _func_eval_genlaguerre_l
ctypedef double _proto_eval_genlaguerre_l_t(long, double, double) noexcept nogil
cdef _proto_eval_genlaguerre_l_t *_proto_eval_genlaguerre_l_t_var = &_func_eval_genlaguerre_l
from .orthogonal_eval cimport eval_hermite as _func_eval_hermite
ctypedef double _proto_eval_hermite_t(long, double) noexcept nogil
cdef _proto_eval_hermite_t *_proto_eval_hermite_t_var = &_func_eval_hermite
from .orthogonal_eval cimport eval_hermitenorm as _func_eval_hermitenorm
ctypedef double _proto_eval_hermitenorm_t(long, double) noexcept nogil
cdef _proto_eval_hermitenorm_t *_proto_eval_hermitenorm_t_var = &_func_eval_hermitenorm
from .orthogonal_eval cimport eval_jacobi as _func_eval_jacobi
ctypedef double complex _proto_eval_jacobi_double_complex__t(double, double, double, double complex) noexcept nogil
cdef _proto_eval_jacobi_double_complex__t *_proto_eval_jacobi_double_complex__t_var = &_func_eval_jacobi[double_complex]
from .orthogonal_eval cimport eval_jacobi as _func_eval_jacobi
ctypedef double _proto_eval_jacobi_double__t(double, double, double, double) noexcept nogil
cdef _proto_eval_jacobi_double__t *_proto_eval_jacobi_double__t_var = &_func_eval_jacobi[double]
from .orthogonal_eval cimport eval_jacobi_l as _func_eval_jacobi_l
ctypedef double _proto_eval_jacobi_l_t(long, double, double, double) noexcept nogil
cdef _proto_eval_jacobi_l_t *_proto_eval_jacobi_l_t_var = &_func_eval_jacobi_l
from .orthogonal_eval cimport eval_laguerre as _func_eval_laguerre
ctypedef double complex _proto_eval_laguerre_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_laguerre_double_complex__t *_proto_eval_laguerre_double_complex__t_var = &_func_eval_laguerre[double_complex]
from .orthogonal_eval cimport eval_laguerre as _func_eval_laguerre
ctypedef double _proto_eval_laguerre_double__t(double, double) noexcept nogil
cdef _proto_eval_laguerre_double__t *_proto_eval_laguerre_double__t_var = &_func_eval_laguerre[double]
from .orthogonal_eval cimport eval_laguerre_l as _func_eval_laguerre_l
ctypedef double _proto_eval_laguerre_l_t(long, double) noexcept nogil
cdef _proto_eval_laguerre_l_t *_proto_eval_laguerre_l_t_var = &_func_eval_laguerre_l
from .orthogonal_eval cimport eval_legendre as _func_eval_legendre
ctypedef double complex _proto_eval_legendre_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_legendre_double_complex__t *_proto_eval_legendre_double_complex__t_var = &_func_eval_legendre[double_complex]
from .orthogonal_eval cimport eval_legendre as _func_eval_legendre
ctypedef double _proto_eval_legendre_double__t(double, double) noexcept nogil
cdef _proto_eval_legendre_double__t *_proto_eval_legendre_double__t_var = &_func_eval_legendre[double]
from .orthogonal_eval cimport eval_legendre_l as _func_eval_legendre_l
ctypedef double _proto_eval_legendre_l_t(long, double) noexcept nogil
cdef _proto_eval_legendre_l_t *_proto_eval_legendre_l_t_var = &_func_eval_legendre_l
from .orthogonal_eval cimport eval_sh_chebyt as _func_eval_sh_chebyt
ctypedef double complex _proto_eval_sh_chebyt_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_sh_chebyt_double_complex__t *_proto_eval_sh_chebyt_double_complex__t_var = &_func_eval_sh_chebyt[double_complex]
from .orthogonal_eval cimport eval_sh_chebyt as _func_eval_sh_chebyt
ctypedef double _proto_eval_sh_chebyt_double__t(double, double) noexcept nogil
cdef _proto_eval_sh_chebyt_double__t *_proto_eval_sh_chebyt_double__t_var = &_func_eval_sh_chebyt[double]
from .orthogonal_eval cimport eval_sh_chebyt_l as _func_eval_sh_chebyt_l
ctypedef double _proto_eval_sh_chebyt_l_t(long, double) noexcept nogil
cdef _proto_eval_sh_chebyt_l_t *_proto_eval_sh_chebyt_l_t_var = &_func_eval_sh_chebyt_l
from .orthogonal_eval cimport eval_sh_chebyu as _func_eval_sh_chebyu
ctypedef double complex _proto_eval_sh_chebyu_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_sh_chebyu_double_complex__t *_proto_eval_sh_chebyu_double_complex__t_var = &_func_eval_sh_chebyu[double_complex]
from .orthogonal_eval cimport eval_sh_chebyu as _func_eval_sh_chebyu
ctypedef double _proto_eval_sh_chebyu_double__t(double, double) noexcept nogil
cdef _proto_eval_sh_chebyu_double__t *_proto_eval_sh_chebyu_double__t_var = &_func_eval_sh_chebyu[double]
from .orthogonal_eval cimport eval_sh_chebyu_l as _func_eval_sh_chebyu_l
ctypedef double _proto_eval_sh_chebyu_l_t(long, double) noexcept nogil
cdef _proto_eval_sh_chebyu_l_t *_proto_eval_sh_chebyu_l_t_var = &_func_eval_sh_chebyu_l
from .orthogonal_eval cimport eval_sh_jacobi as _func_eval_sh_jacobi
ctypedef double complex _proto_eval_sh_jacobi_double_complex__t(double, double, double, double complex) noexcept nogil
cdef _proto_eval_sh_jacobi_double_complex__t *_proto_eval_sh_jacobi_double_complex__t_var = &_func_eval_sh_jacobi[double_complex]
from .orthogonal_eval cimport eval_sh_jacobi as _func_eval_sh_jacobi
ctypedef double _proto_eval_sh_jacobi_double__t(double, double, double, double) noexcept nogil
cdef _proto_eval_sh_jacobi_double__t *_proto_eval_sh_jacobi_double__t_var = &_func_eval_sh_jacobi[double]
from .orthogonal_eval cimport eval_sh_jacobi_l as _func_eval_sh_jacobi_l
ctypedef double _proto_eval_sh_jacobi_l_t(long, double, double, double) noexcept nogil
cdef _proto_eval_sh_jacobi_l_t *_proto_eval_sh_jacobi_l_t_var = &_func_eval_sh_jacobi_l
from .orthogonal_eval cimport eval_sh_legendre as _func_eval_sh_legendre
ctypedef double complex _proto_eval_sh_legendre_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_sh_legendre_double_complex__t *_proto_eval_sh_legendre_double_complex__t_var = &_func_eval_sh_legendre[double_complex]
from .orthogonal_eval cimport eval_sh_legendre as _func_eval_sh_legendre
ctypedef double _proto_eval_sh_legendre_double__t(double, double) noexcept nogil
cdef _proto_eval_sh_legendre_double__t *_proto_eval_sh_legendre_double__t_var = &_func_eval_sh_legendre[double]
from .orthogonal_eval cimport eval_sh_legendre_l as _func_eval_sh_legendre_l
ctypedef double _proto_eval_sh_legendre_l_t(long, double) noexcept nogil
cdef _proto_eval_sh_legendre_l_t *_proto_eval_sh_legendre_l_t_var = &_func_eval_sh_legendre_l
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cexp1_wrap "cexp1_wrap"(double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_exp1_wrap "exp1_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_exp10 "exp10"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_exp2 "exp2"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cexpi_wrap "cexpi_wrap"(double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_expi_wrap "expi_wrap"(double) noexcept nogil
from ._cunity cimport cexpm1 as _func_cexpm1
ctypedef double complex _proto_cexpm1_t(double complex) noexcept nogil
cdef _proto_cexpm1_t *_proto_cexpm1_t_var = &_func_cexpm1
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_expm1 "expm1"(double) noexcept nogil
from ._legacy cimport expn_unsafe as _func_expn_unsafe
ctypedef double _proto_expn_unsafe_t(double, double) noexcept nogil
cdef _proto_expn_unsafe_t *_proto_expn_unsafe_t_var = &_func_expn_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_expn "expn"(int, double) noexcept nogil
from ._exprel cimport exprel as _func_exprel
ctypedef double _proto_exprel_t(double) noexcept nogil
cdef _proto_exprel_t *_proto_exprel_t_var = &_func_exprel
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_fdtr "fdtr"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_fdtrc "fdtrc"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_fdtri "fdtri"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdff4_wrap "cdff4_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_fresnl "fresnl"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cfresnl_wrap "cfresnl_wrap"(double complex, double complex *, double complex *) noexcept nogil
from ._loggamma cimport cgamma as _func_cgamma
ctypedef double complex _proto_cgamma_t(double complex) noexcept nogil
cdef _proto_cgamma_t *_proto_cgamma_t_var = &_func_cgamma
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_Gamma "Gamma"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_igam "igam"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_igamc "igamc"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_igamci "igamci"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_igami "igami"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_lgam "lgam"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_gammasgn "gammasgn"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_gdtr "gdtr"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_gdtrc "gdtrc"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfgam4_wrap "cdfgam4_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfgam3_wrap "cdfgam3_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfgam2_wrap "cdfgam2_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesh_wrap1 "cbesh_wrap1"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesh_wrap1_e "cbesh_wrap1_e"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesh_wrap2 "cbesh_wrap2"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesh_wrap2_e "cbesh_wrap2_e"(double, double complex) noexcept nogil
from ._convex_analysis cimport huber as _func_huber
ctypedef double _proto_huber_t(double, double) noexcept nogil
cdef _proto_huber_t *_proto_huber_t_var = &_func_huber
from ._hyp0f1 cimport _hyp0f1_cmplx as _func__hyp0f1_cmplx
ctypedef double complex _proto__hyp0f1_cmplx_t(double, double complex) noexcept nogil
cdef _proto__hyp0f1_cmplx_t *_proto__hyp0f1_cmplx_t_var = &_func__hyp0f1_cmplx
from ._hyp0f1 cimport _hyp0f1_real as _func__hyp0f1_real
ctypedef double _proto__hyp0f1_real_t(double, double) noexcept nogil
cdef _proto__hyp0f1_real_t *_proto__hyp0f1_real_t_var = &_func__hyp0f1_real
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_chyp1f1_wrap "chyp1f1_wrap"(double, double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_hyp2f1 "hyp2f1"(double, double, double, double) noexcept nogil
from ._hyp2f1 cimport hyp2f1_complex as _func_hyp2f1_complex
ctypedef double complex _proto_hyp2f1_complex_t(double, double, double, double complex) noexcept nogil
cdef _proto_hyp2f1_complex_t *_proto_hyp2f1_complex_t_var = &_func_hyp2f1_complex
from ._hypergeometric cimport hyperu as _func_hyperu
ctypedef double _proto_hyperu_t(double, double, double) noexcept nogil
cdef _proto_hyperu_t *_proto_hyperu_t_var = &_func_hyperu
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_i0 "i0"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_i0e "i0e"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_i1 "i1"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_i1e "i1e"(double) noexcept nogil
from ._boxcox cimport inv_boxcox as _func_inv_boxcox
ctypedef double _proto_inv_boxcox_t(double, double) noexcept nogil
cdef _proto_inv_boxcox_t *_proto_inv_boxcox_t_var = &_func_inv_boxcox
from ._boxcox cimport inv_boxcox1p as _func_inv_boxcox1p
ctypedef double _proto_inv_boxcox1p_t(double, double) noexcept nogil
cdef _proto_inv_boxcox1p_t *_proto_inv_boxcox1p_t_var = &_func_inv_boxcox1p
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_it2i0k0_wrap "it2i0k0_wrap"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_it2j0y0_wrap "it2j0y0_wrap"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_it2struve0_wrap "it2struve0_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_itairy_wrap "itairy_wrap"(double, double *, double *, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_it1i0k0_wrap "it1i0k0_wrap"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_it1j0y0_wrap "it1j0y0_wrap"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_itmodstruve0_wrap "itmodstruve0_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_itstruve0_wrap "itstruve0_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesi_wrap "cbesi_wrap"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_iv "iv"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesi_wrap_e "cbesi_wrap_e"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesi_wrap_e_real "cbesi_wrap_e_real"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_j0 "j0"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_j1 "j1"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesj_wrap "cbesj_wrap"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesj_wrap_real "cbesj_wrap_real"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesj_wrap_e "cbesj_wrap_e"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesj_wrap_e_real "cbesj_wrap_e_real"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_k0 "k0"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_k0e "k0e"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_k1 "k1"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_k1e "k1e"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_kei_wrap "kei_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_keip_wrap "keip_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_kelvin_wrap "kelvin_wrap"(double, double complex *, double complex *, double complex *, double complex *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ker_wrap "ker_wrap"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_kerp_wrap "kerp_wrap"(double) noexcept nogil
from ._convex_analysis cimport kl_div as _func_kl_div
ctypedef double _proto_kl_div_t(double, double) noexcept nogil
cdef _proto_kl_div_t *_proto_kl_div_t_var = &_func_kl_div
from ._legacy cimport kn_unsafe as _func_kn_unsafe
ctypedef double _proto_kn_unsafe_t(double, double) noexcept nogil
cdef _proto_kn_unsafe_t *_proto_kn_unsafe_t_var = &_func_kn_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesk_wrap_real_int "cbesk_wrap_real_int"(int, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_kolmogi "kolmogi"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_kolmogorov "kolmogorov"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesk_wrap "cbesk_wrap"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesk_wrap_real "cbesk_wrap_real"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesk_wrap_e "cbesk_wrap_e"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesk_wrap_e_real "cbesk_wrap_e_real"(double, double) noexcept nogil
from ._cunity cimport clog1p as _func_clog1p
ctypedef double complex _proto_clog1p_t(double complex) noexcept nogil
cdef _proto_clog1p_t *_proto_clog1p_t_var = &_func_clog1p
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_log1p "log1p"(double) noexcept nogil
from ._loggamma cimport loggamma_real as _func_loggamma_real
ctypedef double _proto_loggamma_real_t(double) noexcept nogil
cdef _proto_loggamma_real_t *_proto_loggamma_real_t_var = &_func_loggamma_real
from ._loggamma cimport loggamma as _func_loggamma
ctypedef double complex _proto_loggamma_t(double complex) noexcept nogil
cdef _proto_loggamma_t *_proto_loggamma_t_var = &_func_loggamma
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_pmv_wrap "pmv_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cem_cva_wrap "cem_cva_wrap"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_sem_cva_wrap "sem_cva_wrap"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cem_wrap "cem_wrap"(double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_mcm1_wrap "mcm1_wrap"(double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_mcm2_wrap "mcm2_wrap"(double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_msm1_wrap "msm1_wrap"(double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_msm2_wrap "msm2_wrap"(double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_sem_wrap "sem_wrap"(double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_modified_fresnel_minus_wrap "modified_fresnel_minus_wrap"(double, double complex *, double complex *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_modified_fresnel_plus_wrap "modified_fresnel_plus_wrap"(double, double complex *, double complex *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_struve_l "struve_l"(double, double) noexcept nogil
from ._legacy cimport nbdtr_unsafe as _func_nbdtr_unsafe
ctypedef double _proto_nbdtr_unsafe_t(double, double, double) noexcept nogil
cdef _proto_nbdtr_unsafe_t *_proto_nbdtr_unsafe_t_var = &_func_nbdtr_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_nbdtr "nbdtr"(int, int, double) noexcept nogil
from ._legacy cimport nbdtrc_unsafe as _func_nbdtrc_unsafe
ctypedef double _proto_nbdtrc_unsafe_t(double, double, double) noexcept nogil
cdef _proto_nbdtrc_unsafe_t *_proto_nbdtrc_unsafe_t_var = &_func_nbdtrc_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_nbdtrc "nbdtrc"(int, int, double) noexcept nogil
from ._legacy cimport nbdtri_unsafe as _func_nbdtri_unsafe
ctypedef double _proto_nbdtri_unsafe_t(double, double, double) noexcept nogil
cdef _proto_nbdtri_unsafe_t *_proto_nbdtri_unsafe_t_var = &_func_nbdtri_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_nbdtri "nbdtri"(int, int, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfnbn2_wrap "cdfnbn2_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfnbn3_wrap "cdfnbn3_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdffnc1_wrap "cdffnc1_wrap"(double, double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdffnc2_wrap "cdffnc2_wrap"(double, double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdffnc4_wrap "cdffnc4_wrap"(double, double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdffnc3_wrap "cdffnc3_wrap"(double, double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdffnc5_wrap "cdffnc5_wrap"(double, double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdftnc1_wrap "cdftnc1_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdftnc3_wrap "cdftnc3_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdftnc4_wrap "cdftnc4_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdftnc2_wrap "cdftnc2_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ndtr "ndtr"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_ndtri "ndtri"(double) noexcept nogil
from ._ndtri_exp cimport ndtri_exp as _func_ndtri_exp
ctypedef double _proto_ndtri_exp_t(double) noexcept nogil
cdef _proto_ndtri_exp_t *_proto_ndtri_exp_t_var = &_func_ndtri_exp
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfnor3_wrap "cdfnor3_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfnor4_wrap "cdfnor4_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_oblate_aswfa_nocv_wrap "oblate_aswfa_nocv_wrap"(double, double, double, double, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_oblate_aswfa_wrap "oblate_aswfa_wrap"(double, double, double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_oblate_segv_wrap "oblate_segv_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_oblate_radial1_nocv_wrap "oblate_radial1_nocv_wrap"(double, double, double, double, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_oblate_radial1_wrap "oblate_radial1_wrap"(double, double, double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_oblate_radial2_nocv_wrap "oblate_radial2_nocv_wrap"(double, double, double, double, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_oblate_radial2_wrap "oblate_radial2_wrap"(double, double, double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_owens_t "owens_t"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_pbdv_wrap "pbdv_wrap"(double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_pbvv_wrap "pbvv_wrap"(double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_pbwa_wrap "pbwa_wrap"(double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_pdtr "pdtr"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_pdtrc "pdtrc"(double, double) noexcept nogil
from ._legacy cimport pdtri_unsafe as _func_pdtri_unsafe
ctypedef double _proto_pdtri_unsafe_t(double, double) noexcept nogil
cdef _proto_pdtri_unsafe_t *_proto_pdtri_unsafe_t_var = &_func_pdtri_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_pdtri "pdtri"(int, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdfpoi2_wrap "cdfpoi2_wrap"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_poch "poch"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_prolate_aswfa_nocv_wrap "prolate_aswfa_nocv_wrap"(double, double, double, double, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_prolate_aswfa_wrap "prolate_aswfa_wrap"(double, double, double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_prolate_segv_wrap "prolate_segv_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_prolate_radial1_nocv_wrap "prolate_radial1_nocv_wrap"(double, double, double, double, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_prolate_radial1_wrap "prolate_radial1_wrap"(double, double, double, double, double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_prolate_radial2_nocv_wrap "prolate_radial2_nocv_wrap"(double, double, double, double, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_prolate_radial2_wrap "prolate_radial2_wrap"(double, double, double, double, double, double *, double *) noexcept nogil
from ._convex_analysis cimport pseudo_huber as _func_pseudo_huber
ctypedef double _proto_pseudo_huber_t(double, double) noexcept nogil
cdef _proto_pseudo_huber_t *_proto_pseudo_huber_t_var = &_func_pseudo_huber
from ._digamma cimport cdigamma as _func_cdigamma
ctypedef double complex _proto_cdigamma_t(double complex) noexcept nogil
cdef _proto_cdigamma_t *_proto_cdigamma_t_var = &_func_cdigamma
from ._digamma cimport digamma as _func_digamma
ctypedef double _proto_digamma_t(double) noexcept nogil
cdef _proto_digamma_t *_proto_digamma_t_var = &_func_digamma
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_radian "radian"(double, double, double) noexcept nogil
from ._convex_analysis cimport rel_entr as _func_rel_entr
ctypedef double _proto_rel_entr_t(double, double) noexcept nogil
cdef _proto_rel_entr_t *_proto_rel_entr_t_var = &_func_rel_entr
from ._loggamma cimport crgamma as _func_crgamma
ctypedef double complex _proto_crgamma_t(double complex) noexcept nogil
cdef _proto_crgamma_t *_proto_crgamma_t_var = &_func_crgamma
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_rgamma "rgamma"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_round "round"(double) noexcept nogil
from ._sici cimport cshichi as _func_cshichi
ctypedef int _proto_cshichi_t(double complex, double complex *, double complex *) noexcept nogil
cdef _proto_cshichi_t *_proto_cshichi_t_var = &_func_cshichi
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_shichi "shichi"(double, double *, double *) noexcept nogil
from ._sici cimport csici as _func_csici
ctypedef int _proto_csici_t(double complex, double complex *, double complex *) noexcept nogil
cdef _proto_csici_t *_proto_csici_t_var = &_func_csici
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_sici "sici"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_sindg "sindg"(double) noexcept nogil
from ._legacy cimport smirnov_unsafe as _func_smirnov_unsafe
ctypedef double _proto_smirnov_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnov_unsafe_t *_proto_smirnov_unsafe_t_var = &_func_smirnov_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_smirnov "smirnov"(int, double) noexcept nogil
from ._legacy cimport smirnovi_unsafe as _func_smirnovi_unsafe
ctypedef double _proto_smirnovi_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovi_unsafe_t *_proto_smirnovi_unsafe_t_var = &_func_smirnovi_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_smirnovi "smirnovi"(int, double) noexcept nogil
from ._spence cimport cspence as _func_cspence
ctypedef double complex _proto_cspence_t(double complex) noexcept nogil
cdef _proto_cspence_t *_proto_cspence_t_var = &_func_cspence
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_spence "spence"(double) noexcept nogil
from ._legacy cimport sph_harmonic_unsafe as _func_sph_harmonic_unsafe
ctypedef double complex _proto_sph_harmonic_unsafe_t(double, double, double, double) noexcept nogil
cdef _proto_sph_harmonic_unsafe_t *_proto_sph_harmonic_unsafe_t_var = &_func_sph_harmonic_unsafe
from .sph_harm cimport sph_harmonic as _func_sph_harmonic
ctypedef double complex _proto_sph_harmonic_t(int, int, double, double) noexcept nogil
cdef _proto_sph_harmonic_t *_proto_sph_harmonic_t_var = &_func_sph_harmonic
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdft1_wrap "cdft1_wrap"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdft3_wrap "cdft3_wrap"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cdft2_wrap "cdft2_wrap"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_struve_h "struve_h"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_tandg "tandg"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_tukeylambdacdf "tukeylambdacdf"(double, double) noexcept nogil
from ._wright_bessel cimport wright_bessel_scalar as _func_wright_bessel_scalar
ctypedef double _proto_wright_bessel_scalar_t(double, double, double) noexcept nogil
cdef _proto_wright_bessel_scalar_t *_proto_wright_bessel_scalar_t_var = &_func_wright_bessel_scalar
from ._xlogy cimport xlog1py as _func_xlog1py
ctypedef double _proto_xlog1py_double__t(double, double) noexcept nogil
cdef _proto_xlog1py_double__t *_proto_xlog1py_double__t_var = &_func_xlog1py[double]
from ._xlogy cimport xlog1py as _func_xlog1py
ctypedef double complex _proto_xlog1py_double_complex__t(double complex, double complex) noexcept nogil
cdef _proto_xlog1py_double_complex__t *_proto_xlog1py_double_complex__t_var = &_func_xlog1py[double_complex]
from ._xlogy cimport xlogy as _func_xlogy
ctypedef double _proto_xlogy_double__t(double, double) noexcept nogil
cdef _proto_xlogy_double__t *_proto_xlogy_double__t_var = &_func_xlogy[double]
from ._xlogy cimport xlogy as _func_xlogy
ctypedef double complex _proto_xlogy_double_complex__t(double complex, double complex) noexcept nogil
cdef _proto_xlogy_double_complex__t *_proto_xlogy_double_complex__t_var = &_func_xlogy[double_complex]
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_y0 "y0"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_y1 "y1"(double) noexcept nogil
from ._legacy cimport yn_unsafe as _func_yn_unsafe
ctypedef double _proto_yn_unsafe_t(double, double) noexcept nogil
cdef _proto_yn_unsafe_t *_proto_yn_unsafe_t_var = &_func_yn_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_yn "yn"(int, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesy_wrap "cbesy_wrap"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesy_wrap_real "cbesy_wrap_real"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_cbesy_wrap_e "cbesy_wrap_e"(double, double complex) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cbesy_wrap_e_real "cbesy_wrap_e_real"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_zetac "zetac"(double) noexcept nogil
cdef np.PyUFuncGenericFunction ufunc__cosine_cdf_loops[2]
cdef void *ufunc__cosine_cdf_ptr[4]
cdef void *ufunc__cosine_cdf_data[2]
cdef char ufunc__cosine_cdf_types[4]
cdef char *ufunc__cosine_cdf_doc = (
    "_cosine_cdf(x)\n"
    "\n"
    "Cumulative distribution function (CDF) of the cosine distribution::\n"
    "\n"
    "             {             0,              x < -pi\n"
    "    cdf(x) = { (pi + x + sin(x))/(2*pi),   -pi <= x <= pi\n"
    "             {             1,              x > pi\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    `x` must contain real numbers.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The cosine distribution CDF evaluated at `x`.")
ufunc__cosine_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__cosine_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__cosine_cdf_types[0] = <char>NPY_FLOAT
ufunc__cosine_cdf_types[1] = <char>NPY_FLOAT
ufunc__cosine_cdf_types[2] = <char>NPY_DOUBLE
ufunc__cosine_cdf_types[3] = <char>NPY_DOUBLE
ufunc__cosine_cdf_ptr[2*0] = <void*>_func_cosine_cdf
ufunc__cosine_cdf_ptr[2*0+1] = <void*>(<char*>"_cosine_cdf")
ufunc__cosine_cdf_ptr[2*1] = <void*>_func_cosine_cdf
ufunc__cosine_cdf_ptr[2*1+1] = <void*>(<char*>"_cosine_cdf")
ufunc__cosine_cdf_data[0] = &ufunc__cosine_cdf_ptr[2*0]
ufunc__cosine_cdf_data[1] = &ufunc__cosine_cdf_ptr[2*1]
_cosine_cdf = np.PyUFunc_FromFuncAndData(ufunc__cosine_cdf_loops, ufunc__cosine_cdf_data, ufunc__cosine_cdf_types, 2, 1, 1, 0, "_cosine_cdf", ufunc__cosine_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__cosine_invcdf_loops[2]
cdef void *ufunc__cosine_invcdf_ptr[4]
cdef void *ufunc__cosine_invcdf_data[2]
cdef char ufunc__cosine_invcdf_types[4]
cdef char *ufunc__cosine_invcdf_doc = (
    "_cosine_invcdf(p)\n"
    "\n"
    "Inverse of the cumulative distribution function (CDF) of the cosine\n"
    "distribution.\n"
    "\n"
    "The CDF of the cosine distribution is::\n"
    "\n"
    "    cdf(x) = (pi + x + sin(x))/(2*pi)\n"
    "\n"
    "This function computes the inverse of cdf(x).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    `p` must contain real numbers in the interval ``0 <= p <= 1``.\n"
    "    `nan` is returned for values of `p` outside the interval [0, 1].\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The inverse of the cosine distribution CDF evaluated at `p`.")
ufunc__cosine_invcdf_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__cosine_invcdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__cosine_invcdf_types[0] = <char>NPY_FLOAT
ufunc__cosine_invcdf_types[1] = <char>NPY_FLOAT
ufunc__cosine_invcdf_types[2] = <char>NPY_DOUBLE
ufunc__cosine_invcdf_types[3] = <char>NPY_DOUBLE
ufunc__cosine_invcdf_ptr[2*0] = <void*>_func_cosine_invcdf
ufunc__cosine_invcdf_ptr[2*0+1] = <void*>(<char*>"_cosine_invcdf")
ufunc__cosine_invcdf_ptr[2*1] = <void*>_func_cosine_invcdf
ufunc__cosine_invcdf_ptr[2*1+1] = <void*>(<char*>"_cosine_invcdf")
ufunc__cosine_invcdf_data[0] = &ufunc__cosine_invcdf_ptr[2*0]
ufunc__cosine_invcdf_data[1] = &ufunc__cosine_invcdf_ptr[2*1]
_cosine_invcdf = np.PyUFunc_FromFuncAndData(ufunc__cosine_invcdf_loops, ufunc__cosine_invcdf_data, ufunc__cosine_invcdf_types, 2, 1, 1, 0, "_cosine_invcdf", ufunc__cosine_invcdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__cospi_loops[4]
cdef void *ufunc__cospi_ptr[8]
cdef void *ufunc__cospi_data[4]
cdef char ufunc__cospi_types[8]
cdef char *ufunc__cospi_doc = (
    "Internal function, do not use.")
ufunc__cospi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__cospi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__cospi_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc__cospi_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc__cospi_types[0] = <char>NPY_FLOAT
ufunc__cospi_types[1] = <char>NPY_FLOAT
ufunc__cospi_types[2] = <char>NPY_DOUBLE
ufunc__cospi_types[3] = <char>NPY_DOUBLE
ufunc__cospi_types[4] = <char>NPY_CFLOAT
ufunc__cospi_types[5] = <char>NPY_CFLOAT
ufunc__cospi_types[6] = <char>NPY_CDOUBLE
ufunc__cospi_types[7] = <char>NPY_CDOUBLE
ufunc__cospi_ptr[2*0] = <void*>_func_cospi
ufunc__cospi_ptr[2*0+1] = <void*>(<char*>"_cospi")
ufunc__cospi_ptr[2*1] = <void*>_func_cospi
ufunc__cospi_ptr[2*1+1] = <void*>(<char*>"_cospi")
ufunc__cospi_ptr[2*2] = <void*>_func_ccospi
ufunc__cospi_ptr[2*2+1] = <void*>(<char*>"_cospi")
ufunc__cospi_ptr[2*3] = <void*>_func_ccospi
ufunc__cospi_ptr[2*3+1] = <void*>(<char*>"_cospi")
ufunc__cospi_data[0] = &ufunc__cospi_ptr[2*0]
ufunc__cospi_data[1] = &ufunc__cospi_ptr[2*1]
ufunc__cospi_data[2] = &ufunc__cospi_ptr[2*2]
ufunc__cospi_data[3] = &ufunc__cospi_ptr[2*3]
_cospi = np.PyUFunc_FromFuncAndData(ufunc__cospi_loops, ufunc__cospi_data, ufunc__cospi_types, 4, 1, 1, 0, "_cospi", ufunc__cospi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ellip_harm_loops[3]
cdef void *ufunc__ellip_harm_ptr[6]
cdef void *ufunc__ellip_harm_data[3]
cdef char ufunc__ellip_harm_types[24]
cdef char *ufunc__ellip_harm_doc = (
    "Internal function, use `ellip_harm` instead.")
ufunc__ellip_harm_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddddddd__As_fffffff_f
ufunc__ellip_harm_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddiiddd__As_ddllddd_d
ufunc__ellip_harm_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddddddd__As_ddddddd_d
ufunc__ellip_harm_types[0] = <char>NPY_FLOAT
ufunc__ellip_harm_types[1] = <char>NPY_FLOAT
ufunc__ellip_harm_types[2] = <char>NPY_FLOAT
ufunc__ellip_harm_types[3] = <char>NPY_FLOAT
ufunc__ellip_harm_types[4] = <char>NPY_FLOAT
ufunc__ellip_harm_types[5] = <char>NPY_FLOAT
ufunc__ellip_harm_types[6] = <char>NPY_FLOAT
ufunc__ellip_harm_types[7] = <char>NPY_FLOAT
ufunc__ellip_harm_types[8] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[9] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[10] = <char>NPY_LONG
ufunc__ellip_harm_types[11] = <char>NPY_LONG
ufunc__ellip_harm_types[12] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[13] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[14] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[15] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[16] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[17] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[18] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[19] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[20] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[21] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[22] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[23] = <char>NPY_DOUBLE
ufunc__ellip_harm_ptr[2*0] = <void*>_func_ellip_harmonic_unsafe
ufunc__ellip_harm_ptr[2*0+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_ptr[2*1] = <void*>_func_ellip_harmonic
ufunc__ellip_harm_ptr[2*1+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_ptr[2*2] = <void*>_func_ellip_harmonic_unsafe
ufunc__ellip_harm_ptr[2*2+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_data[0] = &ufunc__ellip_harm_ptr[2*0]
ufunc__ellip_harm_data[1] = &ufunc__ellip_harm_ptr[2*1]
ufunc__ellip_harm_data[2] = &ufunc__ellip_harm_ptr[2*2]
_ellip_harm = np.PyUFunc_FromFuncAndData(ufunc__ellip_harm_loops, ufunc__ellip_harm_data, ufunc__ellip_harm_types, 3, 7, 1, 0, "_ellip_harm", ufunc__ellip_harm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__factorial_loops[2]
cdef void *ufunc__factorial_ptr[4]
cdef void *ufunc__factorial_data[2]
cdef char ufunc__factorial_types[4]
cdef char *ufunc__factorial_doc = (
    "Internal function, do not use.")
ufunc__factorial_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__factorial_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__factorial_types[0] = <char>NPY_FLOAT
ufunc__factorial_types[1] = <char>NPY_FLOAT
ufunc__factorial_types[2] = <char>NPY_DOUBLE
ufunc__factorial_types[3] = <char>NPY_DOUBLE
ufunc__factorial_ptr[2*0] = <void*>_func__factorial
ufunc__factorial_ptr[2*0+1] = <void*>(<char*>"_factorial")
ufunc__factorial_ptr[2*1] = <void*>_func__factorial
ufunc__factorial_ptr[2*1+1] = <void*>(<char*>"_factorial")
ufunc__factorial_data[0] = &ufunc__factorial_ptr[2*0]
ufunc__factorial_data[1] = &ufunc__factorial_ptr[2*1]
_factorial = np.PyUFunc_FromFuncAndData(ufunc__factorial_loops, ufunc__factorial_data, ufunc__factorial_types, 2, 1, 1, 0, "_factorial", ufunc__factorial_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__igam_fac_loops[2]
cdef void *ufunc__igam_fac_ptr[4]
cdef void *ufunc__igam_fac_data[2]
cdef char ufunc__igam_fac_types[6]
cdef char *ufunc__igam_fac_doc = (
    "Internal function, do not use.")
ufunc__igam_fac_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__igam_fac_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__igam_fac_types[0] = <char>NPY_FLOAT
ufunc__igam_fac_types[1] = <char>NPY_FLOAT
ufunc__igam_fac_types[2] = <char>NPY_FLOAT
ufunc__igam_fac_types[3] = <char>NPY_DOUBLE
ufunc__igam_fac_types[4] = <char>NPY_DOUBLE
ufunc__igam_fac_types[5] = <char>NPY_DOUBLE
ufunc__igam_fac_ptr[2*0] = <void*>_func_igam_fac
ufunc__igam_fac_ptr[2*0+1] = <void*>(<char*>"_igam_fac")
ufunc__igam_fac_ptr[2*1] = <void*>_func_igam_fac
ufunc__igam_fac_ptr[2*1+1] = <void*>(<char*>"_igam_fac")
ufunc__igam_fac_data[0] = &ufunc__igam_fac_ptr[2*0]
ufunc__igam_fac_data[1] = &ufunc__igam_fac_ptr[2*1]
_igam_fac = np.PyUFunc_FromFuncAndData(ufunc__igam_fac_loops, ufunc__igam_fac_data, ufunc__igam_fac_types, 2, 2, 1, 0, "_igam_fac", ufunc__igam_fac_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__kolmogc_loops[2]
cdef void *ufunc__kolmogc_ptr[4]
cdef void *ufunc__kolmogc_data[2]
cdef char ufunc__kolmogc_types[4]
cdef char *ufunc__kolmogc_doc = (
    "Internal function, do not use.")
ufunc__kolmogc_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__kolmogc_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__kolmogc_types[0] = <char>NPY_FLOAT
ufunc__kolmogc_types[1] = <char>NPY_FLOAT
ufunc__kolmogc_types[2] = <char>NPY_DOUBLE
ufunc__kolmogc_types[3] = <char>NPY_DOUBLE
ufunc__kolmogc_ptr[2*0] = <void*>_func_kolmogc
ufunc__kolmogc_ptr[2*0+1] = <void*>(<char*>"_kolmogc")
ufunc__kolmogc_ptr[2*1] = <void*>_func_kolmogc
ufunc__kolmogc_ptr[2*1+1] = <void*>(<char*>"_kolmogc")
ufunc__kolmogc_data[0] = &ufunc__kolmogc_ptr[2*0]
ufunc__kolmogc_data[1] = &ufunc__kolmogc_ptr[2*1]
_kolmogc = np.PyUFunc_FromFuncAndData(ufunc__kolmogc_loops, ufunc__kolmogc_data, ufunc__kolmogc_types, 2, 1, 1, 0, "_kolmogc", ufunc__kolmogc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__kolmogci_loops[2]
cdef void *ufunc__kolmogci_ptr[4]
cdef void *ufunc__kolmogci_data[2]
cdef char ufunc__kolmogci_types[4]
cdef char *ufunc__kolmogci_doc = (
    "Internal function, do not use.")
ufunc__kolmogci_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__kolmogci_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__kolmogci_types[0] = <char>NPY_FLOAT
ufunc__kolmogci_types[1] = <char>NPY_FLOAT
ufunc__kolmogci_types[2] = <char>NPY_DOUBLE
ufunc__kolmogci_types[3] = <char>NPY_DOUBLE
ufunc__kolmogci_ptr[2*0] = <void*>_func_kolmogci
ufunc__kolmogci_ptr[2*0+1] = <void*>(<char*>"_kolmogci")
ufunc__kolmogci_ptr[2*1] = <void*>_func_kolmogci
ufunc__kolmogci_ptr[2*1+1] = <void*>(<char*>"_kolmogci")
ufunc__kolmogci_data[0] = &ufunc__kolmogci_ptr[2*0]
ufunc__kolmogci_data[1] = &ufunc__kolmogci_ptr[2*1]
_kolmogci = np.PyUFunc_FromFuncAndData(ufunc__kolmogci_loops, ufunc__kolmogci_data, ufunc__kolmogci_types, 2, 1, 1, 0, "_kolmogci", ufunc__kolmogci_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__kolmogp_loops[2]
cdef void *ufunc__kolmogp_ptr[4]
cdef void *ufunc__kolmogp_data[2]
cdef char ufunc__kolmogp_types[4]
cdef char *ufunc__kolmogp_doc = (
    "Internal function, do not use.")
ufunc__kolmogp_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__kolmogp_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__kolmogp_types[0] = <char>NPY_FLOAT
ufunc__kolmogp_types[1] = <char>NPY_FLOAT
ufunc__kolmogp_types[2] = <char>NPY_DOUBLE
ufunc__kolmogp_types[3] = <char>NPY_DOUBLE
ufunc__kolmogp_ptr[2*0] = <void*>_func_kolmogp
ufunc__kolmogp_ptr[2*0+1] = <void*>(<char*>"_kolmogp")
ufunc__kolmogp_ptr[2*1] = <void*>_func_kolmogp
ufunc__kolmogp_ptr[2*1+1] = <void*>(<char*>"_kolmogp")
ufunc__kolmogp_data[0] = &ufunc__kolmogp_ptr[2*0]
ufunc__kolmogp_data[1] = &ufunc__kolmogp_ptr[2*1]
_kolmogp = np.PyUFunc_FromFuncAndData(ufunc__kolmogp_loops, ufunc__kolmogp_data, ufunc__kolmogp_types, 2, 1, 1, 0, "_kolmogp", ufunc__kolmogp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__lambertw_loops[1]
cdef void *ufunc__lambertw_ptr[2]
cdef void *ufunc__lambertw_data[1]
cdef char ufunc__lambertw_types[4]
cdef char *ufunc__lambertw_doc = (
    "Internal function, use `lambertw` instead.")
ufunc__lambertw_loops[0] = <np.PyUFuncGenericFunction>loop_D_Dld__As_Dld_D
ufunc__lambertw_types[0] = <char>NPY_CDOUBLE
ufunc__lambertw_types[1] = <char>NPY_LONG
ufunc__lambertw_types[2] = <char>NPY_DOUBLE
ufunc__lambertw_types[3] = <char>NPY_CDOUBLE
ufunc__lambertw_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_lambertw_scalar
ufunc__lambertw_ptr[2*0+1] = <void*>(<char*>"_lambertw")
ufunc__lambertw_data[0] = &ufunc__lambertw_ptr[2*0]
_lambertw = np.PyUFunc_FromFuncAndData(ufunc__lambertw_loops, ufunc__lambertw_data, ufunc__lambertw_types, 1, 3, 1, 0, "_lambertw", ufunc__lambertw_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__lanczos_sum_expg_scaled_loops[2]
cdef void *ufunc__lanczos_sum_expg_scaled_ptr[4]
cdef void *ufunc__lanczos_sum_expg_scaled_data[2]
cdef char ufunc__lanczos_sum_expg_scaled_types[4]
cdef char *ufunc__lanczos_sum_expg_scaled_doc = (
    "Internal function, do not use.")
ufunc__lanczos_sum_expg_scaled_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__lanczos_sum_expg_scaled_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__lanczos_sum_expg_scaled_types[0] = <char>NPY_FLOAT
ufunc__lanczos_sum_expg_scaled_types[1] = <char>NPY_FLOAT
ufunc__lanczos_sum_expg_scaled_types[2] = <char>NPY_DOUBLE
ufunc__lanczos_sum_expg_scaled_types[3] = <char>NPY_DOUBLE
ufunc__lanczos_sum_expg_scaled_ptr[2*0] = <void*>_func_lanczos_sum_expg_scaled
ufunc__lanczos_sum_expg_scaled_ptr[2*0+1] = <void*>(<char*>"_lanczos_sum_expg_scaled")
ufunc__lanczos_sum_expg_scaled_ptr[2*1] = <void*>_func_lanczos_sum_expg_scaled
ufunc__lanczos_sum_expg_scaled_ptr[2*1+1] = <void*>(<char*>"_lanczos_sum_expg_scaled")
ufunc__lanczos_sum_expg_scaled_data[0] = &ufunc__lanczos_sum_expg_scaled_ptr[2*0]
ufunc__lanczos_sum_expg_scaled_data[1] = &ufunc__lanczos_sum_expg_scaled_ptr[2*1]
_lanczos_sum_expg_scaled = np.PyUFunc_FromFuncAndData(ufunc__lanczos_sum_expg_scaled_loops, ufunc__lanczos_sum_expg_scaled_data, ufunc__lanczos_sum_expg_scaled_types, 2, 1, 1, 0, "_lanczos_sum_expg_scaled", ufunc__lanczos_sum_expg_scaled_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__lgam1p_loops[2]
cdef void *ufunc__lgam1p_ptr[4]
cdef void *ufunc__lgam1p_data[2]
cdef char ufunc__lgam1p_types[4]
cdef char *ufunc__lgam1p_doc = (
    "Internal function, do not use.")
ufunc__lgam1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__lgam1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__lgam1p_types[0] = <char>NPY_FLOAT
ufunc__lgam1p_types[1] = <char>NPY_FLOAT
ufunc__lgam1p_types[2] = <char>NPY_DOUBLE
ufunc__lgam1p_types[3] = <char>NPY_DOUBLE
ufunc__lgam1p_ptr[2*0] = <void*>_func_lgam1p
ufunc__lgam1p_ptr[2*0+1] = <void*>(<char*>"_lgam1p")
ufunc__lgam1p_ptr[2*1] = <void*>_func_lgam1p
ufunc__lgam1p_ptr[2*1+1] = <void*>(<char*>"_lgam1p")
ufunc__lgam1p_data[0] = &ufunc__lgam1p_ptr[2*0]
ufunc__lgam1p_data[1] = &ufunc__lgam1p_ptr[2*1]
_lgam1p = np.PyUFunc_FromFuncAndData(ufunc__lgam1p_loops, ufunc__lgam1p_data, ufunc__lgam1p_types, 2, 1, 1, 0, "_lgam1p", ufunc__lgam1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__log1pmx_loops[2]
cdef void *ufunc__log1pmx_ptr[4]
cdef void *ufunc__log1pmx_data[2]
cdef char ufunc__log1pmx_types[4]
cdef char *ufunc__log1pmx_doc = (
    "Internal function, do not use.")
ufunc__log1pmx_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__log1pmx_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__log1pmx_types[0] = <char>NPY_FLOAT
ufunc__log1pmx_types[1] = <char>NPY_FLOAT
ufunc__log1pmx_types[2] = <char>NPY_DOUBLE
ufunc__log1pmx_types[3] = <char>NPY_DOUBLE
ufunc__log1pmx_ptr[2*0] = <void*>_func_log1pmx
ufunc__log1pmx_ptr[2*0+1] = <void*>(<char*>"_log1pmx")
ufunc__log1pmx_ptr[2*1] = <void*>_func_log1pmx
ufunc__log1pmx_ptr[2*1+1] = <void*>(<char*>"_log1pmx")
ufunc__log1pmx_data[0] = &ufunc__log1pmx_ptr[2*0]
ufunc__log1pmx_data[1] = &ufunc__log1pmx_ptr[2*1]
_log1pmx = np.PyUFunc_FromFuncAndData(ufunc__log1pmx_loops, ufunc__log1pmx_data, ufunc__log1pmx_types, 2, 1, 1, 0, "_log1pmx", ufunc__log1pmx_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__riemann_zeta_loops[2]
cdef void *ufunc__riemann_zeta_ptr[4]
cdef void *ufunc__riemann_zeta_data[2]
cdef char ufunc__riemann_zeta_types[4]
cdef char *ufunc__riemann_zeta_doc = (
    "Internal function, use `zeta` instead.")
ufunc__riemann_zeta_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__riemann_zeta_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__riemann_zeta_types[0] = <char>NPY_FLOAT
ufunc__riemann_zeta_types[1] = <char>NPY_FLOAT
ufunc__riemann_zeta_types[2] = <char>NPY_DOUBLE
ufunc__riemann_zeta_types[3] = <char>NPY_DOUBLE
ufunc__riemann_zeta_ptr[2*0] = <void*>_func_riemann_zeta
ufunc__riemann_zeta_ptr[2*0+1] = <void*>(<char*>"_riemann_zeta")
ufunc__riemann_zeta_ptr[2*1] = <void*>_func_riemann_zeta
ufunc__riemann_zeta_ptr[2*1+1] = <void*>(<char*>"_riemann_zeta")
ufunc__riemann_zeta_data[0] = &ufunc__riemann_zeta_ptr[2*0]
ufunc__riemann_zeta_data[1] = &ufunc__riemann_zeta_ptr[2*1]
_riemann_zeta = np.PyUFunc_FromFuncAndData(ufunc__riemann_zeta_loops, ufunc__riemann_zeta_data, ufunc__riemann_zeta_types, 2, 1, 1, 0, "_riemann_zeta", ufunc__riemann_zeta_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__scaled_exp1_loops[2]
cdef void *ufunc__scaled_exp1_ptr[4]
cdef void *ufunc__scaled_exp1_data[2]
cdef char ufunc__scaled_exp1_types[4]
cdef char *ufunc__scaled_exp1_doc = (
    "_scaled_exp1(x, out=None):\n"
    "\n"
    "Compute the scaled exponential integral.\n"
    "\n"
    "This is a private function, subject to change or removal with no\n"
    "deprecation.\n"
    "\n"
    "This function computes F(x), where F is the factor remaining in E_1(x)\n"
    "when exp(-x)/x is factored out.  That is,::\n"
    "\n"
    "    E_1(x) = exp(-x)/x * F(x)\n"
    "\n"
    "or\n"
    "\n"
    "    F(x) = x * exp(x) * E_1(x)\n"
    "\n"
    "The function is defined for real x >= 0.  For x < 0, nan is returned.\n"
    "\n"
    "F has the properties:\n"
    "\n"
    "* F(0) = 0\n"
    "* F(x) is increasing on [0, inf).\n"
    "* The limit as x goes to infinity of F(x) is 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x: array_like\n"
    "    The input values. Must be real.  The implementation is limited to\n"
    "    double precision floating point, so other types will be cast to\n"
    "    to double precision.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the scaled exponential integral.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "exp1 : exponential integral E_1\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import _scaled_exp1\n"
    ">>> _scaled_exp1([0, 0.1, 1, 10, 100])")
ufunc__scaled_exp1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__scaled_exp1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__scaled_exp1_types[0] = <char>NPY_FLOAT
ufunc__scaled_exp1_types[1] = <char>NPY_FLOAT
ufunc__scaled_exp1_types[2] = <char>NPY_DOUBLE
ufunc__scaled_exp1_types[3] = <char>NPY_DOUBLE
ufunc__scaled_exp1_ptr[2*0] = <void*>_func_scaled_exp1
ufunc__scaled_exp1_ptr[2*0+1] = <void*>(<char*>"_scaled_exp1")
ufunc__scaled_exp1_ptr[2*1] = <void*>_func_scaled_exp1
ufunc__scaled_exp1_ptr[2*1+1] = <void*>(<char*>"_scaled_exp1")
ufunc__scaled_exp1_data[0] = &ufunc__scaled_exp1_ptr[2*0]
ufunc__scaled_exp1_data[1] = &ufunc__scaled_exp1_ptr[2*1]
_scaled_exp1 = np.PyUFunc_FromFuncAndData(ufunc__scaled_exp1_loops, ufunc__scaled_exp1_data, ufunc__scaled_exp1_types, 2, 1, 1, 0, "_scaled_exp1", ufunc__scaled_exp1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__sf_error_test_function_loops[1]
cdef void *ufunc__sf_error_test_function_ptr[2]
cdef void *ufunc__sf_error_test_function_data[1]
cdef char ufunc__sf_error_test_function_types[2]
cdef char *ufunc__sf_error_test_function_doc = (
    "Private function; do not use.")
ufunc__sf_error_test_function_loops[0] = <np.PyUFuncGenericFunction>loop_i_i__As_l_l
ufunc__sf_error_test_function_types[0] = <char>NPY_LONG
ufunc__sf_error_test_function_types[1] = <char>NPY_LONG
ufunc__sf_error_test_function_ptr[2*0] = <void*>_func__sf_error_test_function
ufunc__sf_error_test_function_ptr[2*0+1] = <void*>(<char*>"_sf_error_test_function")
ufunc__sf_error_test_function_data[0] = &ufunc__sf_error_test_function_ptr[2*0]
_sf_error_test_function = np.PyUFunc_FromFuncAndData(ufunc__sf_error_test_function_loops, ufunc__sf_error_test_function_data, ufunc__sf_error_test_function_types, 1, 1, 1, 0, "_sf_error_test_function", ufunc__sf_error_test_function_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__sinpi_loops[4]
cdef void *ufunc__sinpi_ptr[8]
cdef void *ufunc__sinpi_data[4]
cdef char ufunc__sinpi_types[8]
cdef char *ufunc__sinpi_doc = (
    "Internal function, do not use.")
ufunc__sinpi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__sinpi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__sinpi_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc__sinpi_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc__sinpi_types[0] = <char>NPY_FLOAT
ufunc__sinpi_types[1] = <char>NPY_FLOAT
ufunc__sinpi_types[2] = <char>NPY_DOUBLE
ufunc__sinpi_types[3] = <char>NPY_DOUBLE
ufunc__sinpi_types[4] = <char>NPY_CFLOAT
ufunc__sinpi_types[5] = <char>NPY_CFLOAT
ufunc__sinpi_types[6] = <char>NPY_CDOUBLE
ufunc__sinpi_types[7] = <char>NPY_CDOUBLE
ufunc__sinpi_ptr[2*0] = <void*>_func_sinpi
ufunc__sinpi_ptr[2*0+1] = <void*>(<char*>"_sinpi")
ufunc__sinpi_ptr[2*1] = <void*>_func_sinpi
ufunc__sinpi_ptr[2*1+1] = <void*>(<char*>"_sinpi")
ufunc__sinpi_ptr[2*2] = <void*>_func_csinpi
ufunc__sinpi_ptr[2*2+1] = <void*>(<char*>"_sinpi")
ufunc__sinpi_ptr[2*3] = <void*>_func_csinpi
ufunc__sinpi_ptr[2*3+1] = <void*>(<char*>"_sinpi")
ufunc__sinpi_data[0] = &ufunc__sinpi_ptr[2*0]
ufunc__sinpi_data[1] = &ufunc__sinpi_ptr[2*1]
ufunc__sinpi_data[2] = &ufunc__sinpi_ptr[2*2]
ufunc__sinpi_data[3] = &ufunc__sinpi_ptr[2*3]
_sinpi = np.PyUFunc_FromFuncAndData(ufunc__sinpi_loops, ufunc__sinpi_data, ufunc__sinpi_types, 4, 1, 1, 0, "_sinpi", ufunc__sinpi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__smirnovc_loops[3]
cdef void *ufunc__smirnovc_ptr[6]
cdef void *ufunc__smirnovc_data[3]
cdef char ufunc__smirnovc_types[9]
cdef char *ufunc__smirnovc_doc = (
    "_smirnovc(n, d)\n"
    " Internal function, do not use.")
ufunc__smirnovc_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc__smirnovc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__smirnovc_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__smirnovc_types[0] = <char>NPY_LONG
ufunc__smirnovc_types[1] = <char>NPY_DOUBLE
ufunc__smirnovc_types[2] = <char>NPY_DOUBLE
ufunc__smirnovc_types[3] = <char>NPY_FLOAT
ufunc__smirnovc_types[4] = <char>NPY_FLOAT
ufunc__smirnovc_types[5] = <char>NPY_FLOAT
ufunc__smirnovc_types[6] = <char>NPY_DOUBLE
ufunc__smirnovc_types[7] = <char>NPY_DOUBLE
ufunc__smirnovc_types[8] = <char>NPY_DOUBLE
ufunc__smirnovc_ptr[2*0] = <void*>_func_smirnovc
ufunc__smirnovc_ptr[2*0+1] = <void*>(<char*>"_smirnovc")
ufunc__smirnovc_ptr[2*1] = <void*>_func_smirnovc_unsafe
ufunc__smirnovc_ptr[2*1+1] = <void*>(<char*>"_smirnovc")
ufunc__smirnovc_ptr[2*2] = <void*>_func_smirnovc_unsafe
ufunc__smirnovc_ptr[2*2+1] = <void*>(<char*>"_smirnovc")
ufunc__smirnovc_data[0] = &ufunc__smirnovc_ptr[2*0]
ufunc__smirnovc_data[1] = &ufunc__smirnovc_ptr[2*1]
ufunc__smirnovc_data[2] = &ufunc__smirnovc_ptr[2*2]
_smirnovc = np.PyUFunc_FromFuncAndData(ufunc__smirnovc_loops, ufunc__smirnovc_data, ufunc__smirnovc_types, 3, 2, 1, 0, "_smirnovc", ufunc__smirnovc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__smirnovci_loops[3]
cdef void *ufunc__smirnovci_ptr[6]
cdef void *ufunc__smirnovci_data[3]
cdef char ufunc__smirnovci_types[9]
cdef char *ufunc__smirnovci_doc = (
    "Internal function, do not use.")
ufunc__smirnovci_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc__smirnovci_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__smirnovci_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__smirnovci_types[0] = <char>NPY_LONG
ufunc__smirnovci_types[1] = <char>NPY_DOUBLE
ufunc__smirnovci_types[2] = <char>NPY_DOUBLE
ufunc__smirnovci_types[3] = <char>NPY_FLOAT
ufunc__smirnovci_types[4] = <char>NPY_FLOAT
ufunc__smirnovci_types[5] = <char>NPY_FLOAT
ufunc__smirnovci_types[6] = <char>NPY_DOUBLE
ufunc__smirnovci_types[7] = <char>NPY_DOUBLE
ufunc__smirnovci_types[8] = <char>NPY_DOUBLE
ufunc__smirnovci_ptr[2*0] = <void*>_func_smirnovci
ufunc__smirnovci_ptr[2*0+1] = <void*>(<char*>"_smirnovci")
ufunc__smirnovci_ptr[2*1] = <void*>_func_smirnovci_unsafe
ufunc__smirnovci_ptr[2*1+1] = <void*>(<char*>"_smirnovci")
ufunc__smirnovci_ptr[2*2] = <void*>_func_smirnovci_unsafe
ufunc__smirnovci_ptr[2*2+1] = <void*>(<char*>"_smirnovci")
ufunc__smirnovci_data[0] = &ufunc__smirnovci_ptr[2*0]
ufunc__smirnovci_data[1] = &ufunc__smirnovci_ptr[2*1]
ufunc__smirnovci_data[2] = &ufunc__smirnovci_ptr[2*2]
_smirnovci = np.PyUFunc_FromFuncAndData(ufunc__smirnovci_loops, ufunc__smirnovci_data, ufunc__smirnovci_types, 3, 2, 1, 0, "_smirnovci", ufunc__smirnovci_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__smirnovp_loops[3]
cdef void *ufunc__smirnovp_ptr[6]
cdef void *ufunc__smirnovp_data[3]
cdef char ufunc__smirnovp_types[9]
cdef char *ufunc__smirnovp_doc = (
    "_smirnovp(n, p)\n"
    " Internal function, do not use.")
ufunc__smirnovp_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc__smirnovp_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__smirnovp_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__smirnovp_types[0] = <char>NPY_LONG
ufunc__smirnovp_types[1] = <char>NPY_DOUBLE
ufunc__smirnovp_types[2] = <char>NPY_DOUBLE
ufunc__smirnovp_types[3] = <char>NPY_FLOAT
ufunc__smirnovp_types[4] = <char>NPY_FLOAT
ufunc__smirnovp_types[5] = <char>NPY_FLOAT
ufunc__smirnovp_types[6] = <char>NPY_DOUBLE
ufunc__smirnovp_types[7] = <char>NPY_DOUBLE
ufunc__smirnovp_types[8] = <char>NPY_DOUBLE
ufunc__smirnovp_ptr[2*0] = <void*>_func_smirnovp
ufunc__smirnovp_ptr[2*0+1] = <void*>(<char*>"_smirnovp")
ufunc__smirnovp_ptr[2*1] = <void*>_func_smirnovp_unsafe
ufunc__smirnovp_ptr[2*1+1] = <void*>(<char*>"_smirnovp")
ufunc__smirnovp_ptr[2*2] = <void*>_func_smirnovp_unsafe
ufunc__smirnovp_ptr[2*2+1] = <void*>(<char*>"_smirnovp")
ufunc__smirnovp_data[0] = &ufunc__smirnovp_ptr[2*0]
ufunc__smirnovp_data[1] = &ufunc__smirnovp_ptr[2*1]
ufunc__smirnovp_data[2] = &ufunc__smirnovp_ptr[2*2]
_smirnovp = np.PyUFunc_FromFuncAndData(ufunc__smirnovp_loops, ufunc__smirnovp_data, ufunc__smirnovp_types, 3, 2, 1, 0, "_smirnovp", ufunc__smirnovp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_in_loops[2]
cdef void *ufunc__spherical_in_ptr[4]
cdef void *ufunc__spherical_in_data[2]
cdef char ufunc__spherical_in_types[6]
cdef char *ufunc__spherical_in_doc = (
    "Internal function, use `spherical_in` instead.")
ufunc__spherical_in_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_in_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_in_types[0] = <char>NPY_LONG
ufunc__spherical_in_types[1] = <char>NPY_DOUBLE
ufunc__spherical_in_types[2] = <char>NPY_DOUBLE
ufunc__spherical_in_types[3] = <char>NPY_LONG
ufunc__spherical_in_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_in_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_in_ptr[2*0] = <void*>_func_spherical_in_real
ufunc__spherical_in_ptr[2*0+1] = <void*>(<char*>"_spherical_in")
ufunc__spherical_in_ptr[2*1] = <void*>_func_spherical_in_complex
ufunc__spherical_in_ptr[2*1+1] = <void*>(<char*>"_spherical_in")
ufunc__spherical_in_data[0] = &ufunc__spherical_in_ptr[2*0]
ufunc__spherical_in_data[1] = &ufunc__spherical_in_ptr[2*1]
_spherical_in = np.PyUFunc_FromFuncAndData(ufunc__spherical_in_loops, ufunc__spherical_in_data, ufunc__spherical_in_types, 2, 2, 1, 0, "_spherical_in", ufunc__spherical_in_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_in_d_loops[2]
cdef void *ufunc__spherical_in_d_ptr[4]
cdef void *ufunc__spherical_in_d_data[2]
cdef char ufunc__spherical_in_d_types[6]
cdef char *ufunc__spherical_in_d_doc = (
    "Internal function, use `spherical_in` instead.")
ufunc__spherical_in_d_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_in_d_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_in_d_types[0] = <char>NPY_LONG
ufunc__spherical_in_d_types[1] = <char>NPY_DOUBLE
ufunc__spherical_in_d_types[2] = <char>NPY_DOUBLE
ufunc__spherical_in_d_types[3] = <char>NPY_LONG
ufunc__spherical_in_d_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_in_d_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_in_d_ptr[2*0] = <void*>_func_spherical_in_d_real
ufunc__spherical_in_d_ptr[2*0+1] = <void*>(<char*>"_spherical_in_d")
ufunc__spherical_in_d_ptr[2*1] = <void*>_func_spherical_in_d_complex
ufunc__spherical_in_d_ptr[2*1+1] = <void*>(<char*>"_spherical_in_d")
ufunc__spherical_in_d_data[0] = &ufunc__spherical_in_d_ptr[2*0]
ufunc__spherical_in_d_data[1] = &ufunc__spherical_in_d_ptr[2*1]
_spherical_in_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_in_d_loops, ufunc__spherical_in_d_data, ufunc__spherical_in_d_types, 2, 2, 1, 0, "_spherical_in_d", ufunc__spherical_in_d_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_jn_loops[2]
cdef void *ufunc__spherical_jn_ptr[4]
cdef void *ufunc__spherical_jn_data[2]
cdef char ufunc__spherical_jn_types[6]
cdef char *ufunc__spherical_jn_doc = (
    "Internal function, use `spherical_jn` instead.")
ufunc__spherical_jn_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_jn_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_jn_types[0] = <char>NPY_LONG
ufunc__spherical_jn_types[1] = <char>NPY_DOUBLE
ufunc__spherical_jn_types[2] = <char>NPY_DOUBLE
ufunc__spherical_jn_types[3] = <char>NPY_LONG
ufunc__spherical_jn_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_jn_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_jn_ptr[2*0] = <void*>_func_spherical_jn_real
ufunc__spherical_jn_ptr[2*0+1] = <void*>(<char*>"_spherical_jn")
ufunc__spherical_jn_ptr[2*1] = <void*>_func_spherical_jn_complex
ufunc__spherical_jn_ptr[2*1+1] = <void*>(<char*>"_spherical_jn")
ufunc__spherical_jn_data[0] = &ufunc__spherical_jn_ptr[2*0]
ufunc__spherical_jn_data[1] = &ufunc__spherical_jn_ptr[2*1]
_spherical_jn = np.PyUFunc_FromFuncAndData(ufunc__spherical_jn_loops, ufunc__spherical_jn_data, ufunc__spherical_jn_types, 2, 2, 1, 0, "_spherical_jn", ufunc__spherical_jn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_jn_d_loops[2]
cdef void *ufunc__spherical_jn_d_ptr[4]
cdef void *ufunc__spherical_jn_d_data[2]
cdef char ufunc__spherical_jn_d_types[6]
cdef char *ufunc__spherical_jn_d_doc = (
    "Internal function, use `spherical_jn` instead.")
ufunc__spherical_jn_d_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_jn_d_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_jn_d_types[0] = <char>NPY_LONG
ufunc__spherical_jn_d_types[1] = <char>NPY_DOUBLE
ufunc__spherical_jn_d_types[2] = <char>NPY_DOUBLE
ufunc__spherical_jn_d_types[3] = <char>NPY_LONG
ufunc__spherical_jn_d_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_jn_d_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_jn_d_ptr[2*0] = <void*>_func_spherical_jn_d_real
ufunc__spherical_jn_d_ptr[2*0+1] = <void*>(<char*>"_spherical_jn_d")
ufunc__spherical_jn_d_ptr[2*1] = <void*>_func_spherical_jn_d_complex
ufunc__spherical_jn_d_ptr[2*1+1] = <void*>(<char*>"_spherical_jn_d")
ufunc__spherical_jn_d_data[0] = &ufunc__spherical_jn_d_ptr[2*0]
ufunc__spherical_jn_d_data[1] = &ufunc__spherical_jn_d_ptr[2*1]
_spherical_jn_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_jn_d_loops, ufunc__spherical_jn_d_data, ufunc__spherical_jn_d_types, 2, 2, 1, 0, "_spherical_jn_d", ufunc__spherical_jn_d_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_kn_loops[2]
cdef void *ufunc__spherical_kn_ptr[4]
cdef void *ufunc__spherical_kn_data[2]
cdef char ufunc__spherical_kn_types[6]
cdef char *ufunc__spherical_kn_doc = (
    "Internal function, use `spherical_kn` instead.")
ufunc__spherical_kn_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_kn_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_kn_types[0] = <char>NPY_LONG
ufunc__spherical_kn_types[1] = <char>NPY_DOUBLE
ufunc__spherical_kn_types[2] = <char>NPY_DOUBLE
ufunc__spherical_kn_types[3] = <char>NPY_LONG
ufunc__spherical_kn_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_kn_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_kn_ptr[2*0] = <void*>_func_spherical_kn_real
ufunc__spherical_kn_ptr[2*0+1] = <void*>(<char*>"_spherical_kn")
ufunc__spherical_kn_ptr[2*1] = <void*>_func_spherical_kn_complex
ufunc__spherical_kn_ptr[2*1+1] = <void*>(<char*>"_spherical_kn")
ufunc__spherical_kn_data[0] = &ufunc__spherical_kn_ptr[2*0]
ufunc__spherical_kn_data[1] = &ufunc__spherical_kn_ptr[2*1]
_spherical_kn = np.PyUFunc_FromFuncAndData(ufunc__spherical_kn_loops, ufunc__spherical_kn_data, ufunc__spherical_kn_types, 2, 2, 1, 0, "_spherical_kn", ufunc__spherical_kn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_kn_d_loops[2]
cdef void *ufunc__spherical_kn_d_ptr[4]
cdef void *ufunc__spherical_kn_d_data[2]
cdef char ufunc__spherical_kn_d_types[6]
cdef char *ufunc__spherical_kn_d_doc = (
    "Internal function, use `spherical_kn` instead.")
ufunc__spherical_kn_d_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_kn_d_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_kn_d_types[0] = <char>NPY_LONG
ufunc__spherical_kn_d_types[1] = <char>NPY_DOUBLE
ufunc__spherical_kn_d_types[2] = <char>NPY_DOUBLE
ufunc__spherical_kn_d_types[3] = <char>NPY_LONG
ufunc__spherical_kn_d_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_kn_d_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_kn_d_ptr[2*0] = <void*>_func_spherical_kn_d_real
ufunc__spherical_kn_d_ptr[2*0+1] = <void*>(<char*>"_spherical_kn_d")
ufunc__spherical_kn_d_ptr[2*1] = <void*>_func_spherical_kn_d_complex
ufunc__spherical_kn_d_ptr[2*1+1] = <void*>(<char*>"_spherical_kn_d")
ufunc__spherical_kn_d_data[0] = &ufunc__spherical_kn_d_ptr[2*0]
ufunc__spherical_kn_d_data[1] = &ufunc__spherical_kn_d_ptr[2*1]
_spherical_kn_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_kn_d_loops, ufunc__spherical_kn_d_data, ufunc__spherical_kn_d_types, 2, 2, 1, 0, "_spherical_kn_d", ufunc__spherical_kn_d_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_yn_loops[2]
cdef void *ufunc__spherical_yn_ptr[4]
cdef void *ufunc__spherical_yn_data[2]
cdef char ufunc__spherical_yn_types[6]
cdef char *ufunc__spherical_yn_doc = (
    "Internal function, use `spherical_yn` instead.")
ufunc__spherical_yn_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_yn_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_yn_types[0] = <char>NPY_LONG
ufunc__spherical_yn_types[1] = <char>NPY_DOUBLE
ufunc__spherical_yn_types[2] = <char>NPY_DOUBLE
ufunc__spherical_yn_types[3] = <char>NPY_LONG
ufunc__spherical_yn_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_yn_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_yn_ptr[2*0] = <void*>_func_spherical_yn_real
ufunc__spherical_yn_ptr[2*0+1] = <void*>(<char*>"_spherical_yn")
ufunc__spherical_yn_ptr[2*1] = <void*>_func_spherical_yn_complex
ufunc__spherical_yn_ptr[2*1+1] = <void*>(<char*>"_spherical_yn")
ufunc__spherical_yn_data[0] = &ufunc__spherical_yn_ptr[2*0]
ufunc__spherical_yn_data[1] = &ufunc__spherical_yn_ptr[2*1]
_spherical_yn = np.PyUFunc_FromFuncAndData(ufunc__spherical_yn_loops, ufunc__spherical_yn_data, ufunc__spherical_yn_types, 2, 2, 1, 0, "_spherical_yn", ufunc__spherical_yn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_yn_d_loops[2]
cdef void *ufunc__spherical_yn_d_ptr[4]
cdef void *ufunc__spherical_yn_d_data[2]
cdef char ufunc__spherical_yn_d_types[6]
cdef char *ufunc__spherical_yn_d_doc = (
    "Internal function, use `spherical_yn` instead.")
ufunc__spherical_yn_d_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_yn_d_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_yn_d_types[0] = <char>NPY_LONG
ufunc__spherical_yn_d_types[1] = <char>NPY_DOUBLE
ufunc__spherical_yn_d_types[2] = <char>NPY_DOUBLE
ufunc__spherical_yn_d_types[3] = <char>NPY_LONG
ufunc__spherical_yn_d_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_yn_d_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_yn_d_ptr[2*0] = <void*>_func_spherical_yn_d_real
ufunc__spherical_yn_d_ptr[2*0+1] = <void*>(<char*>"_spherical_yn_d")
ufunc__spherical_yn_d_ptr[2*1] = <void*>_func_spherical_yn_d_complex
ufunc__spherical_yn_d_ptr[2*1+1] = <void*>(<char*>"_spherical_yn_d")
ufunc__spherical_yn_d_data[0] = &ufunc__spherical_yn_d_ptr[2*0]
ufunc__spherical_yn_d_data[1] = &ufunc__spherical_yn_d_ptr[2*1]
_spherical_yn_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_yn_d_loops, ufunc__spherical_yn_d_data, ufunc__spherical_yn_d_types, 2, 2, 1, 0, "_spherical_yn_d", ufunc__spherical_yn_d_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__stirling2_inexact_loops[2]
cdef void *ufunc__stirling2_inexact_ptr[4]
cdef void *ufunc__stirling2_inexact_data[2]
cdef char ufunc__stirling2_inexact_types[6]
cdef char *ufunc__stirling2_inexact_doc = (
    "Internal function, do not use.")
ufunc__stirling2_inexact_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__stirling2_inexact_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__stirling2_inexact_types[0] = <char>NPY_FLOAT
ufunc__stirling2_inexact_types[1] = <char>NPY_FLOAT
ufunc__stirling2_inexact_types[2] = <char>NPY_FLOAT
ufunc__stirling2_inexact_types[3] = <char>NPY_DOUBLE
ufunc__stirling2_inexact_types[4] = <char>NPY_DOUBLE
ufunc__stirling2_inexact_types[5] = <char>NPY_DOUBLE
ufunc__stirling2_inexact_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export__stirling2_inexact
ufunc__stirling2_inexact_ptr[2*0+1] = <void*>(<char*>"_stirling2_inexact")
ufunc__stirling2_inexact_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export__stirling2_inexact
ufunc__stirling2_inexact_ptr[2*1+1] = <void*>(<char*>"_stirling2_inexact")
ufunc__stirling2_inexact_data[0] = &ufunc__stirling2_inexact_ptr[2*0]
ufunc__stirling2_inexact_data[1] = &ufunc__stirling2_inexact_ptr[2*1]
_stirling2_inexact = np.PyUFunc_FromFuncAndData(ufunc__stirling2_inexact_loops, ufunc__stirling2_inexact_data, ufunc__stirling2_inexact_types, 2, 2, 1, 0, "_stirling2_inexact", ufunc__stirling2_inexact_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_asymp_large_z_loops[1]
cdef void *ufunc__struve_asymp_large_z_ptr[2]
cdef void *ufunc__struve_asymp_large_z_data[1]
cdef char ufunc__struve_asymp_large_z_types[5]
cdef char *ufunc__struve_asymp_large_z_doc = (
    "_struve_asymp_large_z(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using asymptotic expansion\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_asymp_large_z_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddi_d_As_ddl_dd
ufunc__struve_asymp_large_z_types[0] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[1] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[2] = <char>NPY_LONG
ufunc__struve_asymp_large_z_types[3] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[4] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_ptr[2*0] = <void*>_func_struve_asymp_large_z
ufunc__struve_asymp_large_z_ptr[2*0+1] = <void*>(<char*>"_struve_asymp_large_z")
ufunc__struve_asymp_large_z_data[0] = &ufunc__struve_asymp_large_z_ptr[2*0]
_struve_asymp_large_z = np.PyUFunc_FromFuncAndData(ufunc__struve_asymp_large_z_loops, ufunc__struve_asymp_large_z_data, ufunc__struve_asymp_large_z_types, 1, 3, 2, 0, "_struve_asymp_large_z", ufunc__struve_asymp_large_z_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_bessel_series_loops[1]
cdef void *ufunc__struve_bessel_series_ptr[2]
cdef void *ufunc__struve_bessel_series_data[1]
cdef char ufunc__struve_bessel_series_types[5]
cdef char *ufunc__struve_bessel_series_doc = (
    "_struve_bessel_series(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using Bessel function series\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_bessel_series_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddi_d_As_ddl_dd
ufunc__struve_bessel_series_types[0] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[1] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[2] = <char>NPY_LONG
ufunc__struve_bessel_series_types[3] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[4] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_ptr[2*0] = <void*>_func_struve_bessel_series
ufunc__struve_bessel_series_ptr[2*0+1] = <void*>(<char*>"_struve_bessel_series")
ufunc__struve_bessel_series_data[0] = &ufunc__struve_bessel_series_ptr[2*0]
_struve_bessel_series = np.PyUFunc_FromFuncAndData(ufunc__struve_bessel_series_loops, ufunc__struve_bessel_series_data, ufunc__struve_bessel_series_types, 1, 3, 2, 0, "_struve_bessel_series", ufunc__struve_bessel_series_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_power_series_loops[1]
cdef void *ufunc__struve_power_series_ptr[2]
cdef void *ufunc__struve_power_series_data[1]
cdef char ufunc__struve_power_series_types[5]
cdef char *ufunc__struve_power_series_doc = (
    "_struve_power_series(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using power series\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_power_series_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddi_d_As_ddl_dd
ufunc__struve_power_series_types[0] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[1] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[2] = <char>NPY_LONG
ufunc__struve_power_series_types[3] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[4] = <char>NPY_DOUBLE
ufunc__struve_power_series_ptr[2*0] = <void*>_func_struve_power_series
ufunc__struve_power_series_ptr[2*0+1] = <void*>(<char*>"_struve_power_series")
ufunc__struve_power_series_data[0] = &ufunc__struve_power_series_ptr[2*0]
_struve_power_series = np.PyUFunc_FromFuncAndData(ufunc__struve_power_series_loops, ufunc__struve_power_series_data, ufunc__struve_power_series_types, 1, 3, 2, 0, "_struve_power_series", ufunc__struve_power_series_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__zeta_loops[2]
cdef void *ufunc__zeta_ptr[4]
cdef void *ufunc__zeta_data[2]
cdef char ufunc__zeta_types[6]
cdef char *ufunc__zeta_doc = (
    "_zeta(x, q)\n"
    "\n"
    "Internal function, Hurwitz zeta.")
ufunc__zeta_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__zeta_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__zeta_types[0] = <char>NPY_FLOAT
ufunc__zeta_types[1] = <char>NPY_FLOAT
ufunc__zeta_types[2] = <char>NPY_FLOAT
ufunc__zeta_types[3] = <char>NPY_DOUBLE
ufunc__zeta_types[4] = <char>NPY_DOUBLE
ufunc__zeta_types[5] = <char>NPY_DOUBLE
ufunc__zeta_ptr[2*0] = <void*>_func_zeta
ufunc__zeta_ptr[2*0+1] = <void*>(<char*>"_zeta")
ufunc__zeta_ptr[2*1] = <void*>_func_zeta
ufunc__zeta_ptr[2*1+1] = <void*>(<char*>"_zeta")
ufunc__zeta_data[0] = &ufunc__zeta_ptr[2*0]
ufunc__zeta_data[1] = &ufunc__zeta_ptr[2*1]
_zeta = np.PyUFunc_FromFuncAndData(ufunc__zeta_loops, ufunc__zeta_data, ufunc__zeta_types, 2, 2, 1, 0, "_zeta", ufunc__zeta_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_agm_loops[2]
cdef void *ufunc_agm_ptr[4]
cdef void *ufunc_agm_data[2]
cdef char ufunc_agm_types[6]
cdef char *ufunc_agm_doc = (
    "agm(a, b, out=None)\n"
    "\n"
    "Compute the arithmetic-geometric mean of `a` and `b`.\n"
    "\n"
    "Start with a_0 = a and b_0 = b and iteratively compute::\n"
    "\n"
    "    a_{n+1} = (a_n + b_n)/2\n"
    "    b_{n+1} = sqrt(a_n*b_n)\n"
    "\n"
    "a_n and b_n converge to the same limit as n increases; their common\n"
    "limit is agm(a, b).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Real values only. If the values are both negative, the result\n"
    "    is negative. If one value is negative and the other is positive,\n"
    "    `nan` is returned.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The arithmetic-geometric mean of `a` and `b`.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import agm\n"
    ">>> a, b = 24.0, 6.0\n"
    ">>> agm(a, b)\n"
    "13.458171481725614\n"
    "\n"
    "Compare that result to the iteration:\n"
    "\n"
    ">>> while a != b:\n"
    "...     a, b = (a + b)/2, np.sqrt(a*b)\n"
    "...     print(\"a = %19.16f  b=%19.16f\" % (a, b))\n"
    "...\n"
    "a = 15.0000000000000000  b=12.0000000000000000\n"
    "a = 13.5000000000000000  b=13.4164078649987388\n"
    "a = 13.4582039324993694  b=13.4581390309909850\n"
    "a = 13.4581714817451772  b=13.4581714817060547\n"
    "a = 13.4581714817256159  b=13.4581714817256159\n"
    "\n"
    "When array-like arguments are given, broadcasting applies:\n"
    "\n"
    ">>> a = np.array([[1.5], [3], [6]])  # a has shape (3, 1).\n"
    ">>> b = np.array([6, 12, 24, 48])    # b has shape (4,).\n"
    ">>> agm(a, b)\n"
    "array([[  3.36454287,   5.42363427,   9.05798751,  15.53650756],\n"
    "       [  4.37037309,   6.72908574,  10.84726853,  18.11597502],\n"
    "       [  6.        ,   8.74074619,  13.45817148,  21.69453707]])")
ufunc_agm_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_agm_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_agm_types[0] = <char>NPY_FLOAT
ufunc_agm_types[1] = <char>NPY_FLOAT
ufunc_agm_types[2] = <char>NPY_FLOAT
ufunc_agm_types[3] = <char>NPY_DOUBLE
ufunc_agm_types[4] = <char>NPY_DOUBLE
ufunc_agm_types[5] = <char>NPY_DOUBLE
ufunc_agm_ptr[2*0] = <void*>_func_agm
ufunc_agm_ptr[2*0+1] = <void*>(<char*>"agm")
ufunc_agm_ptr[2*1] = <void*>_func_agm
ufunc_agm_ptr[2*1+1] = <void*>(<char*>"agm")
ufunc_agm_data[0] = &ufunc_agm_ptr[2*0]
ufunc_agm_data[1] = &ufunc_agm_ptr[2*1]
agm = np.PyUFunc_FromFuncAndData(ufunc_agm_loops, ufunc_agm_data, ufunc_agm_types, 2, 2, 1, 0, "agm", ufunc_agm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_airy_loops[4]
cdef void *ufunc_airy_ptr[8]
cdef void *ufunc_airy_data[4]
cdef char ufunc_airy_types[20]
cdef char *ufunc_airy_doc = (
    "airy(z, out=None)\n"
    "\n"
    "Airy functions and their derivatives.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Real or complex argument.\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Ai, Aip, Bi, Bip : 4-tuple of scalar or ndarray\n"
    "    Airy functions Ai and Bi, and their derivatives Aip and Bip.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "airye : exponentially scaled Airy functions.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The Airy functions Ai and Bi are two independent solutions of\n"
    "\n"
    ".. math:: y''(x) = x y(x).\n"
    "\n"
    "For real `z` in [-10, 10], the computation is carried out by calling\n"
    "the Cephes [1]_ `airy` routine, which uses power series summation\n"
    "for small `z` and rational minimax approximations for large `z`.\n"
    "\n"
    "Outside this range, the AMOS [2]_ `zairy` and `zbiry` routines are\n"
    "employed.  They are computed using power series for :math:`|z| < 1` and\n"
    "the following relations to modified Bessel functions for larger `z`\n"
    "(where :math:`t \\equiv 2 z^{3/2}/3`):\n"
    "\n"
    ".. math::\n"
    "\n"
    "    Ai(z) = \\frac{1}{\\pi \\sqrt{3}} K_{1/3}(t)\n"
    "\n"
    "    Ai'(z) = -\\frac{z}{\\pi \\sqrt{3}} K_{2/3}(t)\n"
    "\n"
    "    Bi(z) = \\sqrt{\\frac{z}{3}} \\left(I_{-1/3}(t) + I_{1/3}(t) \\right)\n"
    "\n"
    "    Bi'(z) = \\frac{z}{\\sqrt{3}} \\left(I_{-2/3}(t) + I_{2/3}(t)\\right)\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    ".. [2] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the Airy functions on the interval [-15, 5].\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> x = np.linspace(-15, 5, 201)\n"
    ">>> ai, aip, bi, bip = special.airy(x)\n"
    "\n"
    "Plot Ai(x) and Bi(x).\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> plt.plot(x, ai, 'r', label='Ai(x)')\n"
    ">>> plt.plot(x, bi, 'b--', label='Bi(x)')\n"
    ">>> plt.ylim(-0.5, 1.0)\n"
    ">>> plt.grid()\n"
    ">>> plt.legend(loc='upper left')\n"
    ">>> plt.show()")
ufunc_airy_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_f_ffff
ufunc_airy_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_d_dddd
ufunc_airy_loops[2] = <np.PyUFuncGenericFunction>loop_i_D_DDDD_As_F_FFFF
ufunc_airy_loops[3] = <np.PyUFuncGenericFunction>loop_i_D_DDDD_As_D_DDDD
ufunc_airy_types[0] = <char>NPY_FLOAT
ufunc_airy_types[1] = <char>NPY_FLOAT
ufunc_airy_types[2] = <char>NPY_FLOAT
ufunc_airy_types[3] = <char>NPY_FLOAT
ufunc_airy_types[4] = <char>NPY_FLOAT
ufunc_airy_types[5] = <char>NPY_DOUBLE
ufunc_airy_types[6] = <char>NPY_DOUBLE
ufunc_airy_types[7] = <char>NPY_DOUBLE
ufunc_airy_types[8] = <char>NPY_DOUBLE
ufunc_airy_types[9] = <char>NPY_DOUBLE
ufunc_airy_types[10] = <char>NPY_CFLOAT
ufunc_airy_types[11] = <char>NPY_CFLOAT
ufunc_airy_types[12] = <char>NPY_CFLOAT
ufunc_airy_types[13] = <char>NPY_CFLOAT
ufunc_airy_types[14] = <char>NPY_CFLOAT
ufunc_airy_types[15] = <char>NPY_CDOUBLE
ufunc_airy_types[16] = <char>NPY_CDOUBLE
ufunc_airy_types[17] = <char>NPY_CDOUBLE
ufunc_airy_types[18] = <char>NPY_CDOUBLE
ufunc_airy_types[19] = <char>NPY_CDOUBLE
ufunc_airy_ptr[2*0] = <void*>_func_airy_wrap
ufunc_airy_ptr[2*0+1] = <void*>(<char*>"airy")
ufunc_airy_ptr[2*1] = <void*>_func_airy_wrap
ufunc_airy_ptr[2*1+1] = <void*>(<char*>"airy")
ufunc_airy_ptr[2*2] = <void*>_func_cairy_wrap
ufunc_airy_ptr[2*2+1] = <void*>(<char*>"airy")
ufunc_airy_ptr[2*3] = <void*>_func_cairy_wrap
ufunc_airy_ptr[2*3+1] = <void*>(<char*>"airy")
ufunc_airy_data[0] = &ufunc_airy_ptr[2*0]
ufunc_airy_data[1] = &ufunc_airy_ptr[2*1]
ufunc_airy_data[2] = &ufunc_airy_ptr[2*2]
ufunc_airy_data[3] = &ufunc_airy_ptr[2*3]
airy = np.PyUFunc_FromFuncAndData(ufunc_airy_loops, ufunc_airy_data, ufunc_airy_types, 4, 1, 4, 0, "airy", ufunc_airy_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_airye_loops[4]
cdef void *ufunc_airye_ptr[8]
cdef void *ufunc_airye_data[4]
cdef char ufunc_airye_types[20]
cdef char *ufunc_airye_doc = (
    "airye(z, out=None)\n"
    "\n"
    "Exponentially scaled Airy functions and their derivatives.\n"
    "\n"
    "Scaling::\n"
    "\n"
    "    eAi  = Ai  * exp(2.0/3.0*z*sqrt(z))\n"
    "    eAip = Aip * exp(2.0/3.0*z*sqrt(z))\n"
    "    eBi  = Bi  * exp(-abs(2.0/3.0*(z*sqrt(z)).real))\n"
    "    eBip = Bip * exp(-abs(2.0/3.0*(z*sqrt(z)).real))\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Real or complex argument.\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "eAi, eAip, eBi, eBip : 4-tuple of scalar or ndarray\n"
    "    Exponentially scaled Airy functions eAi and eBi, and their derivatives\n"
    "    eAip and eBip\n"
    "\n"
    "See Also\n"
    "--------\n"
    "airy\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the AMOS [1]_ routines `zairy` and `zbiry`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "We can compute exponentially scaled Airy functions and their derivatives:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import airye\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> z = np.linspace(0, 50, 500)\n"
    ">>> eAi, eAip, eBi, eBip = airye(z)\n"
    ">>> f, ax = plt.subplots(2, 1, sharex=True)\n"
    ">>> for ind, data in enumerate([[eAi, eAip, [\"eAi\", \"eAip\"]],\n"
    "...                             [eBi, eBip, [\"eBi\", \"eBip\"]]]):\n"
    "...     ax[ind].plot(z, data[0], \"-r\", z, data[1], \"-b\")\n"
    "...     ax[ind].legend(data[2])\n"
    "...     ax[ind].grid(True)\n"
    ">>> plt.show()\n"
    "\n"
    "We can compute these using usual non-scaled Airy functions by:\n"
    "\n"
    ">>> from scipy.special import airy\n"
    ">>> Ai, Aip, Bi, Bip = airy(z)\n"
    ">>> np.allclose(eAi, Ai * np.exp(2.0 / 3.0 * z * np.sqrt(z)))\n"
    "True\n"
    ">>> np.allclose(eAip, Aip * np.exp(2.0 / 3.0 * z * np.sqrt(z)))\n"
    "True\n"
    ">>> np.allclose(eBi, Bi * np.exp(-abs(np.real(2.0 / 3.0 * z * np.sqrt(z)))))\n"
    "True\n"
    ">>> np.allclose(eBip, Bip * np.exp(-abs(np.real(2.0 / 3.0 * z * np.sqrt(z)))))\n"
    "True\n"
    "\n"
    "Comparing non-scaled and exponentially scaled ones, the usual non-scaled\n"
    "function quickly underflows for large values, whereas the exponentially\n"
    "scaled function does not.\n"
    "\n"
    ">>> airy(200)\n"
    "(0.0, 0.0, nan, nan)\n"
    ">>> airye(200)\n"
    "(0.07501041684381093, -1.0609012305109042, 0.15003188417418148, 2.1215836725571093)")
ufunc_airye_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_f_ffff
ufunc_airye_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_d_dddd
ufunc_airye_loops[2] = <np.PyUFuncGenericFunction>loop_i_D_DDDD_As_F_FFFF
ufunc_airye_loops[3] = <np.PyUFuncGenericFunction>loop_i_D_DDDD_As_D_DDDD
ufunc_airye_types[0] = <char>NPY_FLOAT
ufunc_airye_types[1] = <char>NPY_FLOAT
ufunc_airye_types[2] = <char>NPY_FLOAT
ufunc_airye_types[3] = <char>NPY_FLOAT
ufunc_airye_types[4] = <char>NPY_FLOAT
ufunc_airye_types[5] = <char>NPY_DOUBLE
ufunc_airye_types[6] = <char>NPY_DOUBLE
ufunc_airye_types[7] = <char>NPY_DOUBLE
ufunc_airye_types[8] = <char>NPY_DOUBLE
ufunc_airye_types[9] = <char>NPY_DOUBLE
ufunc_airye_types[10] = <char>NPY_CFLOAT
ufunc_airye_types[11] = <char>NPY_CFLOAT
ufunc_airye_types[12] = <char>NPY_CFLOAT
ufunc_airye_types[13] = <char>NPY_CFLOAT
ufunc_airye_types[14] = <char>NPY_CFLOAT
ufunc_airye_types[15] = <char>NPY_CDOUBLE
ufunc_airye_types[16] = <char>NPY_CDOUBLE
ufunc_airye_types[17] = <char>NPY_CDOUBLE
ufunc_airye_types[18] = <char>NPY_CDOUBLE
ufunc_airye_types[19] = <char>NPY_CDOUBLE
ufunc_airye_ptr[2*0] = <void*>_func_cairy_wrap_e_real
ufunc_airye_ptr[2*0+1] = <void*>(<char*>"airye")
ufunc_airye_ptr[2*1] = <void*>_func_cairy_wrap_e_real
ufunc_airye_ptr[2*1+1] = <void*>(<char*>"airye")
ufunc_airye_ptr[2*2] = <void*>_func_cairy_wrap_e
ufunc_airye_ptr[2*2+1] = <void*>(<char*>"airye")
ufunc_airye_ptr[2*3] = <void*>_func_cairy_wrap_e
ufunc_airye_ptr[2*3+1] = <void*>(<char*>"airye")
ufunc_airye_data[0] = &ufunc_airye_ptr[2*0]
ufunc_airye_data[1] = &ufunc_airye_ptr[2*1]
ufunc_airye_data[2] = &ufunc_airye_ptr[2*2]
ufunc_airye_data[3] = &ufunc_airye_ptr[2*3]
airye = np.PyUFunc_FromFuncAndData(ufunc_airye_loops, ufunc_airye_data, ufunc_airye_types, 4, 1, 4, 0, "airye", ufunc_airye_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtr_loops[3]
cdef void *ufunc_bdtr_ptr[6]
cdef void *ufunc_bdtr_data[3]
cdef char ufunc_bdtr_types[12]
cdef char *ufunc_bdtr_doc = (
    "bdtr(k, n, p, out=None)\n"
    "\n"
    "Binomial distribution cumulative distribution function.\n"
    "\n"
    "Sum of the terms 0 through `floor(k)` of the Binomial probability density.\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtr}(k, n, p) =\n"
    "    \\sum_{j=0}^{\\lfloor k \\rfloor} {{n}\\choose{j}} p^j (1-p)^{n-j}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (double), rounded down to the nearest integer.\n"
    "n : array_like\n"
    "    Number of events (int).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Probability of `floor(k)` or fewer successes in `n` independent events with\n"
    "    success probabilities of `p`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtr}(k, n, p) =\n"
    "    I_{1 - p}(n - \\lfloor k \\rfloor, \\lfloor k \\rfloor + 1).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtr`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_bdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_did__As_dld_d
ufunc_bdtr_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtr_types[0] = <char>NPY_FLOAT
ufunc_bdtr_types[1] = <char>NPY_FLOAT
ufunc_bdtr_types[2] = <char>NPY_FLOAT
ufunc_bdtr_types[3] = <char>NPY_FLOAT
ufunc_bdtr_types[4] = <char>NPY_DOUBLE
ufunc_bdtr_types[5] = <char>NPY_LONG
ufunc_bdtr_types[6] = <char>NPY_DOUBLE
ufunc_bdtr_types[7] = <char>NPY_DOUBLE
ufunc_bdtr_types[8] = <char>NPY_DOUBLE
ufunc_bdtr_types[9] = <char>NPY_DOUBLE
ufunc_bdtr_types[10] = <char>NPY_DOUBLE
ufunc_bdtr_types[11] = <char>NPY_DOUBLE
ufunc_bdtr_ptr[2*0] = <void*>_func_bdtr_unsafe
ufunc_bdtr_ptr[2*0+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_ptr[2*1] = <void*>_func_bdtr
ufunc_bdtr_ptr[2*1+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_ptr[2*2] = <void*>_func_bdtr_unsafe
ufunc_bdtr_ptr[2*2+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_data[0] = &ufunc_bdtr_ptr[2*0]
ufunc_bdtr_data[1] = &ufunc_bdtr_ptr[2*1]
ufunc_bdtr_data[2] = &ufunc_bdtr_ptr[2*2]
bdtr = np.PyUFunc_FromFuncAndData(ufunc_bdtr_loops, ufunc_bdtr_data, ufunc_bdtr_types, 3, 3, 1, 0, "bdtr", ufunc_bdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrc_loops[3]
cdef void *ufunc_bdtrc_ptr[6]
cdef void *ufunc_bdtrc_data[3]
cdef char ufunc_bdtrc_types[12]
cdef char *ufunc_bdtrc_doc = (
    "bdtrc(k, n, p, out=None)\n"
    "\n"
    "Binomial distribution survival function.\n"
    "\n"
    "Sum of the terms `floor(k) + 1` through `n` of the binomial probability\n"
    "density,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtrc}(k, n, p) =\n"
    "    \\sum_{j=\\lfloor k \\rfloor +1}^n {{n}\\choose{j}} p^j (1-p)^{n-j}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (double), rounded down to nearest integer.\n"
    "n : array_like\n"
    "    Number of events (int)\n"
    "p : array_like\n"
    "    Probability of success in a single event.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Probability of `floor(k) + 1` or more successes in `n` independent\n"
    "    events with success probabilities of `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "betainc\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtrc}(k, n, p) = I_{p}(\\lfloor k \\rfloor + 1, n - \\lfloor k \\rfloor).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtrc`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_bdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_did__As_dld_d
ufunc_bdtrc_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrc_types[0] = <char>NPY_FLOAT
ufunc_bdtrc_types[1] = <char>NPY_FLOAT
ufunc_bdtrc_types[2] = <char>NPY_FLOAT
ufunc_bdtrc_types[3] = <char>NPY_FLOAT
ufunc_bdtrc_types[4] = <char>NPY_DOUBLE
ufunc_bdtrc_types[5] = <char>NPY_LONG
ufunc_bdtrc_types[6] = <char>NPY_DOUBLE
ufunc_bdtrc_types[7] = <char>NPY_DOUBLE
ufunc_bdtrc_types[8] = <char>NPY_DOUBLE
ufunc_bdtrc_types[9] = <char>NPY_DOUBLE
ufunc_bdtrc_types[10] = <char>NPY_DOUBLE
ufunc_bdtrc_types[11] = <char>NPY_DOUBLE
ufunc_bdtrc_ptr[2*0] = <void*>_func_bdtrc_unsafe
ufunc_bdtrc_ptr[2*0+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_ptr[2*1] = <void*>_func_bdtrc
ufunc_bdtrc_ptr[2*1+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_ptr[2*2] = <void*>_func_bdtrc_unsafe
ufunc_bdtrc_ptr[2*2+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_data[0] = &ufunc_bdtrc_ptr[2*0]
ufunc_bdtrc_data[1] = &ufunc_bdtrc_ptr[2*1]
ufunc_bdtrc_data[2] = &ufunc_bdtrc_ptr[2*2]
bdtrc = np.PyUFunc_FromFuncAndData(ufunc_bdtrc_loops, ufunc_bdtrc_data, ufunc_bdtrc_types, 3, 3, 1, 0, "bdtrc", ufunc_bdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtri_loops[3]
cdef void *ufunc_bdtri_ptr[6]
cdef void *ufunc_bdtri_data[3]
cdef char ufunc_bdtri_types[12]
cdef char *ufunc_bdtri_doc = (
    "bdtri(k, n, y, out=None)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `p`.\n"
    "\n"
    "Finds the event probability `p` such that the sum of the terms 0 through\n"
    "`k` of the binomial probability density is equal to the given cumulative\n"
    "probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (float), rounded down to the nearest integer.\n"
    "n : array_like\n"
    "    Number of events (float)\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "p : scalar or ndarray\n"
    "    The event probability such that `bdtr(\\lfloor k \\rfloor, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "betaincinv\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The computation is carried out using the inverse beta integral function\n"
    "and the relation,::\n"
    "\n"
    "    1 - p = betaincinv(n - k, k + 1, y).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtri`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_bdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_did__As_dld_d
ufunc_bdtri_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtri_types[0] = <char>NPY_FLOAT
ufunc_bdtri_types[1] = <char>NPY_FLOAT
ufunc_bdtri_types[2] = <char>NPY_FLOAT
ufunc_bdtri_types[3] = <char>NPY_FLOAT
ufunc_bdtri_types[4] = <char>NPY_DOUBLE
ufunc_bdtri_types[5] = <char>NPY_LONG
ufunc_bdtri_types[6] = <char>NPY_DOUBLE
ufunc_bdtri_types[7] = <char>NPY_DOUBLE
ufunc_bdtri_types[8] = <char>NPY_DOUBLE
ufunc_bdtri_types[9] = <char>NPY_DOUBLE
ufunc_bdtri_types[10] = <char>NPY_DOUBLE
ufunc_bdtri_types[11] = <char>NPY_DOUBLE
ufunc_bdtri_ptr[2*0] = <void*>_func_bdtri_unsafe
ufunc_bdtri_ptr[2*0+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_ptr[2*1] = <void*>_func_bdtri
ufunc_bdtri_ptr[2*1+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_ptr[2*2] = <void*>_func_bdtri_unsafe
ufunc_bdtri_ptr[2*2+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_data[0] = &ufunc_bdtri_ptr[2*0]
ufunc_bdtri_data[1] = &ufunc_bdtri_ptr[2*1]
ufunc_bdtri_data[2] = &ufunc_bdtri_ptr[2*2]
bdtri = np.PyUFunc_FromFuncAndData(ufunc_bdtri_loops, ufunc_bdtri_data, ufunc_bdtri_types, 3, 3, 1, 0, "bdtri", ufunc_bdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrik_loops[2]
cdef void *ufunc_bdtrik_ptr[4]
cdef void *ufunc_bdtrik_data[2]
cdef char ufunc_bdtrik_types[8]
cdef char *ufunc_bdtrik_doc = (
    "bdtrik(y, n, p, out=None)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `k`.\n"
    "\n"
    "Finds the number of successes `k` such that the sum of the terms 0 through\n"
    "`k` of the Binomial probability density for `n` events with probability\n"
    "`p` is equal to the given cumulative probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "n : array_like\n"
    "    Number of events (float).\n"
    "p : array_like\n"
    "    Success probability (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "k : scalar or ndarray\n"
    "    The number of successes `k` such that `bdtr(k, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the\n"
    "cumulative incomplete beta distribution.\n"
    "\n"
    "Computation of `k` involves a search for a value that produces the desired\n"
    "value of `y`. The search relies on the monotonicity of `y` with `k`.\n"
    "\n"
    "Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [2] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.")
ufunc_bdtrik_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrik_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrik_types[0] = <char>NPY_FLOAT
ufunc_bdtrik_types[1] = <char>NPY_FLOAT
ufunc_bdtrik_types[2] = <char>NPY_FLOAT
ufunc_bdtrik_types[3] = <char>NPY_FLOAT
ufunc_bdtrik_types[4] = <char>NPY_DOUBLE
ufunc_bdtrik_types[5] = <char>NPY_DOUBLE
ufunc_bdtrik_types[6] = <char>NPY_DOUBLE
ufunc_bdtrik_types[7] = <char>NPY_DOUBLE
ufunc_bdtrik_ptr[2*0] = <void*>_func_cdfbin2_wrap
ufunc_bdtrik_ptr[2*0+1] = <void*>(<char*>"bdtrik")
ufunc_bdtrik_ptr[2*1] = <void*>_func_cdfbin2_wrap
ufunc_bdtrik_ptr[2*1+1] = <void*>(<char*>"bdtrik")
ufunc_bdtrik_data[0] = &ufunc_bdtrik_ptr[2*0]
ufunc_bdtrik_data[1] = &ufunc_bdtrik_ptr[2*1]
bdtrik = np.PyUFunc_FromFuncAndData(ufunc_bdtrik_loops, ufunc_bdtrik_data, ufunc_bdtrik_types, 2, 3, 1, 0, "bdtrik", ufunc_bdtrik_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrin_loops[2]
cdef void *ufunc_bdtrin_ptr[4]
cdef void *ufunc_bdtrin_data[2]
cdef char ufunc_bdtrin_types[8]
cdef char *ufunc_bdtrin_doc = (
    "bdtrin(k, y, p, out=None)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `n`.\n"
    "\n"
    "Finds the number of events `n` such that the sum of the terms 0 through\n"
    "`k` of the Binomial probability density for events with probability `p` is\n"
    "equal to the given cumulative probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (float).\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "p : array_like\n"
    "    Success probability (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "n : scalar or ndarray\n"
    "    The number of events `n` such that `bdtr(k, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the\n"
    "cumulative incomplete beta distribution.\n"
    "\n"
    "Computation of `n` involves a search for a value that produces the desired\n"
    "value of `y`. The search relies on the monotonicity of `y` with `n`.\n"
    "\n"
    "Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [2] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.")
ufunc_bdtrin_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrin_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrin_types[0] = <char>NPY_FLOAT
ufunc_bdtrin_types[1] = <char>NPY_FLOAT
ufunc_bdtrin_types[2] = <char>NPY_FLOAT
ufunc_bdtrin_types[3] = <char>NPY_FLOAT
ufunc_bdtrin_types[4] = <char>NPY_DOUBLE
ufunc_bdtrin_types[5] = <char>NPY_DOUBLE
ufunc_bdtrin_types[6] = <char>NPY_DOUBLE
ufunc_bdtrin_types[7] = <char>NPY_DOUBLE
ufunc_bdtrin_ptr[2*0] = <void*>_func_cdfbin3_wrap
ufunc_bdtrin_ptr[2*0+1] = <void*>(<char*>"bdtrin")
ufunc_bdtrin_ptr[2*1] = <void*>_func_cdfbin3_wrap
ufunc_bdtrin_ptr[2*1+1] = <void*>(<char*>"bdtrin")
ufunc_bdtrin_data[0] = &ufunc_bdtrin_ptr[2*0]
ufunc_bdtrin_data[1] = &ufunc_bdtrin_ptr[2*1]
bdtrin = np.PyUFunc_FromFuncAndData(ufunc_bdtrin_loops, ufunc_bdtrin_data, ufunc_bdtrin_types, 2, 3, 1, 0, "bdtrin", ufunc_bdtrin_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bei_loops[2]
cdef void *ufunc_bei_ptr[4]
cdef void *ufunc_bei_data[2]
cdef char ufunc_bei_types[4]
cdef char *ufunc_bei_doc = (
    "bei(x, out=None)\n"
    "\n"
    "Kelvin function bei.\n"
    "\n"
    "Defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\mathrm{bei}(x) = \\Im[J_0(x e^{3 \\pi i / 4})]\n"
    "\n"
    "where :math:`J_0` is the Bessel function of the first kind of\n"
    "order zero (see `jv`). See [dlmf]_ for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the Kelvin function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ber : the corresponding real part\n"
    "beip : the derivative of bei\n"
    "jv : Bessel function of the first kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST, Digital Library of Mathematical Functions,\n"
    "    https://dlmf.nist.gov/10.61\n"
    "\n"
    "Examples\n"
    "--------\n"
    "It can be expressed using Bessel functions.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    ">>> x = np.array([1.0, 2.0, 3.0, 4.0])\n"
    ">>> sc.jv(0, x * np.exp(3 * np.pi * 1j / 4)).imag\n"
    "array([0.24956604, 0.97229163, 1.93758679, 2.29269032])\n"
    ">>> sc.bei(x)\n"
    "array([0.24956604, 0.97229163, 1.93758679, 2.29269032])")
ufunc_bei_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_bei_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_bei_types[0] = <char>NPY_FLOAT
ufunc_bei_types[1] = <char>NPY_FLOAT
ufunc_bei_types[2] = <char>NPY_DOUBLE
ufunc_bei_types[3] = <char>NPY_DOUBLE
ufunc_bei_ptr[2*0] = <void*>_func_bei_wrap
ufunc_bei_ptr[2*0+1] = <void*>(<char*>"bei")
ufunc_bei_ptr[2*1] = <void*>_func_bei_wrap
ufunc_bei_ptr[2*1+1] = <void*>(<char*>"bei")
ufunc_bei_data[0] = &ufunc_bei_ptr[2*0]
ufunc_bei_data[1] = &ufunc_bei_ptr[2*1]
bei = np.PyUFunc_FromFuncAndData(ufunc_bei_loops, ufunc_bei_data, ufunc_bei_types, 2, 1, 1, 0, "bei", ufunc_bei_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_beip_loops[2]
cdef void *ufunc_beip_ptr[4]
cdef void *ufunc_beip_data[2]
cdef char ufunc_beip_types[4]
cdef char *ufunc_beip_doc = (
    "beip(x, out=None)\n"
    "\n"
    "Derivative of the Kelvin function bei.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The values of the derivative of bei.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bei\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST, Digital Library of Mathematical Functions,\n"
    "    https://dlmf.nist.gov/10#PT5")
ufunc_beip_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_beip_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_beip_types[0] = <char>NPY_FLOAT
ufunc_beip_types[1] = <char>NPY_FLOAT
ufunc_beip_types[2] = <char>NPY_DOUBLE
ufunc_beip_types[3] = <char>NPY_DOUBLE
ufunc_beip_ptr[2*0] = <void*>_func_beip_wrap
ufunc_beip_ptr[2*0+1] = <void*>(<char*>"beip")
ufunc_beip_ptr[2*1] = <void*>_func_beip_wrap
ufunc_beip_ptr[2*1+1] = <void*>(<char*>"beip")
ufunc_beip_data[0] = &ufunc_beip_ptr[2*0]
ufunc_beip_data[1] = &ufunc_beip_ptr[2*1]
beip = np.PyUFunc_FromFuncAndData(ufunc_beip_loops, ufunc_beip_data, ufunc_beip_types, 2, 1, 1, 0, "beip", ufunc_beip_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ber_loops[2]
cdef void *ufunc_ber_ptr[4]
cdef void *ufunc_ber_data[2]
cdef char ufunc_ber_types[4]
cdef char *ufunc_ber_doc = (
    "ber(x, out=None)\n"
    "\n"
    "Kelvin function ber.\n"
    "\n"
    "Defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\mathrm{ber}(x) = \\Re[J_0(x e^{3 \\pi i / 4})]\n"
    "\n"
    "where :math:`J_0` is the Bessel function of the first kind of\n"
    "order zero (see `jv`). See [dlmf]_ for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the Kelvin function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bei : the corresponding real part\n"
    "berp : the derivative of bei\n"
    "jv : Bessel function of the first kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST, Digital Library of Mathematical Functions,\n"
    "    https://dlmf.nist.gov/10.61\n"
    "\n"
    "Examples\n"
    "--------\n"
    "It can be expressed using Bessel functions.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    ">>> x = np.array([1.0, 2.0, 3.0, 4.0])\n"
    ">>> sc.jv(0, x * np.exp(3 * np.pi * 1j / 4)).real\n"
    "array([ 0.98438178,  0.75173418, -0.22138025, -2.56341656])\n"
    ">>> sc.ber(x)\n"
    "array([ 0.98438178,  0.75173418, -0.22138025, -2.56341656])")
ufunc_ber_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ber_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ber_types[0] = <char>NPY_FLOAT
ufunc_ber_types[1] = <char>NPY_FLOAT
ufunc_ber_types[2] = <char>NPY_DOUBLE
ufunc_ber_types[3] = <char>NPY_DOUBLE
ufunc_ber_ptr[2*0] = <void*>_func_ber_wrap
ufunc_ber_ptr[2*0+1] = <void*>(<char*>"ber")
ufunc_ber_ptr[2*1] = <void*>_func_ber_wrap
ufunc_ber_ptr[2*1+1] = <void*>(<char*>"ber")
ufunc_ber_data[0] = &ufunc_ber_ptr[2*0]
ufunc_ber_data[1] = &ufunc_ber_ptr[2*1]
ber = np.PyUFunc_FromFuncAndData(ufunc_ber_loops, ufunc_ber_data, ufunc_ber_types, 2, 1, 1, 0, "ber", ufunc_ber_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_berp_loops[2]
cdef void *ufunc_berp_ptr[4]
cdef void *ufunc_berp_data[2]
cdef char ufunc_berp_types[4]
cdef char *ufunc_berp_doc = (
    "berp(x, out=None)\n"
    "\n"
    "Derivative of the Kelvin function ber.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The values of the derivative of ber.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ber\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST, Digital Library of Mathematical Functions,\n"
    "    https://dlmf.nist.gov/10#PT5")
ufunc_berp_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_berp_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_berp_types[0] = <char>NPY_FLOAT
ufunc_berp_types[1] = <char>NPY_FLOAT
ufunc_berp_types[2] = <char>NPY_DOUBLE
ufunc_berp_types[3] = <char>NPY_DOUBLE
ufunc_berp_ptr[2*0] = <void*>_func_berp_wrap
ufunc_berp_ptr[2*0+1] = <void*>(<char*>"berp")
ufunc_berp_ptr[2*1] = <void*>_func_berp_wrap
ufunc_berp_ptr[2*1+1] = <void*>(<char*>"berp")
ufunc_berp_data[0] = &ufunc_berp_ptr[2*0]
ufunc_berp_data[1] = &ufunc_berp_ptr[2*1]
berp = np.PyUFunc_FromFuncAndData(ufunc_berp_loops, ufunc_berp_data, ufunc_berp_types, 2, 1, 1, 0, "berp", ufunc_berp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_besselpoly_loops[2]
cdef void *ufunc_besselpoly_ptr[4]
cdef void *ufunc_besselpoly_data[2]
cdef char ufunc_besselpoly_types[8]
cdef char *ufunc_besselpoly_doc = (
    "besselpoly(a, lmb, nu, out=None)\n"
    "\n"
    "Weighted integral of the Bessel function of the first kind.\n"
    "\n"
    "Computes\n"
    "\n"
    ".. math::\n"
    "\n"
    "   \\int_0^1 x^\\lambda J_\\nu(2 a x) \\, dx\n"
    "\n"
    "where :math:`J_\\nu` is a Bessel function and :math:`\\lambda=lmb`,\n"
    ":math:`\\nu=nu`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Scale factor inside the Bessel function.\n"
    "lmb : array_like\n"
    "    Power of `x`\n"
    "nu : array_like\n"
    "    Order of the Bessel function.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the integral.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the function for one parameter set.\n"
    "\n"
    ">>> from scipy.special import besselpoly\n"
    ">>> besselpoly(1, 1, 1)\n"
    "0.24449718372863877\n"
    "\n"
    "Evaluate the function for different scale factors.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> factors = np.array([0., 3., 6.])\n"
    ">>> besselpoly(factors, 1, 1)\n"
    "array([ 0.        , -0.00549029,  0.00140174])\n"
    "\n"
    "Plot the function for varying powers, orders and scales.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> powers = np.linspace(0, 10, 100)\n"
    ">>> orders = [1, 2, 3]\n"
    ">>> scales = [1, 2]\n"
    ">>> all_combinations = [(order, scale) for order in orders\n"
    "...                     for scale in scales]\n"
    ">>> for order, scale in all_combinations:\n"
    "...     ax.plot(powers, besselpoly(scale, powers, order),\n"
    "...             label=rf\"$\\nu={order}, a={scale}$\")\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(r\"$\\lambda$\")\n"
    ">>> ax.set_ylabel(r\"$\\int_0^1 x^{\\lambda} J_{\\nu}(2ax)\\,dx$\")\n"
    ">>> plt.show()")
ufunc_besselpoly_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_besselpoly_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_besselpoly_types[0] = <char>NPY_FLOAT
ufunc_besselpoly_types[1] = <char>NPY_FLOAT
ufunc_besselpoly_types[2] = <char>NPY_FLOAT
ufunc_besselpoly_types[3] = <char>NPY_FLOAT
ufunc_besselpoly_types[4] = <char>NPY_DOUBLE
ufunc_besselpoly_types[5] = <char>NPY_DOUBLE
ufunc_besselpoly_types[6] = <char>NPY_DOUBLE
ufunc_besselpoly_types[7] = <char>NPY_DOUBLE
ufunc_besselpoly_ptr[2*0] = <void*>_func_besselpoly
ufunc_besselpoly_ptr[2*0+1] = <void*>(<char*>"besselpoly")
ufunc_besselpoly_ptr[2*1] = <void*>_func_besselpoly
ufunc_besselpoly_ptr[2*1+1] = <void*>(<char*>"besselpoly")
ufunc_besselpoly_data[0] = &ufunc_besselpoly_ptr[2*0]
ufunc_besselpoly_data[1] = &ufunc_besselpoly_ptr[2*1]
besselpoly = np.PyUFunc_FromFuncAndData(ufunc_besselpoly_loops, ufunc_besselpoly_data, ufunc_besselpoly_types, 2, 3, 1, 0, "besselpoly", ufunc_besselpoly_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_beta_loops[2]
cdef void *ufunc_beta_ptr[4]
cdef void *ufunc_beta_data[2]
cdef char ufunc_beta_types[6]
cdef char *ufunc_beta_doc = (
    "beta(a, b, out=None)\n"
    "\n"
    "Beta function.\n"
    "\n"
    "This function is defined in [1]_ as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    B(a, b) = \\int_0^1 t^{a-1}(1-t)^{b-1}dt\n"
    "            = \\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)},\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Real-valued arguments\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function result\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gamma : the gamma function\n"
    "betainc :  the regularized incomplete beta function\n"
    "betaln : the natural logarithm of the absolute\n"
    "         value of the beta function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions,\n"
    "       Eq. 5.12.1. https://dlmf.nist.gov/5.12\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "The beta function relates to the gamma function by the\n"
    "definition given above:\n"
    "\n"
    ">>> sc.beta(2, 3)\n"
    "0.08333333333333333\n"
    ">>> sc.gamma(2)*sc.gamma(3)/sc.gamma(2 + 3)\n"
    "0.08333333333333333\n"
    "\n"
    "As this relationship demonstrates, the beta function\n"
    "is symmetric:\n"
    "\n"
    ">>> sc.beta(1.7, 2.4)\n"
    "0.16567527689031739\n"
    ">>> sc.beta(2.4, 1.7)\n"
    "0.16567527689031739\n"
    "\n"
    "This function satisfies :math:`B(1, b) = 1/b`:\n"
    "\n"
    ">>> sc.beta(1, 4)\n"
    "0.25")
ufunc_beta_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_beta_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_beta_types[0] = <char>NPY_FLOAT
ufunc_beta_types[1] = <char>NPY_FLOAT
ufunc_beta_types[2] = <char>NPY_FLOAT
ufunc_beta_types[3] = <char>NPY_DOUBLE
ufunc_beta_types[4] = <char>NPY_DOUBLE
ufunc_beta_types[5] = <char>NPY_DOUBLE
ufunc_beta_ptr[2*0] = <void*>_func_beta
ufunc_beta_ptr[2*0+1] = <void*>(<char*>"beta")
ufunc_beta_ptr[2*1] = <void*>_func_beta
ufunc_beta_ptr[2*1+1] = <void*>(<char*>"beta")
ufunc_beta_data[0] = &ufunc_beta_ptr[2*0]
ufunc_beta_data[1] = &ufunc_beta_ptr[2*1]
beta = np.PyUFunc_FromFuncAndData(ufunc_beta_loops, ufunc_beta_data, ufunc_beta_types, 2, 2, 1, 0, "beta", ufunc_beta_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betainc_loops[2]
cdef void *ufunc_betainc_ptr[4]
cdef void *ufunc_betainc_data[2]
cdef char ufunc_betainc_types[8]
cdef char *ufunc_betainc_doc = (
    "betainc(a, b, x, out=None)\n"
    "\n"
    "Regularized incomplete beta function.\n"
    "\n"
    "Computes the regularized incomplete beta function, defined as [1]_:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    I_x(a, b) = \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)} \\int_0^x\n"
    "    t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "for :math:`0 \\leq x \\leq 1`.\n"
    "\n"
    "This function is the cumulative distribution function for the beta\n"
    "distribution; its range is [0, 1].\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "       Positive, real-valued parameters\n"
    "x : array_like\n"
    "    Real-valued such that :math:`0 \\leq x \\leq 1`,\n"
    "    the upper limit of integration\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "beta : beta function\n"
    "betaincinv : inverse of the regularized incomplete beta function\n"
    "betaincc : complement of the regularized incomplete beta function\n"
    "scipy.stats.beta : beta distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The term *regularized* in the name of this function refers to the\n"
    "scaling of the function by the gamma function terms shown in the\n"
    "formula.  When not qualified as *regularized*, the name *incomplete\n"
    "beta function* often refers to just the integral expression,\n"
    "without the gamma terms.  One can use the function `beta` from\n"
    "`scipy.special` to get this \"nonregularized\" incomplete beta\n"
    "function by multiplying the result of ``betainc(a, b, x)`` by\n"
    "``beta(a, b)``.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    "\n"
    "Examples\n"
    "--------\n"
    "\n"
    "Let :math:`B(a, b)` be the `beta` function.\n"
    "\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "The coefficient in terms of `gamma` is equal to\n"
    ":math:`1/B(a, b)`. Also, when :math:`x=1`\n"
    "the integral is equal to :math:`B(a, b)`.\n"
    "Therefore, :math:`I_{x=1}(a, b) = 1` for any :math:`a, b`.\n"
    "\n"
    ">>> sc.betainc(0.2, 3.5, 1.0)\n"
    "1.0\n"
    "\n"
    "It satisfies\n"
    ":math:`I_x(a, b) = x^a F(a, 1-b, a+1, x)/ (aB(a, b))`,\n"
    "where :math:`F` is the hypergeometric function `hyp2f1`:\n"
    "\n"
    ">>> a, b, x = 1.4, 3.1, 0.5\n"
    ">>> x**a * sc.hyp2f1(a, 1 - b, a + 1, x)/(a * sc.beta(a, b))\n"
    "0.8148904036225295\n"
    ">>> sc.betainc(a, b, x)\n"
    "0.8148904036225296\n"
    "\n"
    "This functions satisfies the relationship\n"
    ":math:`I_x(a, b) = 1 - I_{1-x}(b, a)`:\n"
    "\n"
    ">>> sc.betainc(2.2, 3.1, 0.4)\n"
    "0.49339638807619446\n"
    ">>> 1 - sc.betainc(3.1, 2.2, 1 - 0.4)\n"
    "0.49339638807619446")
ufunc_betainc_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betainc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betainc_types[0] = <char>NPY_FLOAT
ufunc_betainc_types[1] = <char>NPY_FLOAT
ufunc_betainc_types[2] = <char>NPY_FLOAT
ufunc_betainc_types[3] = <char>NPY_FLOAT
ufunc_betainc_types[4] = <char>NPY_DOUBLE
ufunc_betainc_types[5] = <char>NPY_DOUBLE
ufunc_betainc_types[6] = <char>NPY_DOUBLE
ufunc_betainc_types[7] = <char>NPY_DOUBLE
ufunc_betainc_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibeta_float
ufunc_betainc_ptr[2*0+1] = <void*>(<char*>"betainc")
ufunc_betainc_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibeta_double
ufunc_betainc_ptr[2*1+1] = <void*>(<char*>"betainc")
ufunc_betainc_data[0] = &ufunc_betainc_ptr[2*0]
ufunc_betainc_data[1] = &ufunc_betainc_ptr[2*1]
betainc = np.PyUFunc_FromFuncAndData(ufunc_betainc_loops, ufunc_betainc_data, ufunc_betainc_types, 2, 3, 1, 0, "betainc", ufunc_betainc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betaincc_loops[2]
cdef void *ufunc_betaincc_ptr[4]
cdef void *ufunc_betaincc_data[2]
cdef char ufunc_betaincc_types[8]
cdef char *ufunc_betaincc_doc = (
    "betaincc(a, b, x, out=None)\n"
    "\n"
    "Complement of the regularized incomplete beta function.\n"
    "\n"
    "Computes the complement of the regularized incomplete beta function,\n"
    "defined as [1]_:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\bar{I}_x(a, b) = 1 - I_x(a, b)\n"
    "                    = 1 - \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)} \\int_0^x\n"
    "                              t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "for :math:`0 \\leq x \\leq 1`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "       Positive, real-valued parameters\n"
    "x : array_like\n"
    "    Real-valued such that :math:`0 \\leq x \\leq 1`,\n"
    "    the upper limit of integration\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc : regularized incomplete beta function\n"
    "betaincinv : inverse of the regularized incomplete beta function\n"
    "betainccinv :\n"
    "    inverse of the complement of the regularized incomplete beta function\n"
    "beta : beta function\n"
    "scipy.stats.beta : beta distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 1.11.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import betaincc, betainc\n"
    "\n"
    "The naive calculation ``1 - betainc(a, b, x)`` loses precision when\n"
    "the values of ``betainc(a, b, x)`` are close to 1:\n"
    "\n"
    ">>> 1 - betainc(0.5, 8, [0.9, 0.99, 0.999])\n"
    "array([2.0574632e-09, 0.0000000e+00, 0.0000000e+00])\n"
    "\n"
    "By using ``betaincc``, we get the correct values:\n"
    "\n"
    ">>> betaincc(0.5, 8, [0.9, 0.99, 0.999])\n"
    "array([2.05746321e-09, 1.97259354e-17, 1.96467954e-25])")
ufunc_betaincc_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betaincc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betaincc_types[0] = <char>NPY_FLOAT
ufunc_betaincc_types[1] = <char>NPY_FLOAT
ufunc_betaincc_types[2] = <char>NPY_FLOAT
ufunc_betaincc_types[3] = <char>NPY_FLOAT
ufunc_betaincc_types[4] = <char>NPY_DOUBLE
ufunc_betaincc_types[5] = <char>NPY_DOUBLE
ufunc_betaincc_types[6] = <char>NPY_DOUBLE
ufunc_betaincc_types[7] = <char>NPY_DOUBLE
ufunc_betaincc_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibetac_float
ufunc_betaincc_ptr[2*0+1] = <void*>(<char*>"betaincc")
ufunc_betaincc_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibetac_double
ufunc_betaincc_ptr[2*1+1] = <void*>(<char*>"betaincc")
ufunc_betaincc_data[0] = &ufunc_betaincc_ptr[2*0]
ufunc_betaincc_data[1] = &ufunc_betaincc_ptr[2*1]
betaincc = np.PyUFunc_FromFuncAndData(ufunc_betaincc_loops, ufunc_betaincc_data, ufunc_betaincc_types, 2, 3, 1, 0, "betaincc", ufunc_betaincc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betainccinv_loops[2]
cdef void *ufunc_betainccinv_ptr[4]
cdef void *ufunc_betainccinv_data[2]
cdef char ufunc_betainccinv_types[8]
cdef char *ufunc_betainccinv_doc = (
    "betainccinv(a, b, y, out=None)\n"
    "\n"
    "Inverse of the complemented regularized incomplete beta function.\n"
    "\n"
    "Computes :math:`x` such that:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    y = 1 - I_x(a, b) = 1 - \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)}\n"
    "    \\int_0^x t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "where :math:`I_x` is the normalized incomplete beta function `betainc`\n"
    "and :math:`\\Gamma` is the `gamma` function [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Positive, real-valued parameters\n"
    "y : array_like\n"
    "    Real-valued input\n"
    "out : ndarray, optional\n"
    "    Optional output array for function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the inverse of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc : regularized incomplete beta function\n"
    "betaincc : complement of the regularized incomplete beta function\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 1.11.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import betainccinv, betaincc\n"
    "\n"
    "This function is the inverse of `betaincc` for fixed\n"
    "values of :math:`a` and :math:`b`.\n"
    "\n"
    ">>> a, b = 1.2, 3.1\n"
    ">>> y = betaincc(a, b, 0.2)\n"
    ">>> betainccinv(a, b, y)\n"
    "0.2\n"
    "\n"
    ">>> a, b = 7, 2.5\n"
    ">>> x = betainccinv(a, b, 0.875)\n"
    ">>> betaincc(a, b, x)\n"
    "0.875")
ufunc_betainccinv_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betainccinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betainccinv_types[0] = <char>NPY_FLOAT
ufunc_betainccinv_types[1] = <char>NPY_FLOAT
ufunc_betainccinv_types[2] = <char>NPY_FLOAT
ufunc_betainccinv_types[3] = <char>NPY_FLOAT
ufunc_betainccinv_types[4] = <char>NPY_DOUBLE
ufunc_betainccinv_types[5] = <char>NPY_DOUBLE
ufunc_betainccinv_types[6] = <char>NPY_DOUBLE
ufunc_betainccinv_types[7] = <char>NPY_DOUBLE
ufunc_betainccinv_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibetac_inv_float
ufunc_betainccinv_ptr[2*0+1] = <void*>(<char*>"betainccinv")
ufunc_betainccinv_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibetac_inv_double
ufunc_betainccinv_ptr[2*1+1] = <void*>(<char*>"betainccinv")
ufunc_betainccinv_data[0] = &ufunc_betainccinv_ptr[2*0]
ufunc_betainccinv_data[1] = &ufunc_betainccinv_ptr[2*1]
betainccinv = np.PyUFunc_FromFuncAndData(ufunc_betainccinv_loops, ufunc_betainccinv_data, ufunc_betainccinv_types, 2, 3, 1, 0, "betainccinv", ufunc_betainccinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betaincinv_loops[2]
cdef void *ufunc_betaincinv_ptr[4]
cdef void *ufunc_betaincinv_data[2]
cdef char ufunc_betaincinv_types[8]
cdef char *ufunc_betaincinv_doc = (
    "betaincinv(a, b, y, out=None)\n"
    "\n"
    "Inverse of the regularized incomplete beta function.\n"
    "\n"
    "Computes :math:`x` such that:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    y = I_x(a, b) = \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)}\n"
    "    \\int_0^x t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "where :math:`I_x` is the normalized incomplete beta function `betainc`\n"
    "and :math:`\\Gamma` is the `gamma` function [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Positive, real-valued parameters\n"
    "y : array_like\n"
    "    Real-valued input\n"
    "out : ndarray, optional\n"
    "    Optional output array for function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the inverse of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc : regularized incomplete beta function\n"
    "gamma : gamma function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "This function is the inverse of `betainc` for fixed\n"
    "values of :math:`a` and :math:`b`.\n"
    "\n"
    ">>> a, b = 1.2, 3.1\n"
    ">>> y = sc.betainc(a, b, 0.2)\n"
    ">>> sc.betaincinv(a, b, y)\n"
    "0.2\n"
    ">>>\n"
    ">>> a, b = 7.5, 0.4\n"
    ">>> x = sc.betaincinv(a, b, 0.5)\n"
    ">>> sc.betainc(a, b, x)\n"
    "0.5")
ufunc_betaincinv_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betaincinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betaincinv_types[0] = <char>NPY_FLOAT
ufunc_betaincinv_types[1] = <char>NPY_FLOAT
ufunc_betaincinv_types[2] = <char>NPY_FLOAT
ufunc_betaincinv_types[3] = <char>NPY_FLOAT
ufunc_betaincinv_types[4] = <char>NPY_DOUBLE
ufunc_betaincinv_types[5] = <char>NPY_DOUBLE
ufunc_betaincinv_types[6] = <char>NPY_DOUBLE
ufunc_betaincinv_types[7] = <char>NPY_DOUBLE
ufunc_betaincinv_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibeta_inv_float
ufunc_betaincinv_ptr[2*0+1] = <void*>(<char*>"betaincinv")
ufunc_betaincinv_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibeta_inv_double
ufunc_betaincinv_ptr[2*1+1] = <void*>(<char*>"betaincinv")
ufunc_betaincinv_data[0] = &ufunc_betaincinv_ptr[2*0]
ufunc_betaincinv_data[1] = &ufunc_betaincinv_ptr[2*1]
betaincinv = np.PyUFunc_FromFuncAndData(ufunc_betaincinv_loops, ufunc_betaincinv_data, ufunc_betaincinv_types, 2, 3, 1, 0, "betaincinv", ufunc_betaincinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betaln_loops[2]
cdef void *ufunc_betaln_ptr[4]
cdef void *ufunc_betaln_data[2]
cdef char ufunc_betaln_types[6]
cdef char *ufunc_betaln_doc = (
    "betaln(a, b, out=None)\n"
    "\n"
    "Natural logarithm of absolute value of beta function.\n"
    "\n"
    "Computes ``ln(abs(beta(a, b)))``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Positive, real-valued parameters\n"
    "out : ndarray, optional\n"
    "    Optional output array for function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the betaln function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gamma : the gamma function\n"
    "betainc :  the regularized incomplete beta function\n"
    "beta : the beta function\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import betaln, beta\n"
    "\n"
    "Verify that, for moderate values of ``a`` and ``b``, ``betaln(a, b)``\n"
    "is the same as ``log(beta(a, b))``:\n"
    "\n"
    ">>> betaln(3, 4)\n"
    "-4.0943445622221\n"
    "\n"
    ">>> np.log(beta(3, 4))\n"
    "-4.0943445622221\n"
    "\n"
    "In the following ``beta(a, b)`` underflows to 0, so we can't compute\n"
    "the logarithm of the actual value.\n"
    "\n"
    ">>> a = 400\n"
    ">>> b = 900\n"
    ">>> beta(a, b)\n"
    "0.0\n"
    "\n"
    "We can compute the logarithm of ``beta(a, b)`` by using `betaln`:\n"
    "\n"
    ">>> betaln(a, b)\n"
    "-804.3069951764146")
ufunc_betaln_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_betaln_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_betaln_types[0] = <char>NPY_FLOAT
ufunc_betaln_types[1] = <char>NPY_FLOAT
ufunc_betaln_types[2] = <char>NPY_FLOAT
ufunc_betaln_types[3] = <char>NPY_DOUBLE
ufunc_betaln_types[4] = <char>NPY_DOUBLE
ufunc_betaln_types[5] = <char>NPY_DOUBLE
ufunc_betaln_ptr[2*0] = <void*>_func_lbeta
ufunc_betaln_ptr[2*0+1] = <void*>(<char*>"betaln")
ufunc_betaln_ptr[2*1] = <void*>_func_lbeta
ufunc_betaln_ptr[2*1+1] = <void*>(<char*>"betaln")
ufunc_betaln_data[0] = &ufunc_betaln_ptr[2*0]
ufunc_betaln_data[1] = &ufunc_betaln_ptr[2*1]
betaln = np.PyUFunc_FromFuncAndData(ufunc_betaln_loops, ufunc_betaln_data, ufunc_betaln_types, 2, 2, 1, 0, "betaln", ufunc_betaln_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_binom_loops[2]
cdef void *ufunc_binom_ptr[4]
cdef void *ufunc_binom_data[2]
cdef char ufunc_binom_types[6]
cdef char *ufunc_binom_doc = (
    "binom(x, y, out=None)\n"
    "\n"
    "Binomial coefficient considered as a function of two real variables.\n"
    "\n"
    "For real arguments, the binomial coefficient is defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\binom{x}{y} = \\frac{\\Gamma(x + 1)}{\\Gamma(y + 1)\\Gamma(x - y + 1)} =\n"
    "        \\frac{1}{(x + 1)\\mathrm{B}(x - y + 1, y + 1)}\n"
    "\n"
    "Where :math:`\\Gamma` is the Gamma function (`gamma`) and :math:`\\mathrm{B}`\n"
    "is the Beta function (`beta`) [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y: array_like\n"
    "   Real arguments to :math:`\\binom{x}{y}`.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of binomial coefficient.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "comb : The number of combinations of N things taken k at a time.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The Gamma function has poles at non-positive integers and tends to either\n"
    "positive or negative infinity depending on the direction on the real line\n"
    "from which a pole is approached. When considered as a function of two real\n"
    "variables, :math:`\\binom{x}{y}` is thus undefined when `x` is a negative\n"
    "integer.  `binom` returns ``nan`` when ``x`` is a negative integer. This\n"
    "is the case even when ``x`` is a negative integer and ``y`` an integer,\n"
    "contrary to the usual convention for defining :math:`\\binom{n}{k}` when it\n"
    "is considered as a function of two integer variables.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] https://en.wikipedia.org/wiki/Binomial_coefficient\n"
    "\n"
    "Examples\n"
    "--------\n"
    "The following examples illustrate the ways in which `binom` differs from\n"
    "the function `comb`.\n"
    "\n"
    ">>> from scipy.special import binom, comb\n"
    "\n"
    "When ``exact=False`` and ``x`` and ``y`` are both positive, `comb` calls\n"
    "`binom` internally.\n"
    "\n"
    ">>> x, y = 3, 2\n"
    ">>> (binom(x, y), comb(x, y), comb(x, y, exact=True))\n"
    "(3.0, 3.0, 3)\n"
    "\n"
    "For larger values, `comb` with ``exact=True`` no longer agrees\n"
    "with `binom`.\n"
    "\n"
    ">>> x, y = 43, 23\n"
    ">>> (binom(x, y), comb(x, y), comb(x, y, exact=True))\n"
    "(960566918219.9999, 960566918219.9999, 960566918220)\n"
    "\n"
    "`binom` returns ``nan`` when ``x`` is a negative integer, but is otherwise\n"
    "defined for negative arguments. `comb` returns 0 whenever one of ``x`` or\n"
    "``y`` is negative or ``x`` is less than ``y``.\n"
    "\n"
    ">>> x, y = -3, 2\n"
    ">>> (binom(x, y), comb(x, y), comb(x, y, exact=True))\n"
    "(nan, 0.0, 0)\n"
    "\n"
    ">>> x, y = -3.1, 2.2\n"
    ">>> (binom(x, y), comb(x, y), comb(x, y, exact=True))\n"
    "(18.714147876804432, 0.0, 0)\n"
    "\n"
    ">>> x, y = 2.2, 3.1\n"
    ">>> (binom(x, y), comb(x, y), comb(x, y, exact=True))\n"
    "(0.037399983365134115, 0.0, 0)")
ufunc_binom_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_binom_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_binom_types[0] = <char>NPY_FLOAT
ufunc_binom_types[1] = <char>NPY_FLOAT
ufunc_binom_types[2] = <char>NPY_FLOAT
ufunc_binom_types[3] = <char>NPY_DOUBLE
ufunc_binom_types[4] = <char>NPY_DOUBLE
ufunc_binom_types[5] = <char>NPY_DOUBLE
ufunc_binom_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_binom
ufunc_binom_ptr[2*0+1] = <void*>(<char*>"binom")
ufunc_binom_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_binom
ufunc_binom_ptr[2*1+1] = <void*>(<char*>"binom")
ufunc_binom_data[0] = &ufunc_binom_ptr[2*0]
ufunc_binom_data[1] = &ufunc_binom_ptr[2*1]
binom = np.PyUFunc_FromFuncAndData(ufunc_binom_loops, ufunc_binom_data, ufunc_binom_types, 2, 2, 1, 0, "binom", ufunc_binom_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_boxcox_loops[2]
cdef void *ufunc_boxcox_ptr[4]
cdef void *ufunc_boxcox_data[2]
cdef char ufunc_boxcox_types[6]
cdef char *ufunc_boxcox_doc = (
    "boxcox(x, lmbda, out=None)\n"
    "\n"
    "Compute the Box-Cox transformation.\n"
    "\n"
    "The Box-Cox transformation is::\n"
    "\n"
    "    y = (x**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(x)                  if lmbda == 0\n"
    "\n"
    "Returns `nan` if ``x < 0``.\n"
    "Returns `-inf` if ``x == 0`` and ``lmbda < 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.14.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox\n"
    ">>> boxcox([1, 4, 10], 2.5)\n"
    "array([   0.        ,   12.4       ,  126.09110641])\n"
    ">>> boxcox(2, [0, 1, 2])\n"
    "array([ 0.69314718,  1.        ,  1.5       ])")
ufunc_boxcox_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_boxcox_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_boxcox_types[0] = <char>NPY_FLOAT
ufunc_boxcox_types[1] = <char>NPY_FLOAT
ufunc_boxcox_types[2] = <char>NPY_FLOAT
ufunc_boxcox_types[3] = <char>NPY_DOUBLE
ufunc_boxcox_types[4] = <char>NPY_DOUBLE
ufunc_boxcox_types[5] = <char>NPY_DOUBLE
ufunc_boxcox_ptr[2*0] = <void*>_func_boxcox
ufunc_boxcox_ptr[2*0+1] = <void*>(<char*>"boxcox")
ufunc_boxcox_ptr[2*1] = <void*>_func_boxcox
ufunc_boxcox_ptr[2*1+1] = <void*>(<char*>"boxcox")
ufunc_boxcox_data[0] = &ufunc_boxcox_ptr[2*0]
ufunc_boxcox_data[1] = &ufunc_boxcox_ptr[2*1]
boxcox = np.PyUFunc_FromFuncAndData(ufunc_boxcox_loops, ufunc_boxcox_data, ufunc_boxcox_types, 2, 2, 1, 0, "boxcox", ufunc_boxcox_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_boxcox1p_loops[2]
cdef void *ufunc_boxcox1p_ptr[4]
cdef void *ufunc_boxcox1p_data[2]
cdef char ufunc_boxcox1p_types[6]
cdef char *ufunc_boxcox1p_doc = (
    "boxcox1p(x, lmbda, out=None)\n"
    "\n"
    "Compute the Box-Cox transformation of 1 + `x`.\n"
    "\n"
    "The Box-Cox transformation computed by `boxcox1p` is::\n"
    "\n"
    "    y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(1+x)                    if lmbda == 0\n"
    "\n"
    "Returns `nan` if ``x < -1``.\n"
    "Returns `-inf` if ``x == -1`` and ``lmbda < 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.14.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox1p\n"
    ">>> boxcox1p(1e-4, [0, 0.5, 1])\n"
    "array([  9.99950003e-05,   9.99975001e-05,   1.00000000e-04])\n"
    ">>> boxcox1p([0.01, 0.1], 0.25)\n"
    "array([ 0.00996272,  0.09645476])")
ufunc_boxcox1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_boxcox1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_boxcox1p_types[0] = <char>NPY_FLOAT
ufunc_boxcox1p_types[1] = <char>NPY_FLOAT
ufunc_boxcox1p_types[2] = <char>NPY_FLOAT
ufunc_boxcox1p_types[3] = <char>NPY_DOUBLE
ufunc_boxcox1p_types[4] = <char>NPY_DOUBLE
ufunc_boxcox1p_types[5] = <char>NPY_DOUBLE
ufunc_boxcox1p_ptr[2*0] = <void*>_func_boxcox1p
ufunc_boxcox1p_ptr[2*0+1] = <void*>(<char*>"boxcox1p")
ufunc_boxcox1p_ptr[2*1] = <void*>_func_boxcox1p
ufunc_boxcox1p_ptr[2*1+1] = <void*>(<char*>"boxcox1p")
ufunc_boxcox1p_data[0] = &ufunc_boxcox1p_ptr[2*0]
ufunc_boxcox1p_data[1] = &ufunc_boxcox1p_ptr[2*1]
boxcox1p = np.PyUFunc_FromFuncAndData(ufunc_boxcox1p_loops, ufunc_boxcox1p_data, ufunc_boxcox1p_types, 2, 2, 1, 0, "boxcox1p", ufunc_boxcox1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtr_loops[2]
cdef void *ufunc_btdtr_ptr[4]
cdef void *ufunc_btdtr_data[2]
cdef char ufunc_btdtr_types[8]
cdef char *ufunc_btdtr_doc = (
    "btdtr(a, b, x, out=None)\n"
    "\n"
    "Cumulative distribution function of the beta distribution.\n"
    "\n"
    "Returns the integral from zero to `x` of the beta probability density\n"
    "function,\n"
    "\n"
    ".. math::\n"
    "    I = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    ".. deprecated:: 1.12.0\n"
    "    This function is deprecated and will be removed from SciPy 1.14.0.\n"
    "    Use `scipy.special.betainc` instead.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Shape parameter (a > 0).\n"
    "b : array_like\n"
    "    Shape parameter (b > 0).\n"
    "x : array_like\n"
    "    Upper limit of integration, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : scalar or ndarray\n"
    "    Cumulative distribution function of the beta distribution with\n"
    "    parameters `a` and `b` at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function is identical to the incomplete beta integral function\n"
    "`betainc`.\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `btdtr`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_btdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtr_types[0] = <char>NPY_FLOAT
ufunc_btdtr_types[1] = <char>NPY_FLOAT
ufunc_btdtr_types[2] = <char>NPY_FLOAT
ufunc_btdtr_types[3] = <char>NPY_FLOAT
ufunc_btdtr_types[4] = <char>NPY_DOUBLE
ufunc_btdtr_types[5] = <char>NPY_DOUBLE
ufunc_btdtr_types[6] = <char>NPY_DOUBLE
ufunc_btdtr_types[7] = <char>NPY_DOUBLE
ufunc_btdtr_ptr[2*0] = <void*>_func_btdtr
ufunc_btdtr_ptr[2*0+1] = <void*>(<char*>"btdtr")
ufunc_btdtr_ptr[2*1] = <void*>_func_btdtr
ufunc_btdtr_ptr[2*1+1] = <void*>(<char*>"btdtr")
ufunc_btdtr_data[0] = &ufunc_btdtr_ptr[2*0]
ufunc_btdtr_data[1] = &ufunc_btdtr_ptr[2*1]
btdtr = np.PyUFunc_FromFuncAndData(ufunc_btdtr_loops, ufunc_btdtr_data, ufunc_btdtr_types, 2, 3, 1, 0, "btdtr", ufunc_btdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtri_loops[2]
cdef void *ufunc_btdtri_ptr[4]
cdef void *ufunc_btdtri_data[2]
cdef char ufunc_btdtri_types[8]
cdef char *ufunc_btdtri_doc = (
    "btdtri(a, b, p, out=None)\n"
    "\n"
    "The `p`-th quantile of the beta distribution.\n"
    "\n"
    "This function is the inverse of the beta cumulative distribution function,\n"
    "`btdtr`, returning the value of `x` for which `btdtr(a, b, x) = p`, or\n"
    "\n"
    ".. math::\n"
    "    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    ".. deprecated:: 1.12.0\n"
    "    This function is deprecated and will be removed from SciPy 1.14.0.\n"
    "    Use `scipy.special.betaincinv` instead.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Shape parameter (`a` > 0).\n"
    "b : array_like\n"
    "    Shape parameter (`b` > 0).\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    The quantile corresponding to `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betaincinv\n"
    "btdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The value of `x` is found by interval halving or Newton iterations.\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `incbi`, which solves the equivalent\n"
    "problem of finding the inverse of the incomplete beta integral.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_btdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtri_types[0] = <char>NPY_FLOAT
ufunc_btdtri_types[1] = <char>NPY_FLOAT
ufunc_btdtri_types[2] = <char>NPY_FLOAT
ufunc_btdtri_types[3] = <char>NPY_FLOAT
ufunc_btdtri_types[4] = <char>NPY_DOUBLE
ufunc_btdtri_types[5] = <char>NPY_DOUBLE
ufunc_btdtri_types[6] = <char>NPY_DOUBLE
ufunc_btdtri_types[7] = <char>NPY_DOUBLE
ufunc_btdtri_ptr[2*0] = <void*>_func_incbi
ufunc_btdtri_ptr[2*0+1] = <void*>(<char*>"btdtri")
ufunc_btdtri_ptr[2*1] = <void*>_func_incbi
ufunc_btdtri_ptr[2*1+1] = <void*>(<char*>"btdtri")
ufunc_btdtri_data[0] = &ufunc_btdtri_ptr[2*0]
ufunc_btdtri_data[1] = &ufunc_btdtri_ptr[2*1]
btdtri = np.PyUFunc_FromFuncAndData(ufunc_btdtri_loops, ufunc_btdtri_data, ufunc_btdtri_types, 2, 3, 1, 0, "btdtri", ufunc_btdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtria_loops[2]
cdef void *ufunc_btdtria_ptr[4]
cdef void *ufunc_btdtria_data[2]
cdef char ufunc_btdtria_types[8]
cdef char *ufunc_btdtria_doc = (
    "btdtria(p, b, x, out=None)\n"
    "\n"
    "Inverse of `btdtr` with respect to `a`.\n"
    "\n"
    "This is the inverse of the beta cumulative distribution function, `btdtr`,\n"
    "considered as a function of `a`, returning the value of `a` for which\n"
    "`btdtr(a, b, x) = p`, or\n"
    "\n"
    ".. math::\n"
    "    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "b : array_like\n"
    "    Shape parameter (`b` > 0).\n"
    "x : array_like\n"
    "    The quantile, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "a : scalar or ndarray\n"
    "    The value of the shape parameter `a` such that `btdtr(a, b, x) = p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "btdtr : Cumulative distribution function of the beta distribution.\n"
    "btdtri : Inverse with respect to `x`.\n"
    "btdtrib : Inverse with respect to `b`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_. Computation of `a` involves a search for a value\n"
    "that produces the desired value of `p`. The search relies on the\n"
    "monotonicity of `p` with `a`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Algorithm 708: Significant Digit Computation of the Incomplete Beta\n"
    "       Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.")
ufunc_btdtria_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtria_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtria_types[0] = <char>NPY_FLOAT
ufunc_btdtria_types[1] = <char>NPY_FLOAT
ufunc_btdtria_types[2] = <char>NPY_FLOAT
ufunc_btdtria_types[3] = <char>NPY_FLOAT
ufunc_btdtria_types[4] = <char>NPY_DOUBLE
ufunc_btdtria_types[5] = <char>NPY_DOUBLE
ufunc_btdtria_types[6] = <char>NPY_DOUBLE
ufunc_btdtria_types[7] = <char>NPY_DOUBLE
ufunc_btdtria_ptr[2*0] = <void*>_func_cdfbet3_wrap
ufunc_btdtria_ptr[2*0+1] = <void*>(<char*>"btdtria")
ufunc_btdtria_ptr[2*1] = <void*>_func_cdfbet3_wrap
ufunc_btdtria_ptr[2*1+1] = <void*>(<char*>"btdtria")
ufunc_btdtria_data[0] = &ufunc_btdtria_ptr[2*0]
ufunc_btdtria_data[1] = &ufunc_btdtria_ptr[2*1]
btdtria = np.PyUFunc_FromFuncAndData(ufunc_btdtria_loops, ufunc_btdtria_data, ufunc_btdtria_types, 2, 3, 1, 0, "btdtria", ufunc_btdtria_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtrib_loops[2]
cdef void *ufunc_btdtrib_ptr[4]
cdef void *ufunc_btdtrib_data[2]
cdef char ufunc_btdtrib_types[8]
cdef char *ufunc_btdtrib_doc = (
    "btdtria(a, p, x, out=None)\n"
    "\n"
    "Inverse of `btdtr` with respect to `b`.\n"
    "\n"
    "This is the inverse of the beta cumulative distribution function, `btdtr`,\n"
    "considered as a function of `b`, returning the value of `b` for which\n"
    "`btdtr(a, b, x) = p`, or\n"
    "\n"
    ".. math::\n"
    "    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Shape parameter (`a` > 0).\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "x : array_like\n"
    "    The quantile, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "b : scalar or ndarray\n"
    "    The value of the shape parameter `b` such that `btdtr(a, b, x) = p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "btdtr : Cumulative distribution function of the beta distribution.\n"
    "btdtri : Inverse with respect to `x`.\n"
    "btdtria : Inverse with respect to `a`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_. Computation of `b` involves a search for a value\n"
    "that produces the desired value of `p`. The search relies on the\n"
    "monotonicity of `p` with `b`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Algorithm 708: Significant Digit Computation of the Incomplete Beta\n"
    "       Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.")
ufunc_btdtrib_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtrib_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtrib_types[0] = <char>NPY_FLOAT
ufunc_btdtrib_types[1] = <char>NPY_FLOAT
ufunc_btdtrib_types[2] = <char>NPY_FLOAT
ufunc_btdtrib_types[3] = <char>NPY_FLOAT
ufunc_btdtrib_types[4] = <char>NPY_DOUBLE
ufunc_btdtrib_types[5] = <char>NPY_DOUBLE
ufunc_btdtrib_types[6] = <char>NPY_DOUBLE
ufunc_btdtrib_types[7] = <char>NPY_DOUBLE
ufunc_btdtrib_ptr[2*0] = <void*>_func_cdfbet4_wrap
ufunc_btdtrib_ptr[2*0+1] = <void*>(<char*>"btdtrib")
ufunc_btdtrib_ptr[2*1] = <void*>_func_cdfbet4_wrap
ufunc_btdtrib_ptr[2*1+1] = <void*>(<char*>"btdtrib")
ufunc_btdtrib_data[0] = &ufunc_btdtrib_ptr[2*0]
ufunc_btdtrib_data[1] = &ufunc_btdtrib_ptr[2*1]
btdtrib = np.PyUFunc_FromFuncAndData(ufunc_btdtrib_loops, ufunc_btdtrib_data, ufunc_btdtrib_types, 2, 3, 1, 0, "btdtrib", ufunc_btdtrib_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cbrt_loops[2]
cdef void *ufunc_cbrt_ptr[4]
cdef void *ufunc_cbrt_data[2]
cdef char ufunc_cbrt_types[4]
cdef char *ufunc_cbrt_doc = (
    "cbrt(x, out=None)\n"
    "\n"
    "Element-wise cube root of `x`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    `x` must contain real numbers.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The cube root of each value in `x`.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import cbrt\n"
    "\n"
    ">>> cbrt(8)\n"
    "2.0\n"
    ">>> cbrt([-8, -3, 0.125, 1.331])\n"
    "array([-2.        , -1.44224957,  0.5       ,  1.1       ])")
ufunc_cbrt_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cbrt_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cbrt_types[0] = <char>NPY_FLOAT
ufunc_cbrt_types[1] = <char>NPY_FLOAT
ufunc_cbrt_types[2] = <char>NPY_DOUBLE
ufunc_cbrt_types[3] = <char>NPY_DOUBLE
ufunc_cbrt_ptr[2*0] = <void*>_func_cbrt
ufunc_cbrt_ptr[2*0+1] = <void*>(<char*>"cbrt")
ufunc_cbrt_ptr[2*1] = <void*>_func_cbrt
ufunc_cbrt_ptr[2*1+1] = <void*>(<char*>"cbrt")
ufunc_cbrt_data[0] = &ufunc_cbrt_ptr[2*0]
ufunc_cbrt_data[1] = &ufunc_cbrt_ptr[2*1]
cbrt = np.PyUFunc_FromFuncAndData(ufunc_cbrt_loops, ufunc_cbrt_data, ufunc_cbrt_types, 2, 1, 1, 0, "cbrt", ufunc_cbrt_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtr_loops[2]
cdef void *ufunc_chdtr_ptr[4]
cdef void *ufunc_chdtr_data[2]
cdef char ufunc_chdtr_types[6]
cdef char *ufunc_chdtr_doc = (
    "chdtr(v, x, out=None)\n"
    "\n"
    "Chi square cumulative distribution function.\n"
    "\n"
    "Returns the area under the left tail (from 0 to `x`) of the Chi\n"
    "square probability density function with `v` degrees of freedom:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\frac{1}{2^{v/2} \\Gamma(v/2)} \\int_0^x t^{v/2 - 1} e^{-t/2} dt\n"
    "\n"
    "Here :math:`\\Gamma` is the Gamma function; see `gamma`. This\n"
    "integral can be expressed in terms of the regularized lower\n"
    "incomplete gamma function `gammainc` as\n"
    "``gammainc(v / 2, x / 2)``. [1]_\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Degrees of freedom.\n"
    "x : array_like\n"
    "    Upper bound of the integral.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the cumulative distribution function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtrc, chdtri, chdtriv, gammainc\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It can be expressed in terms of the regularized lower incomplete\n"
    "gamma function.\n"
    "\n"
    ">>> v = 1\n"
    ">>> x = np.arange(4)\n"
    ">>> sc.chdtr(v, x)\n"
    "array([0.        , 0.68268949, 0.84270079, 0.91673548])\n"
    ">>> sc.gammainc(v / 2, x / 2)\n"
    "array([0.        , 0.68268949, 0.84270079, 0.91673548])")
ufunc_chdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtr_types[0] = <char>NPY_FLOAT
ufunc_chdtr_types[1] = <char>NPY_FLOAT
ufunc_chdtr_types[2] = <char>NPY_FLOAT
ufunc_chdtr_types[3] = <char>NPY_DOUBLE
ufunc_chdtr_types[4] = <char>NPY_DOUBLE
ufunc_chdtr_types[5] = <char>NPY_DOUBLE
ufunc_chdtr_ptr[2*0] = <void*>_func_chdtr
ufunc_chdtr_ptr[2*0+1] = <void*>(<char*>"chdtr")
ufunc_chdtr_ptr[2*1] = <void*>_func_chdtr
ufunc_chdtr_ptr[2*1+1] = <void*>(<char*>"chdtr")
ufunc_chdtr_data[0] = &ufunc_chdtr_ptr[2*0]
ufunc_chdtr_data[1] = &ufunc_chdtr_ptr[2*1]
chdtr = np.PyUFunc_FromFuncAndData(ufunc_chdtr_loops, ufunc_chdtr_data, ufunc_chdtr_types, 2, 2, 1, 0, "chdtr", ufunc_chdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtrc_loops[2]
cdef void *ufunc_chdtrc_ptr[4]
cdef void *ufunc_chdtrc_data[2]
cdef char ufunc_chdtrc_types[6]
cdef char *ufunc_chdtrc_doc = (
    "chdtrc(v, x, out=None)\n"
    "\n"
    "Chi square survival function.\n"
    "\n"
    "Returns the area under the right hand tail (from `x` to infinity)\n"
    "of the Chi square probability density function with `v` degrees of\n"
    "freedom:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\frac{1}{2^{v/2} \\Gamma(v/2)} \\int_x^\\infty t^{v/2 - 1} e^{-t/2} dt\n"
    "\n"
    "Here :math:`\\Gamma` is the Gamma function; see `gamma`. This\n"
    "integral can be expressed in terms of the regularized upper\n"
    "incomplete gamma function `gammaincc` as\n"
    "``gammaincc(v / 2, x / 2)``. [1]_\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Degrees of freedom.\n"
    "x : array_like\n"
    "    Lower bound of the integral.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the survival function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtr, chdtri, chdtriv, gammaincc\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It can be expressed in terms of the regularized upper incomplete\n"
    "gamma function.\n"
    "\n"
    ">>> v = 1\n"
    ">>> x = np.arange(4)\n"
    ">>> sc.chdtrc(v, x)\n"
    "array([1.        , 0.31731051, 0.15729921, 0.08326452])\n"
    ">>> sc.gammaincc(v / 2, x / 2)\n"
    "array([1.        , 0.31731051, 0.15729921, 0.08326452])")
ufunc_chdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtrc_types[0] = <char>NPY_FLOAT
ufunc_chdtrc_types[1] = <char>NPY_FLOAT
ufunc_chdtrc_types[2] = <char>NPY_FLOAT
ufunc_chdtrc_types[3] = <char>NPY_DOUBLE
ufunc_chdtrc_types[4] = <char>NPY_DOUBLE
ufunc_chdtrc_types[5] = <char>NPY_DOUBLE
ufunc_chdtrc_ptr[2*0] = <void*>_func_chdtrc
ufunc_chdtrc_ptr[2*0+1] = <void*>(<char*>"chdtrc")
ufunc_chdtrc_ptr[2*1] = <void*>_func_chdtrc
ufunc_chdtrc_ptr[2*1+1] = <void*>(<char*>"chdtrc")
ufunc_chdtrc_data[0] = &ufunc_chdtrc_ptr[2*0]
ufunc_chdtrc_data[1] = &ufunc_chdtrc_ptr[2*1]
chdtrc = np.PyUFunc_FromFuncAndData(ufunc_chdtrc_loops, ufunc_chdtrc_data, ufunc_chdtrc_types, 2, 2, 1, 0, "chdtrc", ufunc_chdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtri_loops[2]
cdef void *ufunc_chdtri_ptr[4]
cdef void *ufunc_chdtri_data[2]
cdef char ufunc_chdtri_types[6]
cdef char *ufunc_chdtri_doc = (
    "chdtri(v, p, out=None)\n"
    "\n"
    "Inverse to `chdtrc` with respect to `x`.\n"
    "\n"
    "Returns `x` such that ``chdtrc(v, x) == p``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Degrees of freedom.\n"
    "p : array_like\n"
    "    Probability.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Value so that the probability a Chi square random variable\n"
    "    with `v` degrees of freedom is greater than `x` equals `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtrc, chdtr, chdtriv\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It inverts `chdtrc`.\n"
    "\n"
    ">>> v, p = 1, 0.3\n"
    ">>> sc.chdtrc(v, sc.chdtri(v, p))\n"
    "0.3\n"
    ">>> x = 1\n"
    ">>> sc.chdtri(v, sc.chdtrc(v, x))\n"
    "1.0")
ufunc_chdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtri_types[0] = <char>NPY_FLOAT
ufunc_chdtri_types[1] = <char>NPY_FLOAT
ufunc_chdtri_types[2] = <char>NPY_FLOAT
ufunc_chdtri_types[3] = <char>NPY_DOUBLE
ufunc_chdtri_types[4] = <char>NPY_DOUBLE
ufunc_chdtri_types[5] = <char>NPY_DOUBLE
ufunc_chdtri_ptr[2*0] = <void*>_func_chdtri
ufunc_chdtri_ptr[2*0+1] = <void*>(<char*>"chdtri")
ufunc_chdtri_ptr[2*1] = <void*>_func_chdtri
ufunc_chdtri_ptr[2*1+1] = <void*>(<char*>"chdtri")
ufunc_chdtri_data[0] = &ufunc_chdtri_ptr[2*0]
ufunc_chdtri_data[1] = &ufunc_chdtri_ptr[2*1]
chdtri = np.PyUFunc_FromFuncAndData(ufunc_chdtri_loops, ufunc_chdtri_data, ufunc_chdtri_types, 2, 2, 1, 0, "chdtri", ufunc_chdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtriv_loops[2]
cdef void *ufunc_chdtriv_ptr[4]
cdef void *ufunc_chdtriv_data[2]
cdef char ufunc_chdtriv_types[6]
cdef char *ufunc_chdtriv_doc = (
    "chdtriv(p, x, out=None)\n"
    "\n"
    "Inverse to `chdtr` with respect to `v`.\n"
    "\n"
    "Returns `v` such that ``chdtr(v, x) == p``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability that the Chi square random variable is less than\n"
    "    or equal to `x`.\n"
    "x : array_like\n"
    "    Nonnegative input.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Degrees of freedom.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtr, chdtrc, chdtri\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It inverts `chdtr`.\n"
    "\n"
    ">>> p, x = 0.5, 1\n"
    ">>> sc.chdtr(sc.chdtriv(p, x), x)\n"
    "0.5000000000202172\n"
    ">>> v = 1\n"
    ">>> sc.chdtriv(sc.chdtr(v, x), v)\n"
    "1.0000000000000013")
ufunc_chdtriv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtriv_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtriv_types[0] = <char>NPY_FLOAT
ufunc_chdtriv_types[1] = <char>NPY_FLOAT
ufunc_chdtriv_types[2] = <char>NPY_FLOAT
ufunc_chdtriv_types[3] = <char>NPY_DOUBLE
ufunc_chdtriv_types[4] = <char>NPY_DOUBLE
ufunc_chdtriv_types[5] = <char>NPY_DOUBLE
ufunc_chdtriv_ptr[2*0] = <void*>_func_cdfchi3_wrap
ufunc_chdtriv_ptr[2*0+1] = <void*>(<char*>"chdtriv")
ufunc_chdtriv_ptr[2*1] = <void*>_func_cdfchi3_wrap
ufunc_chdtriv_ptr[2*1+1] = <void*>(<char*>"chdtriv")
ufunc_chdtriv_data[0] = &ufunc_chdtriv_ptr[2*0]
ufunc_chdtriv_data[1] = &ufunc_chdtriv_ptr[2*1]
chdtriv = np.PyUFunc_FromFuncAndData(ufunc_chdtriv_loops, ufunc_chdtriv_data, ufunc_chdtriv_types, 2, 2, 1, 0, "chdtriv", ufunc_chdtriv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtr_loops[2]
cdef void *ufunc_chndtr_ptr[4]
cdef void *ufunc_chndtr_data[2]
cdef char ufunc_chndtr_types[8]
cdef char *ufunc_chndtr_doc = (
    "chndtr(x, df, nc, out=None)\n"
    "\n"
    "Non-central chi square cumulative distribution function\n"
    "\n"
    "The cumulative distribution function is given by:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P(\\chi^{\\prime 2} \\vert \\nu, \\lambda) =\\sum_{j=0}^{\\infty}\n"
    "    e^{-\\lambda /2}\n"
    "    \\frac{(\\lambda /2)^j}{j!} P(\\chi^{\\prime 2} \\vert \\nu + 2j),\n"
    "\n"
    "where :math:`\\nu > 0` is the degrees of freedom (``df``) and\n"
    ":math:`\\lambda \\geq 0` is the non-centrality parameter (``nc``).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper bound of the integral; must satisfy ``x >= 0``\n"
    "df : array_like\n"
    "    Degrees of freedom; must satisfy ``df > 0``\n"
    "nc : array_like\n"
    "    Non-centrality parameter; must satisfy ``nc >= 0``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Value of the non-central chi square cumulative distribution function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtrix, chndtridf, chndtrinc")
ufunc_chndtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtr_types[0] = <char>NPY_FLOAT
ufunc_chndtr_types[1] = <char>NPY_FLOAT
ufunc_chndtr_types[2] = <char>NPY_FLOAT
ufunc_chndtr_types[3] = <char>NPY_FLOAT
ufunc_chndtr_types[4] = <char>NPY_DOUBLE
ufunc_chndtr_types[5] = <char>NPY_DOUBLE
ufunc_chndtr_types[6] = <char>NPY_DOUBLE
ufunc_chndtr_types[7] = <char>NPY_DOUBLE
ufunc_chndtr_ptr[2*0] = <void*>_func_cdfchn1_wrap
ufunc_chndtr_ptr[2*0+1] = <void*>(<char*>"chndtr")
ufunc_chndtr_ptr[2*1] = <void*>_func_cdfchn1_wrap
ufunc_chndtr_ptr[2*1+1] = <void*>(<char*>"chndtr")
ufunc_chndtr_data[0] = &ufunc_chndtr_ptr[2*0]
ufunc_chndtr_data[1] = &ufunc_chndtr_ptr[2*1]
chndtr = np.PyUFunc_FromFuncAndData(ufunc_chndtr_loops, ufunc_chndtr_data, ufunc_chndtr_types, 2, 3, 1, 0, "chndtr", ufunc_chndtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtridf_loops[2]
cdef void *ufunc_chndtridf_ptr[4]
cdef void *ufunc_chndtridf_data[2]
cdef char ufunc_chndtridf_types[8]
cdef char *ufunc_chndtridf_doc = (
    "chndtridf(x, p, nc, out=None)\n"
    "\n"
    "Inverse to `chndtr` vs `df`\n"
    "\n"
    "Calculated using a search to find a value for `df` that produces the\n"
    "desired value of `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper bound of the integral; must satisfy ``x >= 0``\n"
    "p : array_like\n"
    "    Probability; must satisfy ``0 <= p < 1``\n"
    "nc : array_like\n"
    "    Non-centrality parameter; must satisfy ``nc >= 0``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "df : scalar or ndarray\n"
    "    Degrees of freedom\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtr, chndtrix, chndtrinc")
ufunc_chndtridf_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtridf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtridf_types[0] = <char>NPY_FLOAT
ufunc_chndtridf_types[1] = <char>NPY_FLOAT
ufunc_chndtridf_types[2] = <char>NPY_FLOAT
ufunc_chndtridf_types[3] = <char>NPY_FLOAT
ufunc_chndtridf_types[4] = <char>NPY_DOUBLE
ufunc_chndtridf_types[5] = <char>NPY_DOUBLE
ufunc_chndtridf_types[6] = <char>NPY_DOUBLE
ufunc_chndtridf_types[7] = <char>NPY_DOUBLE
ufunc_chndtridf_ptr[2*0] = <void*>_func_cdfchn3_wrap
ufunc_chndtridf_ptr[2*0+1] = <void*>(<char*>"chndtridf")
ufunc_chndtridf_ptr[2*1] = <void*>_func_cdfchn3_wrap
ufunc_chndtridf_ptr[2*1+1] = <void*>(<char*>"chndtridf")
ufunc_chndtridf_data[0] = &ufunc_chndtridf_ptr[2*0]
ufunc_chndtridf_data[1] = &ufunc_chndtridf_ptr[2*1]
chndtridf = np.PyUFunc_FromFuncAndData(ufunc_chndtridf_loops, ufunc_chndtridf_data, ufunc_chndtridf_types, 2, 3, 1, 0, "chndtridf", ufunc_chndtridf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtrinc_loops[2]
cdef void *ufunc_chndtrinc_ptr[4]
cdef void *ufunc_chndtrinc_data[2]
cdef char ufunc_chndtrinc_types[8]
cdef char *ufunc_chndtrinc_doc = (
    "chndtrinc(x, df, p, out=None)\n"
    "\n"
    "Inverse to `chndtr` vs `nc`\n"
    "\n"
    "Calculated using a search to find a value for `df` that produces the\n"
    "desired value of `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper bound of the integral; must satisfy ``x >= 0``\n"
    "df : array_like\n"
    "    Degrees of freedom; must satisfy ``df > 0``\n"
    "p : array_like\n"
    "    Probability; must satisfy ``0 <= p < 1``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "nc : scalar or ndarray\n"
    "    Non-centrality\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtr, chndtrix, chndtrinc")
ufunc_chndtrinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtrinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtrinc_types[0] = <char>NPY_FLOAT
ufunc_chndtrinc_types[1] = <char>NPY_FLOAT
ufunc_chndtrinc_types[2] = <char>NPY_FLOAT
ufunc_chndtrinc_types[3] = <char>NPY_FLOAT
ufunc_chndtrinc_types[4] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[5] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[6] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[7] = <char>NPY_DOUBLE
ufunc_chndtrinc_ptr[2*0] = <void*>_func_cdfchn4_wrap
ufunc_chndtrinc_ptr[2*0+1] = <void*>(<char*>"chndtrinc")
ufunc_chndtrinc_ptr[2*1] = <void*>_func_cdfchn4_wrap
ufunc_chndtrinc_ptr[2*1+1] = <void*>(<char*>"chndtrinc")
ufunc_chndtrinc_data[0] = &ufunc_chndtrinc_ptr[2*0]
ufunc_chndtrinc_data[1] = &ufunc_chndtrinc_ptr[2*1]
chndtrinc = np.PyUFunc_FromFuncAndData(ufunc_chndtrinc_loops, ufunc_chndtrinc_data, ufunc_chndtrinc_types, 2, 3, 1, 0, "chndtrinc", ufunc_chndtrinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtrix_loops[2]
cdef void *ufunc_chndtrix_ptr[4]
cdef void *ufunc_chndtrix_data[2]
cdef char ufunc_chndtrix_types[8]
cdef char *ufunc_chndtrix_doc = (
    "chndtrix(p, df, nc, out=None)\n"
    "\n"
    "Inverse to `chndtr` vs `x`\n"
    "\n"
    "Calculated using a search to find a value for `x` that produces the\n"
    "desired value of `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability; must satisfy ``0 <= p < 1``\n"
    "df : array_like\n"
    "    Degrees of freedom; must satisfy ``df > 0``\n"
    "nc : array_like\n"
    "    Non-centrality parameter; must satisfy ``nc >= 0``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Value so that the probability a non-central Chi square random variable\n"
    "    with `df` degrees of freedom and non-centrality, `nc`, is greater than\n"
    "    `x` equals `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtr, chndtridf, chndtrinc")
ufunc_chndtrix_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtrix_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtrix_types[0] = <char>NPY_FLOAT
ufunc_chndtrix_types[1] = <char>NPY_FLOAT
ufunc_chndtrix_types[2] = <char>NPY_FLOAT
ufunc_chndtrix_types[3] = <char>NPY_FLOAT
ufunc_chndtrix_types[4] = <char>NPY_DOUBLE
ufunc_chndtrix_types[5] = <char>NPY_DOUBLE
ufunc_chndtrix_types[6] = <char>NPY_DOUBLE
ufunc_chndtrix_types[7] = <char>NPY_DOUBLE
ufunc_chndtrix_ptr[2*0] = <void*>_func_cdfchn2_wrap
ufunc_chndtrix_ptr[2*0+1] = <void*>(<char*>"chndtrix")
ufunc_chndtrix_ptr[2*1] = <void*>_func_cdfchn2_wrap
ufunc_chndtrix_ptr[2*1+1] = <void*>(<char*>"chndtrix")
ufunc_chndtrix_data[0] = &ufunc_chndtrix_ptr[2*0]
ufunc_chndtrix_data[1] = &ufunc_chndtrix_ptr[2*1]
chndtrix = np.PyUFunc_FromFuncAndData(ufunc_chndtrix_loops, ufunc_chndtrix_data, ufunc_chndtrix_types, 2, 3, 1, 0, "chndtrix", ufunc_chndtrix_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cosdg_loops[2]
cdef void *ufunc_cosdg_ptr[4]
cdef void *ufunc_cosdg_data[2]
cdef char ufunc_cosdg_types[4]
cdef char *ufunc_cosdg_doc = (
    "cosdg(x, out=None)\n"
    "\n"
    "Cosine of the angle `x` given in degrees.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Angle, given in degrees.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Cosine of the input.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "sindg, tandg, cotdg\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is more accurate than using cosine directly.\n"
    "\n"
    ">>> x = 90 + 180 * np.arange(3)\n"
    ">>> sc.cosdg(x)\n"
    "array([-0.,  0., -0.])\n"
    ">>> np.cos(x * np.pi / 180)\n"
    "array([ 6.1232340e-17, -1.8369702e-16,  3.0616170e-16])")
ufunc_cosdg_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cosdg_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cosdg_types[0] = <char>NPY_FLOAT
ufunc_cosdg_types[1] = <char>NPY_FLOAT
ufunc_cosdg_types[2] = <char>NPY_DOUBLE
ufunc_cosdg_types[3] = <char>NPY_DOUBLE
ufunc_cosdg_ptr[2*0] = <void*>_func_cosdg
ufunc_cosdg_ptr[2*0+1] = <void*>(<char*>"cosdg")
ufunc_cosdg_ptr[2*1] = <void*>_func_cosdg
ufunc_cosdg_ptr[2*1+1] = <void*>(<char*>"cosdg")
ufunc_cosdg_data[0] = &ufunc_cosdg_ptr[2*0]
ufunc_cosdg_data[1] = &ufunc_cosdg_ptr[2*1]
cosdg = np.PyUFunc_FromFuncAndData(ufunc_cosdg_loops, ufunc_cosdg_data, ufunc_cosdg_types, 2, 1, 1, 0, "cosdg", ufunc_cosdg_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cosm1_loops[2]
cdef void *ufunc_cosm1_ptr[4]
cdef void *ufunc_cosm1_data[2]
cdef char ufunc_cosm1_types[4]
cdef char *ufunc_cosm1_doc = (
    "cosm1(x, out=None)\n"
    "\n"
    "cos(x) - 1 for use when `x` is near zero.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real valued argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of ``cos(x) - 1``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "expm1, log1p\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is more accurate than computing ``cos(x) - 1`` directly for\n"
    "``x`` around 0.\n"
    "\n"
    ">>> x = 1e-30\n"
    ">>> np.cos(x) - 1\n"
    "0.0\n"
    ">>> sc.cosm1(x)\n"
    "-5.0000000000000005e-61")
ufunc_cosm1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cosm1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cosm1_types[0] = <char>NPY_FLOAT
ufunc_cosm1_types[1] = <char>NPY_FLOAT
ufunc_cosm1_types[2] = <char>NPY_DOUBLE
ufunc_cosm1_types[3] = <char>NPY_DOUBLE
ufunc_cosm1_ptr[2*0] = <void*>_func_cosm1
ufunc_cosm1_ptr[2*0+1] = <void*>(<char*>"cosm1")
ufunc_cosm1_ptr[2*1] = <void*>_func_cosm1
ufunc_cosm1_ptr[2*1+1] = <void*>(<char*>"cosm1")
ufunc_cosm1_data[0] = &ufunc_cosm1_ptr[2*0]
ufunc_cosm1_data[1] = &ufunc_cosm1_ptr[2*1]
cosm1 = np.PyUFunc_FromFuncAndData(ufunc_cosm1_loops, ufunc_cosm1_data, ufunc_cosm1_types, 2, 1, 1, 0, "cosm1", ufunc_cosm1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cotdg_loops[2]
cdef void *ufunc_cotdg_ptr[4]
cdef void *ufunc_cotdg_data[2]
cdef char ufunc_cotdg_types[4]
cdef char *ufunc_cotdg_doc = (
    "cotdg(x, out=None)\n"
    "\n"
    "Cotangent of the angle `x` given in degrees.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Angle, given in degrees.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Cotangent at the input.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "sindg, cosdg, tandg\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is more accurate than using cotangent directly.\n"
    "\n"
    ">>> x = 90 + 180 * np.arange(3)\n"
    ">>> sc.cotdg(x)\n"
    "array([0., 0., 0.])\n"
    ">>> 1 / np.tan(x * np.pi / 180)\n"
    "array([6.1232340e-17, 1.8369702e-16, 3.0616170e-16])")
ufunc_cotdg_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cotdg_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cotdg_types[0] = <char>NPY_FLOAT
ufunc_cotdg_types[1] = <char>NPY_FLOAT
ufunc_cotdg_types[2] = <char>NPY_DOUBLE
ufunc_cotdg_types[3] = <char>NPY_DOUBLE
ufunc_cotdg_ptr[2*0] = <void*>_func_cotdg
ufunc_cotdg_ptr[2*0+1] = <void*>(<char*>"cotdg")
ufunc_cotdg_ptr[2*1] = <void*>_func_cotdg
ufunc_cotdg_ptr[2*1+1] = <void*>(<char*>"cotdg")
ufunc_cotdg_data[0] = &ufunc_cotdg_ptr[2*0]
ufunc_cotdg_data[1] = &ufunc_cotdg_ptr[2*1]
cotdg = np.PyUFunc_FromFuncAndData(ufunc_cotdg_loops, ufunc_cotdg_data, ufunc_cotdg_types, 2, 1, 1, 0, "cotdg", ufunc_cotdg_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_dawsn_loops[4]
cdef void *ufunc_dawsn_ptr[8]
cdef void *ufunc_dawsn_data[4]
cdef char ufunc_dawsn_types[8]
cdef char *ufunc_dawsn_doc = (
    "dawsn(x, out=None)\n"
    "\n"
    "Dawson's integral.\n"
    "\n"
    "Computes::\n"
    "\n"
    "    exp(-x**2) * integral(exp(t**2), t=0..x).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Function parameter.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Value of the integral.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "wofz, erf, erfc, erfcx, erfi\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-15, 15, num=1000)\n"
    ">>> plt.plot(x, special.dawsn(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$dawsn(x)$')\n"
    ">>> plt.show()")
ufunc_dawsn_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_dawsn_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_dawsn_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_dawsn_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_dawsn_types[0] = <char>NPY_FLOAT
ufunc_dawsn_types[1] = <char>NPY_FLOAT
ufunc_dawsn_types[2] = <char>NPY_DOUBLE
ufunc_dawsn_types[3] = <char>NPY_DOUBLE
ufunc_dawsn_types[4] = <char>NPY_CFLOAT
ufunc_dawsn_types[5] = <char>NPY_CFLOAT
ufunc_dawsn_types[6] = <char>NPY_CDOUBLE
ufunc_dawsn_types[7] = <char>NPY_CDOUBLE
ufunc_dawsn_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn
ufunc_dawsn_ptr[2*0+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn
ufunc_dawsn_ptr[2*1+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn_complex
ufunc_dawsn_ptr[2*2+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn_complex
ufunc_dawsn_ptr[2*3+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_data[0] = &ufunc_dawsn_ptr[2*0]
ufunc_dawsn_data[1] = &ufunc_dawsn_ptr[2*1]
ufunc_dawsn_data[2] = &ufunc_dawsn_ptr[2*2]
ufunc_dawsn_data[3] = &ufunc_dawsn_ptr[2*3]
dawsn = np.PyUFunc_FromFuncAndData(ufunc_dawsn_loops, ufunc_dawsn_data, ufunc_dawsn_types, 4, 1, 1, 0, "dawsn", ufunc_dawsn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ellipe_loops[2]
cdef void *ufunc_ellipe_ptr[4]
cdef void *ufunc_ellipe_data[2]
cdef char ufunc_ellipe_types[4]
cdef char *ufunc_ellipe_doc = (
    "ellipe(m, out=None)\n"
    "\n"
    "Complete elliptic integral of the second kind\n"
    "\n"
    "This function is defined as\n"
    "\n"
    ".. math:: E(m) = \\int_0^{\\pi/2} [1 - m \\sin(t)^2]^{1/2} dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Defines the parameter of the elliptic integral.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "E : scalar or ndarray\n"
    "    Value of the elliptic integral.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1\n"
    "ellipk : Complete elliptic integral of the first kind\n"
    "ellipkinc : Incomplete elliptic integral of the first kind\n"
    "ellipeinc : Incomplete elliptic integral of the second kind\n"
    "elliprd : Symmetric elliptic integral of the second kind.\n"
    "elliprg : Completely-symmetric elliptic integral of the second kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `ellpe`.\n"
    "\n"
    "For `m > 0` the computation uses the approximation,\n"
    "\n"
    ".. math:: E(m) \\approx P(1-m) - (1-m) \\log(1-m) Q(1-m),\n"
    "\n"
    "where :math:`P` and :math:`Q` are tenth-order polynomials.  For\n"
    "`m < 0`, the relation\n"
    "\n"
    ".. math:: E(m) = E(m/(m - 1)) \\sqrt(1-m)\n"
    "\n"
    "is used.\n"
    "\n"
    "The parameterization in terms of :math:`m` follows that of section\n"
    "17.2 in [2]_. Other parameterizations in terms of the\n"
    "complementary parameter :math:`1 - m`, modular angle\n"
    ":math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n"
    "used, so be careful that you choose the correct parameter.\n"
    "\n"
    "The Legendre E integral is related to Carlson's symmetric R_D or R_G\n"
    "functions in multiple ways [3]_. For example,\n"
    "\n"
    ".. math:: E(m) = 2 R_G(0, 1-k^2, 1) .\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [3] NIST Digital Library of Mathematical\n"
    "       Functions. http://dlmf.nist.gov/, Release 1.0.28 of\n"
    "       2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i\n"
    "\n"
    "Examples\n"
    "--------\n"
    "This function is used in finding the circumference of an\n"
    "ellipse with semi-major axis `a` and semi-minor axis `b`.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    "\n"
    ">>> a = 3.5\n"
    ">>> b = 2.1\n"
    ">>> e_sq = 1.0 - b**2/a**2  # eccentricity squared\n"
    "\n"
    "Then the circumference is found using the following:\n"
    "\n"
    ">>> C = 4*a*special.ellipe(e_sq)  # circumference formula\n"
    ">>> C\n"
    "17.868899204378693\n"
    "\n"
    "When `a` and `b` are the same (meaning eccentricity is 0),\n"
    "this reduces to the circumference of a circle.\n"
    "\n"
    ">>> 4*a*special.ellipe(0.0)  # formula for ellipse with a = b\n"
    "21.991148575128552\n"
    ">>> 2*np.pi*a  # formula for circle of radius a\n"
    "21.991148575128552")
ufunc_ellipe_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ellipe_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ellipe_types[0] = <char>NPY_FLOAT
ufunc_ellipe_types[1] = <char>NPY_FLOAT
ufunc_ellipe_types[2] = <char>NPY_DOUBLE
ufunc_ellipe_types[3] = <char>NPY_DOUBLE
ufunc_ellipe_ptr[2*0] = <void*>_func_ellpe
ufunc_ellipe_ptr[2*0+1] = <void*>(<char*>"ellipe")
ufunc_ellipe_ptr[2*1] = <void*>_func_ellpe
ufunc_ellipe_ptr[2*1+1] = <void*>(<char*>"ellipe")
ufunc_ellipe_data[0] = &ufunc_ellipe_ptr[2*0]
ufunc_ellipe_data[1] = &ufunc_ellipe_ptr[2*1]
ellipe = np.PyUFunc_FromFuncAndData(ufunc_ellipe_loops, ufunc_ellipe_data, ufunc_ellipe_types, 2, 1, 1, 0, "ellipe", ufunc_ellipe_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ellipeinc_loops[2]
cdef void *ufunc_ellipeinc_ptr[4]
cdef void *ufunc_ellipeinc_data[2]
cdef char ufunc_ellipeinc_types[6]
cdef char *ufunc_ellipeinc_doc = (
    "ellipeinc(phi, m, out=None)\n"
    "\n"
    "Incomplete elliptic integral of the second kind\n"
    "\n"
    "This function is defined as\n"
    "\n"
    ".. math:: E(\\phi, m) = \\int_0^{\\phi} [1 - m \\sin(t)^2]^{1/2} dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "phi : array_like\n"
    "    amplitude of the elliptic integral.\n"
    "m : array_like\n"
    "    parameter of the elliptic integral.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "E : scalar or ndarray\n"
    "    Value of the elliptic integral.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1\n"
    "ellipk : Complete elliptic integral of the first kind\n"
    "ellipkinc : Incomplete elliptic integral of the first kind\n"
    "ellipe : Complete elliptic integral of the second kind\n"
    "elliprd : Symmetric elliptic integral of the second kind.\n"
    "elliprf : Completely-symmetric elliptic integral of the first kind.\n"
    "elliprg : Completely-symmetric elliptic integral of the second kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `ellie`.\n"
    "\n"
    "Computation uses arithmetic-geometric means algorithm.\n"
    "\n"
    "The parameterization in terms of :math:`m` follows that of section\n"
    "17.2 in [2]_. Other parameterizations in terms of the\n"
    "complementary parameter :math:`1 - m`, modular angle\n"
    ":math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n"
    "used, so be careful that you choose the correct parameter.\n"
    "\n"
    "The Legendre E incomplete integral can be related to combinations\n"
    "of Carlson's symmetric integrals R_D, R_F, and R_G in multiple\n"
    "ways [3]_. For example, with :math:`c = \\csc^2\\phi`,\n"
    "\n"
    ".. math::\n"
    "  E(\\phi, m) = R_F(c-1, c-k^2, c)\n"
    "    - \\frac{1}{3} k^2 R_D(c-1, c-k^2, c) .\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [3] NIST Digital Library of Mathematical\n"
    "       Functions. http://dlmf.nist.gov/, Release 1.0.28 of\n"
    "       2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i")
ufunc_ellipeinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_ellipeinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_ellipeinc_types[0] = <char>NPY_FLOAT
ufunc_ellipeinc_types[1] = <char>NPY_FLOAT
ufunc_ellipeinc_types[2] = <char>NPY_FLOAT
ufunc_ellipeinc_types[3] = <char>NPY_DOUBLE
ufunc_ellipeinc_types[4] = <char>NPY_DOUBLE
ufunc_ellipeinc_types[5] = <char>NPY_DOUBLE
ufunc_ellipeinc_ptr[2*0] = <void*>_func_ellie
ufunc_ellipeinc_ptr[2*0+1] = <void*>(<char*>"ellipeinc")
ufunc_ellipeinc_ptr[2*1] = <void*>_func_ellie
ufunc_ellipeinc_ptr[2*1+1] = <void*>(<char*>"ellipeinc")
ufunc_ellipeinc_data[0] = &ufunc_ellipeinc_ptr[2*0]
ufunc_ellipeinc_data[1] = &ufunc_ellipeinc_ptr[2*1]
ellipeinc = np.PyUFunc_FromFuncAndData(ufunc_ellipeinc_loops, ufunc_ellipeinc_data, ufunc_ellipeinc_types, 2, 2, 1, 0, "ellipeinc", ufunc_ellipeinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ellipj_loops[2]
cdef void *ufunc_ellipj_ptr[4]
cdef void *ufunc_ellipj_data[2]
cdef char ufunc_ellipj_types[12]
cdef char *ufunc_ellipj_doc = (
    "ellipj(u, m, out=None)\n"
    "\n"
    "Jacobian elliptic functions\n"
    "\n"
    "Calculates the Jacobian elliptic functions of parameter `m` between\n"
    "0 and 1, and real argument `u`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Parameter.\n"
    "u : array_like\n"
    "    Argument.\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "sn, cn, dn, ph : 4-tuple of scalar or ndarray\n"
    "    The returned functions::\n"
    "\n"
    "        sn(u|m), cn(u|m), dn(u|m)\n"
    "\n"
    "    The value `ph` is such that if `u = ellipkinc(ph, m)`,\n"
    "    then `sn(u|m) = sin(ph)` and `cn(u|m) = cos(ph)`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ellipk : Complete elliptic integral of the first kind\n"
    "ellipkinc : Incomplete elliptic integral of the first kind\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `ellpj`.\n"
    "\n"
    "These functions are periodic, with quarter-period on the real axis\n"
    "equal to the complete elliptic integral `ellipk(m)`.\n"
    "\n"
    "Relation to incomplete elliptic integral: If `u = ellipkinc(phi,m)`, then\n"
    "`sn(u|m) = sin(phi)`, and `cn(u|m) = cos(phi)`. The `phi` is called\n"
    "the amplitude of `u`.\n"
    "\n"
    "Computation is by means of the arithmetic-geometric mean algorithm,\n"
    "except when `m` is within 1e-9 of 0 or 1. In the latter case with `m`\n"
    "close to 1, the approximation applies only for `phi < pi/2`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_ellipj_loops[0] = <np.PyUFuncGenericFunction>loop_i_dd_dddd_As_ff_ffff
ufunc_ellipj_loops[1] = <np.PyUFuncGenericFunction>loop_i_dd_dddd_As_dd_dddd
ufunc_ellipj_types[0] = <char>NPY_FLOAT
ufunc_ellipj_types[1] = <char>NPY_FLOAT
ufunc_ellipj_types[2] = <char>NPY_FLOAT
ufunc_ellipj_types[3] = <char>NPY_FLOAT
ufunc_ellipj_types[4] = <char>NPY_FLOAT
ufunc_ellipj_types[5] = <char>NPY_FLOAT
ufunc_ellipj_types[6] = <char>NPY_DOUBLE
ufunc_ellipj_types[7] = <char>NPY_DOUBLE
ufunc_ellipj_types[8] = <char>NPY_DOUBLE
ufunc_ellipj_types[9] = <char>NPY_DOUBLE
ufunc_ellipj_types[10] = <char>NPY_DOUBLE
ufunc_ellipj_types[11] = <char>NPY_DOUBLE
ufunc_ellipj_ptr[2*0] = <void*>_func_ellpj
ufunc_ellipj_ptr[2*0+1] = <void*>(<char*>"ellipj")
ufunc_ellipj_ptr[2*1] = <void*>_func_ellpj
ufunc_ellipj_ptr[2*1+1] = <void*>(<char*>"ellipj")
ufunc_ellipj_data[0] = &ufunc_ellipj_ptr[2*0]
ufunc_ellipj_data[1] = &ufunc_ellipj_ptr[2*1]
ellipj = np.PyUFunc_FromFuncAndData(ufunc_ellipj_loops, ufunc_ellipj_data, ufunc_ellipj_types, 2, 2, 4, 0, "ellipj", ufunc_ellipj_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ellipk_loops[2]
cdef void *ufunc_ellipk_ptr[4]
cdef void *ufunc_ellipk_data[2]
cdef char ufunc_ellipk_types[4]
cdef char *ufunc_ellipk_doc = (
    "ellipk(m, out=None)\n"
    "\n"
    "Complete elliptic integral of the first kind.\n"
    "\n"
    "This function is defined as\n"
    "\n"
    ".. math:: K(m) = \\int_0^{\\pi/2} [1 - m \\sin(t)^2]^{-1/2} dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    The parameter of the elliptic integral.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "K : scalar or ndarray\n"
    "    Value of the elliptic integral.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ellipkm1 : Complete elliptic integral of the first kind around m = 1\n"
    "ellipkinc : Incomplete elliptic integral of the first kind\n"
    "ellipe : Complete elliptic integral of the second kind\n"
    "ellipeinc : Incomplete elliptic integral of the second kind\n"
    "elliprf : Completely-symmetric elliptic integral of the first kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For more precision around point m = 1, use `ellipkm1`, which this\n"
    "function calls.\n"
    "\n"
    "The parameterization in terms of :math:`m` follows that of section\n"
    "17.2 in [1]_. Other parameterizations in terms of the\n"
    "complementary parameter :math:`1 - m`, modular angle\n"
    ":math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n"
    "used, so be careful that you choose the correct parameter.\n"
    "\n"
    "The Legendre K integral is related to Carlson's symmetric R_F\n"
    "function by [2]_:\n"
    "\n"
    ".. math:: K(m) = R_F(0, 1-k^2, 1) .\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [2] NIST Digital Library of Mathematical\n"
    "       Functions. http://dlmf.nist.gov/, Release 1.0.28 of\n"
    "       2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i")
ufunc_ellipk_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ellipk_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ellipk_types[0] = <char>NPY_FLOAT
ufunc_ellipk_types[1] = <char>NPY_FLOAT
ufunc_ellipk_types[2] = <char>NPY_DOUBLE
ufunc_ellipk_types[3] = <char>NPY_DOUBLE
ufunc_ellipk_ptr[2*0] = <void*>_func_ellipk
ufunc_ellipk_ptr[2*0+1] = <void*>(<char*>"ellipk")
ufunc_ellipk_ptr[2*1] = <void*>_func_ellipk
ufunc_ellipk_ptr[2*1+1] = <void*>(<char*>"ellipk")
ufunc_ellipk_data[0] = &ufunc_ellipk_ptr[2*0]
ufunc_ellipk_data[1] = &ufunc_ellipk_ptr[2*1]
ellipk = np.PyUFunc_FromFuncAndData(ufunc_ellipk_loops, ufunc_ellipk_data, ufunc_ellipk_types, 2, 1, 1, 0, "ellipk", ufunc_ellipk_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ellipkinc_loops[2]
cdef void *ufunc_ellipkinc_ptr[4]
cdef void *ufunc_ellipkinc_data[2]
cdef char ufunc_ellipkinc_types[6]
cdef char *ufunc_ellipkinc_doc = (
    "ellipkinc(phi, m, out=None)\n"
    "\n"
    "Incomplete elliptic integral of the first kind\n"
    "\n"
    "This function is defined as\n"
    "\n"
    ".. math:: K(\\phi, m) = \\int_0^{\\phi} [1 - m \\sin(t)^2]^{-1/2} dt\n"
    "\n"
    "This function is also called :math:`F(\\phi, m)`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "phi : array_like\n"
    "    amplitude of the elliptic integral\n"
    "m : array_like\n"
    "    parameter of the elliptic integral\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "K : scalar or ndarray\n"
    "    Value of the elliptic integral\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1\n"
    "ellipk : Complete elliptic integral of the first kind\n"
    "ellipe : Complete elliptic integral of the second kind\n"
    "ellipeinc : Incomplete elliptic integral of the second kind\n"
    "elliprf : Completely-symmetric elliptic integral of the first kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `ellik`.  The computation is\n"
    "carried out using the arithmetic-geometric mean algorithm.\n"
    "\n"
    "The parameterization in terms of :math:`m` follows that of section\n"
    "17.2 in [2]_. Other parameterizations in terms of the\n"
    "complementary parameter :math:`1 - m`, modular angle\n"
    ":math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n"
    "used, so be careful that you choose the correct parameter.\n"
    "\n"
    "The Legendre K incomplete integral (or F integral) is related to\n"
    "Carlson's symmetric R_F function [3]_.\n"
    "Setting :math:`c = \\csc^2\\phi`,\n"
    "\n"
    ".. math:: F(\\phi, m) = R_F(c-1, c-k^2, c) .\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [3] NIST Digital Library of Mathematical\n"
    "       Functions. http://dlmf.nist.gov/, Release 1.0.28 of\n"
    "       2020-09-15. See Sec. 19.25(i) https://dlmf.nist.gov/19.25#i")
ufunc_ellipkinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_ellipkinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_ellipkinc_types[0] = <char>NPY_FLOAT
ufunc_ellipkinc_types[1] = <char>NPY_FLOAT
ufunc_ellipkinc_types[2] = <char>NPY_FLOAT
ufunc_ellipkinc_types[3] = <char>NPY_DOUBLE
ufunc_ellipkinc_types[4] = <char>NPY_DOUBLE
ufunc_ellipkinc_types[5] = <char>NPY_DOUBLE
ufunc_ellipkinc_ptr[2*0] = <void*>_func_ellik
ufunc_ellipkinc_ptr[2*0+1] = <void*>(<char*>"ellipkinc")
ufunc_ellipkinc_ptr[2*1] = <void*>_func_ellik
ufunc_ellipkinc_ptr[2*1+1] = <void*>(<char*>"ellipkinc")
ufunc_ellipkinc_data[0] = &ufunc_ellipkinc_ptr[2*0]
ufunc_ellipkinc_data[1] = &ufunc_ellipkinc_ptr[2*1]
ellipkinc = np.PyUFunc_FromFuncAndData(ufunc_ellipkinc_loops, ufunc_ellipkinc_data, ufunc_ellipkinc_types, 2, 2, 1, 0, "ellipkinc", ufunc_ellipkinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ellipkm1_loops[2]
cdef void *ufunc_ellipkm1_ptr[4]
cdef void *ufunc_ellipkm1_data[2]
cdef char ufunc_ellipkm1_types[4]
cdef char *ufunc_ellipkm1_doc = (
    "ellipkm1(p, out=None)\n"
    "\n"
    "Complete elliptic integral of the first kind around `m` = 1\n"
    "\n"
    "This function is defined as\n"
    "\n"
    ".. math:: K(p) = \\int_0^{\\pi/2} [1 - m \\sin(t)^2]^{-1/2} dt\n"
    "\n"
    "where `m = 1 - p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Defines the parameter of the elliptic integral as `m = 1 - p`.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "K : scalar or ndarray\n"
    "    Value of the elliptic integral.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ellipk : Complete elliptic integral of the first kind\n"
    "ellipkinc : Incomplete elliptic integral of the first kind\n"
    "ellipe : Complete elliptic integral of the second kind\n"
    "ellipeinc : Incomplete elliptic integral of the second kind\n"
    "elliprf : Completely-symmetric elliptic integral of the first kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `ellpk`.\n"
    "\n"
    "For `p <= 1`, computation uses the approximation,\n"
    "\n"
    ".. math:: K(p) \\approx P(p) - \\log(p) Q(p),\n"
    "\n"
    "where :math:`P` and :math:`Q` are tenth-order polynomials.  The\n"
    "argument `p` is used internally rather than `m` so that the logarithmic\n"
    "singularity at `m = 1` will be shifted to the origin; this preserves\n"
    "maximum accuracy.  For `p > 1`, the identity\n"
    "\n"
    ".. math:: K(p) = K(1/p)/\\sqrt(p)\n"
    "\n"
    "is used.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_ellipkm1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ellipkm1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ellipkm1_types[0] = <char>NPY_FLOAT
ufunc_ellipkm1_types[1] = <char>NPY_FLOAT
ufunc_ellipkm1_types[2] = <char>NPY_DOUBLE
ufunc_ellipkm1_types[3] = <char>NPY_DOUBLE
ufunc_ellipkm1_ptr[2*0] = <void*>_func_ellpk
ufunc_ellipkm1_ptr[2*0+1] = <void*>(<char*>"ellipkm1")
ufunc_ellipkm1_ptr[2*1] = <void*>_func_ellpk
ufunc_ellipkm1_ptr[2*1+1] = <void*>(<char*>"ellipkm1")
ufunc_ellipkm1_data[0] = &ufunc_ellipkm1_ptr[2*0]
ufunc_ellipkm1_data[1] = &ufunc_ellipkm1_ptr[2*1]
ellipkm1 = np.PyUFunc_FromFuncAndData(ufunc_ellipkm1_loops, ufunc_ellipkm1_data, ufunc_ellipkm1_types, 2, 1, 1, 0, "ellipkm1", ufunc_ellipkm1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_elliprc_loops[4]
cdef void *ufunc_elliprc_ptr[8]
cdef void *ufunc_elliprc_data[4]
cdef char ufunc_elliprc_types[12]
cdef char *ufunc_elliprc_doc = (
    "elliprc(x, y, out=None)\n"
    "\n"
    "Degenerate symmetric elliptic integral.\n"
    "\n"
    "The function RC is defined as [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    R_{\\mathrm{C}}(x, y) =\n"
    "       \\frac{1}{2} \\int_0^{+\\infty} (t + x)^{-1/2} (t + y)^{-1} dt\n"
    "       = R_{\\mathrm{F}}(x, y, y)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y : array_like\n"
    "    Real or complex input parameters. `x` can be any number in the\n"
    "    complex plane cut along the negative real axis. `y` must be non-zero.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "R : scalar or ndarray\n"
    "    Value of the integral. If `y` is real and negative, the Cauchy\n"
    "    principal value is returned. If both of `x` and `y` are real, the\n"
    "    return value is real. Otherwise, the return value is complex.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "elliprf : Completely-symmetric elliptic integral of the first kind.\n"
    "elliprd : Symmetric elliptic integral of the second kind.\n"
    "elliprg : Completely-symmetric elliptic integral of the second kind.\n"
    "elliprj : Symmetric elliptic integral of the third kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "RC is a degenerate case of the symmetric integral RF: ``elliprc(x, y) ==\n"
    "elliprf(x, y, y)``. It is an elementary function rather than an elliptic\n"
    "integral.\n"
    "\n"
    "The code implements Carlson's algorithm based on the duplication theorems\n"
    "and series expansion up to the 7th order. [2]_\n"
    "\n"
    ".. versionadded:: 1.8.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] B. C. Carlson, ed., Chapter 19 in \"Digital Library of Mathematical\n"
    "       Functions,\" NIST, US Dept. of Commerce.\n"
    "       https://dlmf.nist.gov/19.16.E6\n"
    ".. [2] B. C. Carlson, \"Numerical computation of real or complex elliptic\n"
    "       integrals,\" Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n"
    "       https://arxiv.org/abs/math/9409227\n"
    "       https://doi.org/10.1007/BF02198293\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Basic homogeneity property:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import elliprc\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> y = 5.\n"
    ">>> scale = 0.3 + 0.4j\n"
    ">>> elliprc(scale*x, scale*y)\n"
    "(0.5484493976710874-0.4169557678995833j)\n"
    "\n"
    ">>> elliprc(x, y)/np.sqrt(scale)\n"
    "(0.5484493976710874-0.41695576789958333j)\n"
    "\n"
    "When the two arguments coincide, the integral is particularly\n"
    "simple:\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> elliprc(x, x)\n"
    "(0.4299173120614631-0.3041729818745595j)\n"
    "\n"
    ">>> 1/np.sqrt(x)\n"
    "(0.4299173120614631-0.30417298187455954j)\n"
    "\n"
    "Another simple case: the first argument vanishes:\n"
    "\n"
    ">>> y = 1.2 + 3.4j\n"
    ">>> elliprc(0, y)\n"
    "(0.6753125346116815-0.47779380263880866j)\n"
    "\n"
    ">>> np.pi/2/np.sqrt(y)\n"
    "(0.6753125346116815-0.4777938026388088j)\n"
    "\n"
    "When `x` and `y` are both positive, we can express\n"
    ":math:`R_C(x,y)` in terms of more elementary functions.  For the\n"
    "case :math:`0 \\le x < y`,\n"
    "\n"
    ">>> x = 3.2\n"
    ">>> y = 6.\n"
    ">>> elliprc(x, y)\n"
    "0.44942991498453444\n"
    "\n"
    ">>> np.arctan(np.sqrt((y-x)/x))/np.sqrt(y-x)\n"
    "0.44942991498453433\n"
    "\n"
    "And for the case :math:`0 \\le y < x`,\n"
    "\n"
    ">>> x = 6.\n"
    ">>> y = 3.2\n"
    ">>> elliprc(x,y)\n"
    "0.4989837501576147\n"
    "\n"
    ">>> np.log((np.sqrt(x)+np.sqrt(x-y))/np.sqrt(y))/np.sqrt(x-y)\n"
    "0.49898375015761476")
ufunc_elliprc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_elliprc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_elliprc_loops[2] = <np.PyUFuncGenericFunction>loop_D_DD__As_FF_F
ufunc_elliprc_loops[3] = <np.PyUFuncGenericFunction>loop_D_DD__As_DD_D
ufunc_elliprc_types[0] = <char>NPY_FLOAT
ufunc_elliprc_types[1] = <char>NPY_FLOAT
ufunc_elliprc_types[2] = <char>NPY_FLOAT
ufunc_elliprc_types[3] = <char>NPY_DOUBLE
ufunc_elliprc_types[4] = <char>NPY_DOUBLE
ufunc_elliprc_types[5] = <char>NPY_DOUBLE
ufunc_elliprc_types[6] = <char>NPY_CFLOAT
ufunc_elliprc_types[7] = <char>NPY_CFLOAT
ufunc_elliprc_types[8] = <char>NPY_CFLOAT
ufunc_elliprc_types[9] = <char>NPY_CDOUBLE
ufunc_elliprc_types[10] = <char>NPY_CDOUBLE
ufunc_elliprc_types[11] = <char>NPY_CDOUBLE
ufunc_elliprc_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_fellint_RC
ufunc_elliprc_ptr[2*0+1] = <void*>(<char*>"elliprc")
ufunc_elliprc_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_fellint_RC
ufunc_elliprc_ptr[2*1+1] = <void*>(<char*>"elliprc")
ufunc_elliprc_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_cellint_RC
ufunc_elliprc_ptr[2*2+1] = <void*>(<char*>"elliprc")
ufunc_elliprc_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_cellint_RC
ufunc_elliprc_ptr[2*3+1] = <void*>(<char*>"elliprc")
ufunc_elliprc_data[0] = &ufunc_elliprc_ptr[2*0]
ufunc_elliprc_data[1] = &ufunc_elliprc_ptr[2*1]
ufunc_elliprc_data[2] = &ufunc_elliprc_ptr[2*2]
ufunc_elliprc_data[3] = &ufunc_elliprc_ptr[2*3]
elliprc = np.PyUFunc_FromFuncAndData(ufunc_elliprc_loops, ufunc_elliprc_data, ufunc_elliprc_types, 4, 2, 1, 0, "elliprc", ufunc_elliprc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_elliprd_loops[4]
cdef void *ufunc_elliprd_ptr[8]
cdef void *ufunc_elliprd_data[4]
cdef char ufunc_elliprd_types[16]
cdef char *ufunc_elliprd_doc = (
    "elliprd(x, y, z, out=None)\n"
    "\n"
    "Symmetric elliptic integral of the second kind.\n"
    "\n"
    "The function RD is defined as [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    R_{\\mathrm{D}}(x, y, z) =\n"
    "       \\frac{3}{2} \\int_0^{+\\infty} [(t + x) (t + y)]^{-1/2} (t + z)^{-3/2}\n"
    "       dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y, z : array_like\n"
    "    Real or complex input parameters. `x` or `y` can be any number in the\n"
    "    complex plane cut along the negative real axis, but at most one of them\n"
    "    can be zero, while `z` must be non-zero.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "R : scalar or ndarray\n"
    "    Value of the integral. If all of `x`, `y`, and `z` are real, the\n"
    "    return value is real. Otherwise, the return value is complex.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "elliprc : Degenerate symmetric elliptic integral.\n"
    "elliprf : Completely-symmetric elliptic integral of the first kind.\n"
    "elliprg : Completely-symmetric elliptic integral of the second kind.\n"
    "elliprj : Symmetric elliptic integral of the third kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "RD is a degenerate case of the elliptic integral RJ: ``elliprd(x, y, z) ==\n"
    "elliprj(x, y, z, z)``.\n"
    "\n"
    "The code implements Carlson's algorithm based on the duplication theorems\n"
    "and series expansion up to the 7th order. [2]_\n"
    "\n"
    ".. versionadded:: 1.8.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] B. C. Carlson, ed., Chapter 19 in \"Digital Library of Mathematical\n"
    "       Functions,\" NIST, US Dept. of Commerce.\n"
    "       https://dlmf.nist.gov/19.16.E5\n"
    ".. [2] B. C. Carlson, \"Numerical computation of real or complex elliptic\n"
    "       integrals,\" Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n"
    "       https://arxiv.org/abs/math/9409227\n"
    "       https://doi.org/10.1007/BF02198293\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Basic homogeneity property:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import elliprd\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> y = 5.\n"
    ">>> z = 6.\n"
    ">>> scale = 0.3 + 0.4j\n"
    ">>> elliprd(scale*x, scale*y, scale*z)\n"
    "(-0.03703043835680379-0.24500934665683802j)\n"
    "\n"
    ">>> elliprd(x, y, z)*np.power(scale, -1.5)\n"
    "(-0.0370304383568038-0.24500934665683805j)\n"
    "\n"
    "All three arguments coincide:\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> elliprd(x, x, x)\n"
    "(-0.03986825876151896-0.14051741840449586j)\n"
    "\n"
    ">>> np.power(x, -1.5)\n"
    "(-0.03986825876151894-0.14051741840449583j)\n"
    "\n"
    "The so-called \"second lemniscate constant\":\n"
    "\n"
    ">>> elliprd(0, 2, 1)/3\n"
    "0.5990701173677961\n"
    "\n"
    ">>> from scipy.special import gamma\n"
    ">>> gamma(0.75)**2/np.sqrt(2*np.pi)\n"
    "0.5990701173677959")
ufunc_elliprd_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_elliprd_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_elliprd_loops[2] = <np.PyUFuncGenericFunction>loop_D_DDD__As_FFF_F
ufunc_elliprd_loops[3] = <np.PyUFuncGenericFunction>loop_D_DDD__As_DDD_D
ufunc_elliprd_types[0] = <char>NPY_FLOAT
ufunc_elliprd_types[1] = <char>NPY_FLOAT
ufunc_elliprd_types[2] = <char>NPY_FLOAT
ufunc_elliprd_types[3] = <char>NPY_FLOAT
ufunc_elliprd_types[4] = <char>NPY_DOUBLE
ufunc_elliprd_types[5] = <char>NPY_DOUBLE
ufunc_elliprd_types[6] = <char>NPY_DOUBLE
ufunc_elliprd_types[7] = <char>NPY_DOUBLE
ufunc_elliprd_types[8] = <char>NPY_CFLOAT
ufunc_elliprd_types[9] = <char>NPY_CFLOAT
ufunc_elliprd_types[10] = <char>NPY_CFLOAT
ufunc_elliprd_types[11] = <char>NPY_CFLOAT
ufunc_elliprd_types[12] = <char>NPY_CDOUBLE
ufunc_elliprd_types[13] = <char>NPY_CDOUBLE
ufunc_elliprd_types[14] = <char>NPY_CDOUBLE
ufunc_elliprd_types[15] = <char>NPY_CDOUBLE
ufunc_elliprd_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_fellint_RD
ufunc_elliprd_ptr[2*0+1] = <void*>(<char*>"elliprd")
ufunc_elliprd_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_fellint_RD
ufunc_elliprd_ptr[2*1+1] = <void*>(<char*>"elliprd")
ufunc_elliprd_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_cellint_RD
ufunc_elliprd_ptr[2*2+1] = <void*>(<char*>"elliprd")
ufunc_elliprd_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_cellint_RD
ufunc_elliprd_ptr[2*3+1] = <void*>(<char*>"elliprd")
ufunc_elliprd_data[0] = &ufunc_elliprd_ptr[2*0]
ufunc_elliprd_data[1] = &ufunc_elliprd_ptr[2*1]
ufunc_elliprd_data[2] = &ufunc_elliprd_ptr[2*2]
ufunc_elliprd_data[3] = &ufunc_elliprd_ptr[2*3]
elliprd = np.PyUFunc_FromFuncAndData(ufunc_elliprd_loops, ufunc_elliprd_data, ufunc_elliprd_types, 4, 3, 1, 0, "elliprd", ufunc_elliprd_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_elliprf_loops[4]
cdef void *ufunc_elliprf_ptr[8]
cdef void *ufunc_elliprf_data[4]
cdef char ufunc_elliprf_types[16]
cdef char *ufunc_elliprf_doc = (
    "elliprf(x, y, z, out=None)\n"
    "\n"
    "Completely-symmetric elliptic integral of the first kind.\n"
    "\n"
    "The function RF is defined as [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    R_{\\mathrm{F}}(x, y, z) =\n"
    "       \\frac{1}{2} \\int_0^{+\\infty} [(t + x) (t + y) (t + z)]^{-1/2} dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y, z : array_like\n"
    "    Real or complex input parameters. `x`, `y`, or `z` can be any number in\n"
    "    the complex plane cut along the negative real axis, but at most one of\n"
    "    them can be zero.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "R : scalar or ndarray\n"
    "    Value of the integral. If all of `x`, `y`, and `z` are real, the return\n"
    "    value is real. Otherwise, the return value is complex.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "elliprc : Degenerate symmetric integral.\n"
    "elliprd : Symmetric elliptic integral of the second kind.\n"
    "elliprg : Completely-symmetric elliptic integral of the second kind.\n"
    "elliprj : Symmetric elliptic integral of the third kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The code implements Carlson's algorithm based on the duplication theorems\n"
    "and series expansion up to the 7th order (cf.:\n"
    "https://dlmf.nist.gov/19.36.i) and the AGM algorithm for the complete\n"
    "integral. [2]_\n"
    "\n"
    ".. versionadded:: 1.8.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] B. C. Carlson, ed., Chapter 19 in \"Digital Library of Mathematical\n"
    "       Functions,\" NIST, US Dept. of Commerce.\n"
    "       https://dlmf.nist.gov/19.16.E1\n"
    ".. [2] B. C. Carlson, \"Numerical computation of real or complex elliptic\n"
    "       integrals,\" Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n"
    "       https://arxiv.org/abs/math/9409227\n"
    "       https://doi.org/10.1007/BF02198293\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Basic homogeneity property:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import elliprf\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> y = 5.\n"
    ">>> z = 6.\n"
    ">>> scale = 0.3 + 0.4j\n"
    ">>> elliprf(scale*x, scale*y, scale*z)\n"
    "(0.5328051227278146-0.4008623567957094j)\n"
    "\n"
    ">>> elliprf(x, y, z)/np.sqrt(scale)\n"
    "(0.5328051227278147-0.4008623567957095j)\n"
    "\n"
    "All three arguments coincide:\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> elliprf(x, x, x)\n"
    "(0.42991731206146316-0.30417298187455954j)\n"
    "\n"
    ">>> 1/np.sqrt(x)\n"
    "(0.4299173120614631-0.30417298187455954j)\n"
    "\n"
    "The so-called \"first lemniscate constant\":\n"
    "\n"
    ">>> elliprf(0, 1, 2)\n"
    "1.3110287771460598\n"
    "\n"
    ">>> from scipy.special import gamma\n"
    ">>> gamma(0.25)**2/(4*np.sqrt(2*np.pi))\n"
    "1.3110287771460598")
ufunc_elliprf_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_elliprf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_elliprf_loops[2] = <np.PyUFuncGenericFunction>loop_D_DDD__As_FFF_F
ufunc_elliprf_loops[3] = <np.PyUFuncGenericFunction>loop_D_DDD__As_DDD_D
ufunc_elliprf_types[0] = <char>NPY_FLOAT
ufunc_elliprf_types[1] = <char>NPY_FLOAT
ufunc_elliprf_types[2] = <char>NPY_FLOAT
ufunc_elliprf_types[3] = <char>NPY_FLOAT
ufunc_elliprf_types[4] = <char>NPY_DOUBLE
ufunc_elliprf_types[5] = <char>NPY_DOUBLE
ufunc_elliprf_types[6] = <char>NPY_DOUBLE
ufunc_elliprf_types[7] = <char>NPY_DOUBLE
ufunc_elliprf_types[8] = <char>NPY_CFLOAT
ufunc_elliprf_types[9] = <char>NPY_CFLOAT
ufunc_elliprf_types[10] = <char>NPY_CFLOAT
ufunc_elliprf_types[11] = <char>NPY_CFLOAT
ufunc_elliprf_types[12] = <char>NPY_CDOUBLE
ufunc_elliprf_types[13] = <char>NPY_CDOUBLE
ufunc_elliprf_types[14] = <char>NPY_CDOUBLE
ufunc_elliprf_types[15] = <char>NPY_CDOUBLE
ufunc_elliprf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_fellint_RF
ufunc_elliprf_ptr[2*0+1] = <void*>(<char*>"elliprf")
ufunc_elliprf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_fellint_RF
ufunc_elliprf_ptr[2*1+1] = <void*>(<char*>"elliprf")
ufunc_elliprf_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_cellint_RF
ufunc_elliprf_ptr[2*2+1] = <void*>(<char*>"elliprf")
ufunc_elliprf_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_cellint_RF
ufunc_elliprf_ptr[2*3+1] = <void*>(<char*>"elliprf")
ufunc_elliprf_data[0] = &ufunc_elliprf_ptr[2*0]
ufunc_elliprf_data[1] = &ufunc_elliprf_ptr[2*1]
ufunc_elliprf_data[2] = &ufunc_elliprf_ptr[2*2]
ufunc_elliprf_data[3] = &ufunc_elliprf_ptr[2*3]
elliprf = np.PyUFunc_FromFuncAndData(ufunc_elliprf_loops, ufunc_elliprf_data, ufunc_elliprf_types, 4, 3, 1, 0, "elliprf", ufunc_elliprf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_elliprg_loops[4]
cdef void *ufunc_elliprg_ptr[8]
cdef void *ufunc_elliprg_data[4]
cdef char ufunc_elliprg_types[16]
cdef char *ufunc_elliprg_doc = (
    "elliprg(x, y, z, out=None)\n"
    "\n"
    "Completely-symmetric elliptic integral of the second kind.\n"
    "\n"
    "The function RG is defined as [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    R_{\\mathrm{G}}(x, y, z) =\n"
    "       \\frac{1}{4} \\int_0^{+\\infty} [(t + x) (t + y) (t + z)]^{-1/2}\n"
    "       \\left(\\frac{x}{t + x} + \\frac{y}{t + y} + \\frac{z}{t + z}\\right) t\n"
    "       dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y, z : array_like\n"
    "    Real or complex input parameters. `x`, `y`, or `z` can be any number in\n"
    "    the complex plane cut along the negative real axis.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "R : scalar or ndarray\n"
    "    Value of the integral. If all of `x`, `y`, and `z` are real, the return\n"
    "    value is real. Otherwise, the return value is complex.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "elliprc : Degenerate symmetric integral.\n"
    "elliprd : Symmetric elliptic integral of the second kind.\n"
    "elliprf : Completely-symmetric elliptic integral of the first kind.\n"
    "elliprj : Symmetric elliptic integral of the third kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The implementation uses the relation [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    2 R_{\\mathrm{G}}(x, y, z) =\n"
    "       z R_{\\mathrm{F}}(x, y, z) -\n"
    "       \\frac{1}{3} (x - z) (y - z) R_{\\mathrm{D}}(x, y, z) +\n"
    "       \\sqrt{\\frac{x y}{z}}\n"
    "\n"
    "and the symmetry of `x`, `y`, `z` when at least one non-zero parameter can\n"
    "be chosen as the pivot. When one of the arguments is close to zero, the AGM\n"
    "method is applied instead. Other special cases are computed following Ref.\n"
    "[2]_\n"
    "\n"
    ".. versionadded:: 1.8.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] B. C. Carlson, \"Numerical computation of real or complex elliptic\n"
    "       integrals,\" Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n"
    "       https://arxiv.org/abs/math/9409227\n"
    "       https://doi.org/10.1007/BF02198293\n"
    ".. [2] B. C. Carlson, ed., Chapter 19 in \"Digital Library of Mathematical\n"
    "       Functions,\" NIST, US Dept. of Commerce.\n"
    "       https://dlmf.nist.gov/19.16.E1\n"
    "       https://dlmf.nist.gov/19.20.ii\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Basic homogeneity property:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import elliprg\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> y = 5.\n"
    ">>> z = 6.\n"
    ">>> scale = 0.3 + 0.4j\n"
    ">>> elliprg(scale*x, scale*y, scale*z)\n"
    "(1.195936862005246+0.8470988320464167j)\n"
    "\n"
    ">>> elliprg(x, y, z)*np.sqrt(scale)\n"
    "(1.195936862005246+0.8470988320464165j)\n"
    "\n"
    "Simplifications:\n"
    "\n"
    ">>> elliprg(0, y, y)\n"
    "1.756203682760182\n"
    "\n"
    ">>> 0.25*np.pi*np.sqrt(y)\n"
    "1.7562036827601817\n"
    "\n"
    ">>> elliprg(0, 0, z)\n"
    "1.224744871391589\n"
    "\n"
    ">>> 0.5*np.sqrt(z)\n"
    "1.224744871391589\n"
    "\n"
    "The surface area of a triaxial ellipsoid with semiaxes ``a``, ``b``, and\n"
    "``c`` is given by\n"
    "\n"
    ".. math::\n"
    "\n"
    "    S = 4 \\pi a b c R_{\\mathrm{G}}(1 / a^2, 1 / b^2, 1 / c^2).\n"
    "\n"
    ">>> def ellipsoid_area(a, b, c):\n"
    "...     r = 4.0 * np.pi * a * b * c\n"
    "...     return r * elliprg(1.0 / (a * a), 1.0 / (b * b), 1.0 / (c * c))\n"
    ">>> print(ellipsoid_area(1, 3, 5))\n"
    "108.62688289491807")
ufunc_elliprg_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_elliprg_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_elliprg_loops[2] = <np.PyUFuncGenericFunction>loop_D_DDD__As_FFF_F
ufunc_elliprg_loops[3] = <np.PyUFuncGenericFunction>loop_D_DDD__As_DDD_D
ufunc_elliprg_types[0] = <char>NPY_FLOAT
ufunc_elliprg_types[1] = <char>NPY_FLOAT
ufunc_elliprg_types[2] = <char>NPY_FLOAT
ufunc_elliprg_types[3] = <char>NPY_FLOAT
ufunc_elliprg_types[4] = <char>NPY_DOUBLE
ufunc_elliprg_types[5] = <char>NPY_DOUBLE
ufunc_elliprg_types[6] = <char>NPY_DOUBLE
ufunc_elliprg_types[7] = <char>NPY_DOUBLE
ufunc_elliprg_types[8] = <char>NPY_CFLOAT
ufunc_elliprg_types[9] = <char>NPY_CFLOAT
ufunc_elliprg_types[10] = <char>NPY_CFLOAT
ufunc_elliprg_types[11] = <char>NPY_CFLOAT
ufunc_elliprg_types[12] = <char>NPY_CDOUBLE
ufunc_elliprg_types[13] = <char>NPY_CDOUBLE
ufunc_elliprg_types[14] = <char>NPY_CDOUBLE
ufunc_elliprg_types[15] = <char>NPY_CDOUBLE
ufunc_elliprg_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_fellint_RG
ufunc_elliprg_ptr[2*0+1] = <void*>(<char*>"elliprg")
ufunc_elliprg_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_fellint_RG
ufunc_elliprg_ptr[2*1+1] = <void*>(<char*>"elliprg")
ufunc_elliprg_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_cellint_RG
ufunc_elliprg_ptr[2*2+1] = <void*>(<char*>"elliprg")
ufunc_elliprg_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_cellint_RG
ufunc_elliprg_ptr[2*3+1] = <void*>(<char*>"elliprg")
ufunc_elliprg_data[0] = &ufunc_elliprg_ptr[2*0]
ufunc_elliprg_data[1] = &ufunc_elliprg_ptr[2*1]
ufunc_elliprg_data[2] = &ufunc_elliprg_ptr[2*2]
ufunc_elliprg_data[3] = &ufunc_elliprg_ptr[2*3]
elliprg = np.PyUFunc_FromFuncAndData(ufunc_elliprg_loops, ufunc_elliprg_data, ufunc_elliprg_types, 4, 3, 1, 0, "elliprg", ufunc_elliprg_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_elliprj_loops[4]
cdef void *ufunc_elliprj_ptr[8]
cdef void *ufunc_elliprj_data[4]
cdef char ufunc_elliprj_types[20]
cdef char *ufunc_elliprj_doc = (
    "elliprj(x, y, z, p, out=None)\n"
    "\n"
    "Symmetric elliptic integral of the third kind.\n"
    "\n"
    "The function RJ is defined as [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    R_{\\mathrm{J}}(x, y, z, p) =\n"
    "       \\frac{3}{2} \\int_0^{+\\infty} [(t + x) (t + y) (t + z)]^{-1/2}\n"
    "       (t + p)^{-1} dt\n"
    "\n"
    ".. warning::\n"
    "    This function should be considered experimental when the inputs are\n"
    "    unbalanced.  Check correctness with another independent implementation.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y, z, p : array_like\n"
    "    Real or complex input parameters. `x`, `y`, or `z` are numbers in\n"
    "    the complex plane cut along the negative real axis (subject to further\n"
    "    constraints, see Notes), and at most one of them can be zero. `p` must\n"
    "    be non-zero.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "R : scalar or ndarray\n"
    "    Value of the integral. If all of `x`, `y`, `z`, and `p` are real, the\n"
    "    return value is real. Otherwise, the return value is complex.\n"
    "\n"
    "    If `p` is real and negative, while `x`, `y`, and `z` are real,\n"
    "    non-negative, and at most one of them is zero, the Cauchy principal\n"
    "    value is returned. [1]_ [2]_\n"
    "\n"
    "See Also\n"
    "--------\n"
    "elliprc : Degenerate symmetric integral.\n"
    "elliprd : Symmetric elliptic integral of the second kind.\n"
    "elliprf : Completely-symmetric elliptic integral of the first kind.\n"
    "elliprg : Completely-symmetric elliptic integral of the second kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The code implements Carlson's algorithm based on the duplication theorems\n"
    "and series expansion up to the 7th order. [3]_ The algorithm is slightly\n"
    "different from its earlier incarnation as it appears in [1]_, in that the\n"
    "call to `elliprc` (or ``atan``/``atanh``, see [4]_) is no longer needed in\n"
    "the inner loop. Asymptotic approximations are used where arguments differ\n"
    "widely in the order of magnitude. [5]_\n"
    "\n"
    "The input values are subject to certain sufficient but not necessary\n"
    "constraints when input arguments are complex. Notably, ``x``, ``y``, and\n"
    "``z`` must have non-negative real parts, unless two of them are\n"
    "non-negative and complex-conjugates to each other while the other is a real\n"
    "non-negative number. [1]_ If the inputs do not satisfy the sufficient\n"
    "condition described in Ref. [1]_ they are rejected outright with the output\n"
    "set to NaN.\n"
    "\n"
    "In the case where one of ``x``, ``y``, and ``z`` is equal to ``p``, the\n"
    "function ``elliprd`` should be preferred because of its less restrictive\n"
    "domain.\n"
    "\n"
    ".. versionadded:: 1.8.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] B. C. Carlson, \"Numerical computation of real or complex elliptic\n"
    "       integrals,\" Numer. Algorithm, vol. 10, no. 1, pp. 13-26, 1995.\n"
    "       https://arxiv.org/abs/math/9409227\n"
    "       https://doi.org/10.1007/BF02198293\n"
    ".. [2] B. C. Carlson, ed., Chapter 19 in \"Digital Library of Mathematical\n"
    "       Functions,\" NIST, US Dept. of Commerce.\n"
    "       https://dlmf.nist.gov/19.20.iii\n"
    ".. [3] B. C. Carlson, J. FitzSimmons, \"Reduction Theorems for Elliptic\n"
    "       Integrands with the Square Root of Two Quadratic Factors,\" J.\n"
    "       Comput. Appl. Math., vol. 118, nos. 1-2, pp. 71-85, 2000.\n"
    "       https://doi.org/10.1016/S0377-0427(00)00282-X\n"
    ".. [4] F. Johansson, \"Numerical Evaluation of Elliptic Functions, Elliptic\n"
    "       Integrals and Modular Forms,\" in J. Blumlein, C. Schneider, P.\n"
    "       Paule, eds., \"Elliptic Integrals, Elliptic Functions and Modular\n"
    "       Forms in Quantum Field Theory,\" pp. 269-293, 2019 (Cham,\n"
    "       Switzerland: Springer Nature Switzerland)\n"
    "       https://arxiv.org/abs/1806.06725\n"
    "       https://doi.org/10.1007/978-3-030-04480-0\n"
    ".. [5] B. C. Carlson, J. L. Gustafson, \"Asymptotic Approximations for\n"
    "       Symmetric Elliptic Integrals,\" SIAM J. Math. Anls., vol. 25, no. 2,\n"
    "       pp. 288-303, 1994.\n"
    "       https://arxiv.org/abs/math/9310223\n"
    "       https://doi.org/10.1137/S0036141092228477\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Basic homogeneity property:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import elliprj\n"
    "\n"
    ">>> x = 1.2 + 3.4j\n"
    ">>> y = 5.\n"
    ">>> z = 6.\n"
    ">>> p = 7.\n"
    ">>> scale = 0.3 - 0.4j\n"
    ">>> elliprj(scale*x, scale*y, scale*z, scale*p)\n"
    "(0.10834905565679157+0.19694950747103812j)\n"
    "\n"
    ">>> elliprj(x, y, z, p)*np.power(scale, -1.5)\n"
    "(0.10834905565679556+0.19694950747103854j)\n"
    "\n"
    "Reduction to simpler elliptic integral:\n"
    "\n"
    ">>> elliprj(x, y, z, z)\n"
    "(0.08288462362195129-0.028376809745123258j)\n"
    "\n"
    ">>> from scipy.special import elliprd\n"
    ">>> elliprd(x, y, z)\n"
    "(0.08288462362195136-0.028376809745123296j)\n"
    "\n"
    "All arguments coincide:\n"
    "\n"
    ">>> elliprj(x, x, x, x)\n"
    "(-0.03986825876151896-0.14051741840449586j)\n"
    "\n"
    ">>> np.power(x, -1.5)\n"
    "(-0.03986825876151894-0.14051741840449583j)")
ufunc_elliprj_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_elliprj_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_elliprj_loops[2] = <np.PyUFuncGenericFunction>loop_D_DDDD__As_FFFF_F
ufunc_elliprj_loops[3] = <np.PyUFuncGenericFunction>loop_D_DDDD__As_DDDD_D
ufunc_elliprj_types[0] = <char>NPY_FLOAT
ufunc_elliprj_types[1] = <char>NPY_FLOAT
ufunc_elliprj_types[2] = <char>NPY_FLOAT
ufunc_elliprj_types[3] = <char>NPY_FLOAT
ufunc_elliprj_types[4] = <char>NPY_FLOAT
ufunc_elliprj_types[5] = <char>NPY_DOUBLE
ufunc_elliprj_types[6] = <char>NPY_DOUBLE
ufunc_elliprj_types[7] = <char>NPY_DOUBLE
ufunc_elliprj_types[8] = <char>NPY_DOUBLE
ufunc_elliprj_types[9] = <char>NPY_DOUBLE
ufunc_elliprj_types[10] = <char>NPY_CFLOAT
ufunc_elliprj_types[11] = <char>NPY_CFLOAT
ufunc_elliprj_types[12] = <char>NPY_CFLOAT
ufunc_elliprj_types[13] = <char>NPY_CFLOAT
ufunc_elliprj_types[14] = <char>NPY_CFLOAT
ufunc_elliprj_types[15] = <char>NPY_CDOUBLE
ufunc_elliprj_types[16] = <char>NPY_CDOUBLE
ufunc_elliprj_types[17] = <char>NPY_CDOUBLE
ufunc_elliprj_types[18] = <char>NPY_CDOUBLE
ufunc_elliprj_types[19] = <char>NPY_CDOUBLE
ufunc_elliprj_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_fellint_RJ
ufunc_elliprj_ptr[2*0+1] = <void*>(<char*>"elliprj")
ufunc_elliprj_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_fellint_RJ
ufunc_elliprj_ptr[2*1+1] = <void*>(<char*>"elliprj")
ufunc_elliprj_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_cellint_RJ
ufunc_elliprj_ptr[2*2+1] = <void*>(<char*>"elliprj")
ufunc_elliprj_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_cellint_RJ
ufunc_elliprj_ptr[2*3+1] = <void*>(<char*>"elliprj")
ufunc_elliprj_data[0] = &ufunc_elliprj_ptr[2*0]
ufunc_elliprj_data[1] = &ufunc_elliprj_ptr[2*1]
ufunc_elliprj_data[2] = &ufunc_elliprj_ptr[2*2]
ufunc_elliprj_data[3] = &ufunc_elliprj_ptr[2*3]
elliprj = np.PyUFunc_FromFuncAndData(ufunc_elliprj_loops, ufunc_elliprj_data, ufunc_elliprj_types, 4, 4, 1, 0, "elliprj", ufunc_elliprj_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_entr_loops[2]
cdef void *ufunc_entr_ptr[4]
cdef void *ufunc_entr_data[2]
cdef char ufunc_entr_types[4]
cdef char *ufunc_entr_doc = (
    "entr(x, out=None)\n"
    "\n"
    "Elementwise function for computing entropy.\n"
    "\n"
    ".. math:: \\text{entr}(x) = \\begin{cases} - x \\log(x) & x > 0  \\\\ 0 & x = 0\n"
    "          \\\\ -\\infty & \\text{otherwise} \\end{cases}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : ndarray\n"
    "    Input array.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "res : scalar or ndarray\n"
    "    The value of the elementwise entropy function at the given points `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kl_div, rel_entr, scipy.stats.entropy\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 0.15.0\n"
    "\n"
    "This function is concave.\n"
    "\n"
    "The origin of this function is in convex programming; see [1]_.\n"
    "Given a probability distribution :math:`p_1, \\ldots, p_n`,\n"
    "the definition of entropy in the context of *information theory* is\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\sum_{i = 1}^n \\mathrm{entr}(p_i).\n"
    "\n"
    "To compute the latter quantity, use `scipy.stats.entropy`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*.\n"
    "       Cambridge University Press, 2004.\n"
    "       :doi:`https://doi.org/10.1017/CBO9780511804441`")
ufunc_entr_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_entr_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_entr_types[0] = <char>NPY_FLOAT
ufunc_entr_types[1] = <char>NPY_FLOAT
ufunc_entr_types[2] = <char>NPY_DOUBLE
ufunc_entr_types[3] = <char>NPY_DOUBLE
ufunc_entr_ptr[2*0] = <void*>_func_entr
ufunc_entr_ptr[2*0+1] = <void*>(<char*>"entr")
ufunc_entr_ptr[2*1] = <void*>_func_entr
ufunc_entr_ptr[2*1+1] = <void*>(<char*>"entr")
ufunc_entr_data[0] = &ufunc_entr_ptr[2*0]
ufunc_entr_data[1] = &ufunc_entr_ptr[2*1]
entr = np.PyUFunc_FromFuncAndData(ufunc_entr_loops, ufunc_entr_data, ufunc_entr_types, 2, 1, 1, 0, "entr", ufunc_entr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erf_loops[4]
cdef void *ufunc_erf_ptr[8]
cdef void *ufunc_erf_data[4]
cdef char ufunc_erf_types[8]
cdef char *ufunc_erf_doc = (
    "erf(z, out=None)\n"
    "\n"
    "Returns the error function of complex argument.\n"
    "\n"
    "It is defined as ``2/sqrt(pi)*integral(exp(-t**2), t=0..z)``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : ndarray\n"
    "    Input array.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "res : scalar or ndarray\n"
    "    The values of the error function at the given points `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erfc, erfinv, erfcinv, wofz, erfcx, erfi\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The cumulative of the unit normal distribution is given by\n"
    "``Phi(z) = 1/2[1 + erf(z/sqrt(2))]``.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] https://en.wikipedia.org/wiki/Error_function\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover,\n"
    "    1972. http://www.math.sfu.ca/~cbm/aands/page_297.htm\n"
    ".. [3] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> plt.plot(x, special.erf(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$erf(x)$')\n"
    ">>> plt.show()")
ufunc_erf_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_erf_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erf_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_erf_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_erf_types[0] = <char>NPY_FLOAT
ufunc_erf_types[1] = <char>NPY_FLOAT
ufunc_erf_types[2] = <char>NPY_DOUBLE
ufunc_erf_types[3] = <char>NPY_DOUBLE
ufunc_erf_types[4] = <char>NPY_CFLOAT
ufunc_erf_types[5] = <char>NPY_CFLOAT
ufunc_erf_types[6] = <char>NPY_CDOUBLE
ufunc_erf_types[7] = <char>NPY_CDOUBLE
ufunc_erf_ptr[2*0] = <void*>_func_erf
ufunc_erf_ptr[2*0+1] = <void*>(<char*>"erf")
ufunc_erf_ptr[2*1] = <void*>_func_erf
ufunc_erf_ptr[2*1+1] = <void*>(<char*>"erf")
ufunc_erf_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erf
ufunc_erf_ptr[2*2+1] = <void*>(<char*>"erf")
ufunc_erf_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erf
ufunc_erf_ptr[2*3+1] = <void*>(<char*>"erf")
ufunc_erf_data[0] = &ufunc_erf_ptr[2*0]
ufunc_erf_data[1] = &ufunc_erf_ptr[2*1]
ufunc_erf_data[2] = &ufunc_erf_ptr[2*2]
ufunc_erf_data[3] = &ufunc_erf_ptr[2*3]
erf = np.PyUFunc_FromFuncAndData(ufunc_erf_loops, ufunc_erf_data, ufunc_erf_types, 4, 1, 1, 0, "erf", ufunc_erf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erfc_loops[4]
cdef void *ufunc_erfc_ptr[8]
cdef void *ufunc_erfc_data[4]
cdef char ufunc_erfc_types[8]
cdef char *ufunc_erfc_doc = (
    "erfc(x, out=None)\n"
    "\n"
    "Complementary error function, ``1 - erf(x)``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real or complex valued argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the complementary error function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf, erfi, erfcx, dawsn, wofz\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> plt.plot(x, special.erfc(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$erfc(x)$')\n"
    ">>> plt.show()")
ufunc_erfc_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_erfc_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erfc_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_erfc_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_erfc_types[0] = <char>NPY_FLOAT
ufunc_erfc_types[1] = <char>NPY_FLOAT
ufunc_erfc_types[2] = <char>NPY_DOUBLE
ufunc_erfc_types[3] = <char>NPY_DOUBLE
ufunc_erfc_types[4] = <char>NPY_CFLOAT
ufunc_erfc_types[5] = <char>NPY_CFLOAT
ufunc_erfc_types[6] = <char>NPY_CDOUBLE
ufunc_erfc_types[7] = <char>NPY_CDOUBLE
ufunc_erfc_ptr[2*0] = <void*>_func_erfc
ufunc_erfc_ptr[2*0+1] = <void*>(<char*>"erfc")
ufunc_erfc_ptr[2*1] = <void*>_func_erfc
ufunc_erfc_ptr[2*1+1] = <void*>(<char*>"erfc")
ufunc_erfc_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfc_complex
ufunc_erfc_ptr[2*2+1] = <void*>(<char*>"erfc")
ufunc_erfc_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfc_complex
ufunc_erfc_ptr[2*3+1] = <void*>(<char*>"erfc")
ufunc_erfc_data[0] = &ufunc_erfc_ptr[2*0]
ufunc_erfc_data[1] = &ufunc_erfc_ptr[2*1]
ufunc_erfc_data[2] = &ufunc_erfc_ptr[2*2]
ufunc_erfc_data[3] = &ufunc_erfc_ptr[2*3]
erfc = np.PyUFunc_FromFuncAndData(ufunc_erfc_loops, ufunc_erfc_data, ufunc_erfc_types, 4, 1, 1, 0, "erfc", ufunc_erfc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erfcinv_loops[2]
cdef void *ufunc_erfcinv_ptr[4]
cdef void *ufunc_erfcinv_data[2]
cdef char ufunc_erfcinv_types[4]
cdef char *ufunc_erfcinv_doc = (
    "erfcinv(y, out=None)\n"
    "\n"
    "Inverse of the complementary error function.\n"
    "\n"
    "Computes the inverse of the complementary error function.\n"
    "\n"
    "In the complex domain, there is no unique complex number w satisfying\n"
    "erfc(w)=z. This indicates a true inverse function would be multivalued.\n"
    "When the domain restricts to the real, 0 < x < 2, there is a unique real\n"
    "number satisfying erfc(erfcinv(x)) = erfcinv(erfc(x)).\n"
    "\n"
    "It is related to inverse of the error function by erfcinv(1-x) = erfinv(x)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : ndarray\n"
    "    Argument at which to evaluate. Domain: [0, 2]\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "erfcinv : scalar or ndarray\n"
    "    The inverse of erfc of y, element-wise\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf : Error function of a complex argument\n"
    "erfc : Complementary error function, ``1 - erf(x)``\n"
    "erfinv : Inverse of the error function\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> from scipy.special import erfcinv\n"
    "\n"
    ">>> erfcinv(0.5)\n"
    "0.4769362762044699\n"
    "\n"
    ">>> y = np.linspace(0.0, 2.0, num=11)\n"
    ">>> erfcinv(y)\n"
    "array([        inf,  0.9061938 ,  0.59511608,  0.37080716,  0.17914345,\n"
    "       -0.        , -0.17914345, -0.37080716, -0.59511608, -0.9061938 ,\n"
    "              -inf])\n"
    "\n"
    "Plot the function:\n"
    "\n"
    ">>> y = np.linspace(0, 2, 200)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(y, erfcinv(y))\n"
    ">>> ax.grid(True)\n"
    ">>> ax.set_xlabel('y')\n"
    ">>> ax.set_title('erfcinv(y)')\n"
    ">>> plt.show()")
ufunc_erfcinv_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_erfcinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erfcinv_types[0] = <char>NPY_FLOAT
ufunc_erfcinv_types[1] = <char>NPY_FLOAT
ufunc_erfcinv_types[2] = <char>NPY_DOUBLE
ufunc_erfcinv_types[3] = <char>NPY_DOUBLE
ufunc_erfcinv_ptr[2*0] = <void*>_func_erfcinv
ufunc_erfcinv_ptr[2*0+1] = <void*>(<char*>"erfcinv")
ufunc_erfcinv_ptr[2*1] = <void*>_func_erfcinv
ufunc_erfcinv_ptr[2*1+1] = <void*>(<char*>"erfcinv")
ufunc_erfcinv_data[0] = &ufunc_erfcinv_ptr[2*0]
ufunc_erfcinv_data[1] = &ufunc_erfcinv_ptr[2*1]
erfcinv = np.PyUFunc_FromFuncAndData(ufunc_erfcinv_loops, ufunc_erfcinv_data, ufunc_erfcinv_types, 2, 1, 1, 0, "erfcinv", ufunc_erfcinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erfcx_loops[4]
cdef void *ufunc_erfcx_ptr[8]
cdef void *ufunc_erfcx_data[4]
cdef char ufunc_erfcx_types[8]
cdef char *ufunc_erfcx_doc = (
    "erfcx(x, out=None)\n"
    "\n"
    "Scaled complementary error function, ``exp(x**2) * erfc(x)``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real or complex valued argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the scaled complementary error function\n"
    "\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf, erfc, erfi, dawsn, wofz\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.12.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> plt.plot(x, special.erfcx(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$erfcx(x)$')\n"
    ">>> plt.show()")
ufunc_erfcx_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_erfcx_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erfcx_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_erfcx_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_erfcx_types[0] = <char>NPY_FLOAT
ufunc_erfcx_types[1] = <char>NPY_FLOAT
ufunc_erfcx_types[2] = <char>NPY_DOUBLE
ufunc_erfcx_types[3] = <char>NPY_DOUBLE
ufunc_erfcx_types[4] = <char>NPY_CFLOAT
ufunc_erfcx_types[5] = <char>NPY_CFLOAT
ufunc_erfcx_types[6] = <char>NPY_CDOUBLE
ufunc_erfcx_types[7] = <char>NPY_CDOUBLE
ufunc_erfcx_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfcx
ufunc_erfcx_ptr[2*0+1] = <void*>(<char*>"erfcx")
ufunc_erfcx_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfcx
ufunc_erfcx_ptr[2*1+1] = <void*>(<char*>"erfcx")
ufunc_erfcx_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfcx_complex
ufunc_erfcx_ptr[2*2+1] = <void*>(<char*>"erfcx")
ufunc_erfcx_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfcx_complex
ufunc_erfcx_ptr[2*3+1] = <void*>(<char*>"erfcx")
ufunc_erfcx_data[0] = &ufunc_erfcx_ptr[2*0]
ufunc_erfcx_data[1] = &ufunc_erfcx_ptr[2*1]
ufunc_erfcx_data[2] = &ufunc_erfcx_ptr[2*2]
ufunc_erfcx_data[3] = &ufunc_erfcx_ptr[2*3]
erfcx = np.PyUFunc_FromFuncAndData(ufunc_erfcx_loops, ufunc_erfcx_data, ufunc_erfcx_types, 4, 1, 1, 0, "erfcx", ufunc_erfcx_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erfi_loops[4]
cdef void *ufunc_erfi_ptr[8]
cdef void *ufunc_erfi_data[4]
cdef char ufunc_erfi_types[8]
cdef char *ufunc_erfi_doc = (
    "erfi(z, out=None)\n"
    "\n"
    "Imaginary error function, ``-i erf(i z)``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Real or complex valued argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the imaginary error function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf, erfc, erfcx, dawsn, wofz\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.12.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> plt.plot(x, special.erfi(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$erfi(x)$')\n"
    ">>> plt.show()")
ufunc_erfi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_erfi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erfi_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_erfi_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_erfi_types[0] = <char>NPY_FLOAT
ufunc_erfi_types[1] = <char>NPY_FLOAT
ufunc_erfi_types[2] = <char>NPY_DOUBLE
ufunc_erfi_types[3] = <char>NPY_DOUBLE
ufunc_erfi_types[4] = <char>NPY_CFLOAT
ufunc_erfi_types[5] = <char>NPY_CFLOAT
ufunc_erfi_types[6] = <char>NPY_CDOUBLE
ufunc_erfi_types[7] = <char>NPY_CDOUBLE
ufunc_erfi_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfi
ufunc_erfi_ptr[2*0+1] = <void*>(<char*>"erfi")
ufunc_erfi_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfi
ufunc_erfi_ptr[2*1+1] = <void*>(<char*>"erfi")
ufunc_erfi_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfi_complex
ufunc_erfi_ptr[2*2+1] = <void*>(<char*>"erfi")
ufunc_erfi_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfi_complex
ufunc_erfi_ptr[2*3+1] = <void*>(<char*>"erfi")
ufunc_erfi_data[0] = &ufunc_erfi_ptr[2*0]
ufunc_erfi_data[1] = &ufunc_erfi_ptr[2*1]
ufunc_erfi_data[2] = &ufunc_erfi_ptr[2*2]
ufunc_erfi_data[3] = &ufunc_erfi_ptr[2*3]
erfi = np.PyUFunc_FromFuncAndData(ufunc_erfi_loops, ufunc_erfi_data, ufunc_erfi_types, 4, 1, 1, 0, "erfi", ufunc_erfi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erfinv_loops[2]
cdef void *ufunc_erfinv_ptr[4]
cdef void *ufunc_erfinv_data[2]
cdef char ufunc_erfinv_types[4]
cdef char *ufunc_erfinv_doc = (
    "erfinv(y, out=None)\n"
    "\n"
    "Inverse of the error function.\n"
    "\n"
    "Computes the inverse of the error function.\n"
    "\n"
    "In the complex domain, there is no unique complex number w satisfying\n"
    "erf(w)=z. This indicates a true inverse function would be multivalued.\n"
    "When the domain restricts to the real, -1 < x < 1, there is a unique real\n"
    "number satisfying erf(erfinv(x)) = x.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : ndarray\n"
    "    Argument at which to evaluate. Domain: [-1, 1]\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "erfinv : scalar or ndarray\n"
    "    The inverse of erf of y, element-wise\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf : Error function of a complex argument\n"
    "erfc : Complementary error function, ``1 - erf(x)``\n"
    "erfcinv : Inverse of the complementary error function\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> from scipy.special import erfinv, erf\n"
    "\n"
    ">>> erfinv(0.5)\n"
    "0.4769362762044699\n"
    "\n"
    ">>> y = np.linspace(-1.0, 1.0, num=9)\n"
    ">>> x = erfinv(y)\n"
    ">>> x\n"
    "array([       -inf, -0.81341985, -0.47693628, -0.22531206,  0.        ,\n"
    "        0.22531206,  0.47693628,  0.81341985,         inf])\n"
    "\n"
    "Verify that ``erf(erfinv(y))`` is ``y``.\n"
    "\n"
    ">>> erf(x)\n"
    "array([-1.  , -0.75, -0.5 , -0.25,  0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n"
    "\n"
    "Plot the function:\n"
    "\n"
    ">>> y = np.linspace(-1, 1, 200)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(y, erfinv(y))\n"
    ">>> ax.grid(True)\n"
    ">>> ax.set_xlabel('y')\n"
    ">>> ax.set_title('erfinv(y)')\n"
    ">>> plt.show()")
ufunc_erfinv_loops[0] = <np.PyUFuncGenericFunction>loop_f_f__As_f_f
ufunc_erfinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erfinv_types[0] = <char>NPY_FLOAT
ufunc_erfinv_types[1] = <char>NPY_FLOAT
ufunc_erfinv_types[2] = <char>NPY_DOUBLE
ufunc_erfinv_types[3] = <char>NPY_DOUBLE
ufunc_erfinv_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_erfinv_float
ufunc_erfinv_ptr[2*0+1] = <void*>(<char*>"erfinv")
ufunc_erfinv_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_erfinv_double
ufunc_erfinv_ptr[2*1+1] = <void*>(<char*>"erfinv")
ufunc_erfinv_data[0] = &ufunc_erfinv_ptr[2*0]
ufunc_erfinv_data[1] = &ufunc_erfinv_ptr[2*1]
erfinv = np.PyUFunc_FromFuncAndData(ufunc_erfinv_loops, ufunc_erfinv_data, ufunc_erfinv_types, 2, 1, 1, 0, "erfinv", ufunc_erfinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_chebyc_loops[5]
cdef void *ufunc_eval_chebyc_ptr[10]
cdef void *ufunc_eval_chebyc_data[5]
cdef char ufunc_eval_chebyc_types[15]
cdef char *ufunc_eval_chebyc_doc = (
    "eval_chebyc(n, x, out=None)\n"
    "\n"
    "Evaluate Chebyshev polynomial of the first kind on [-2, 2] at a\n"
    "point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    C_n(x) = 2 T_n(x/2)\n"
    "\n"
    "where :math:`T_n` is a Chebyshev polynomial of the first kind. See\n"
    "22.5.11 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `eval_chebyt`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Chebyshev polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "C : scalar or ndarray\n"
    "    Values of the Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_chebyc : roots and quadrature weights of Chebyshev\n"
    "               polynomials of the first kind on [-2, 2]\n"
    "chebyc : Chebyshev polynomial object\n"
    "numpy.polynomial.chebyshev.Chebyshev : Chebyshev series\n"
    "eval_chebyt : evaluate Chebycshev polynomials of the first kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "They are a scaled version of the Chebyshev polynomials of the\n"
    "first kind.\n"
    "\n"
    ">>> x = np.linspace(-2, 2, 6)\n"
    ">>> sc.eval_chebyc(3, x)\n"
    "array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ])\n"
    ">>> 2 * sc.eval_chebyt(3, x / 2)\n"
    "array([-2.   ,  1.872,  1.136, -1.136, -1.872,  2.   ])")
ufunc_eval_chebyc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_chebyc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_chebyc_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_chebyc_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_chebyc_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_chebyc_types[0] = <char>NPY_LONG
ufunc_eval_chebyc_types[1] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[2] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[3] = <char>NPY_FLOAT
ufunc_eval_chebyc_types[4] = <char>NPY_FLOAT
ufunc_eval_chebyc_types[5] = <char>NPY_FLOAT
ufunc_eval_chebyc_types[6] = <char>NPY_FLOAT
ufunc_eval_chebyc_types[7] = <char>NPY_CFLOAT
ufunc_eval_chebyc_types[8] = <char>NPY_CFLOAT
ufunc_eval_chebyc_types[9] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[10] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[11] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[12] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[13] = <char>NPY_CDOUBLE
ufunc_eval_chebyc_types[14] = <char>NPY_CDOUBLE
ufunc_eval_chebyc_ptr[2*0] = <void*>_func_eval_chebyc_l
ufunc_eval_chebyc_ptr[2*0+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_ptr[2*1] = <void*>_func_eval_chebyc[double]
ufunc_eval_chebyc_ptr[2*1+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_ptr[2*2] = <void*>_func_eval_chebyc[double_complex]
ufunc_eval_chebyc_ptr[2*2+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_ptr[2*3] = <void*>_func_eval_chebyc[double]
ufunc_eval_chebyc_ptr[2*3+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_ptr[2*4] = <void*>_func_eval_chebyc[double_complex]
ufunc_eval_chebyc_ptr[2*4+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_data[0] = &ufunc_eval_chebyc_ptr[2*0]
ufunc_eval_chebyc_data[1] = &ufunc_eval_chebyc_ptr[2*1]
ufunc_eval_chebyc_data[2] = &ufunc_eval_chebyc_ptr[2*2]
ufunc_eval_chebyc_data[3] = &ufunc_eval_chebyc_ptr[2*3]
ufunc_eval_chebyc_data[4] = &ufunc_eval_chebyc_ptr[2*4]
eval_chebyc = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyc_loops, ufunc_eval_chebyc_data, ufunc_eval_chebyc_types, 5, 2, 1, 0, "eval_chebyc", ufunc_eval_chebyc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_chebys_loops[5]
cdef void *ufunc_eval_chebys_ptr[10]
cdef void *ufunc_eval_chebys_data[5]
cdef char ufunc_eval_chebys_types[15]
cdef char *ufunc_eval_chebys_doc = (
    "eval_chebys(n, x, out=None)\n"
    "\n"
    "Evaluate Chebyshev polynomial of the second kind on [-2, 2] at a\n"
    "point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    S_n(x) = U_n(x/2)\n"
    "\n"
    "where :math:`U_n` is a Chebyshev polynomial of the second\n"
    "kind. See 22.5.13 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `eval_chebyu`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Chebyshev polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "S : scalar or ndarray\n"
    "    Values of the Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_chebys : roots and quadrature weights of Chebyshev\n"
    "               polynomials of the second kind on [-2, 2]\n"
    "chebys : Chebyshev polynomial object\n"
    "eval_chebyu : evaluate Chebyshev polynomials of the second kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "They are a scaled version of the Chebyshev polynomials of the\n"
    "second kind.\n"
    "\n"
    ">>> x = np.linspace(-2, 2, 6)\n"
    ">>> sc.eval_chebys(3, x)\n"
    "array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ])\n"
    ">>> sc.eval_chebyu(3, x / 2)\n"
    "array([-4.   ,  0.672,  0.736, -0.736, -0.672,  4.   ])")
ufunc_eval_chebys_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_chebys_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_chebys_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_chebys_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_chebys_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_chebys_types[0] = <char>NPY_LONG
ufunc_eval_chebys_types[1] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[2] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[3] = <char>NPY_FLOAT
ufunc_eval_chebys_types[4] = <char>NPY_FLOAT
ufunc_eval_chebys_types[5] = <char>NPY_FLOAT
ufunc_eval_chebys_types[6] = <char>NPY_FLOAT
ufunc_eval_chebys_types[7] = <char>NPY_CFLOAT
ufunc_eval_chebys_types[8] = <char>NPY_CFLOAT
ufunc_eval_chebys_types[9] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[10] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[11] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[12] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[13] = <char>NPY_CDOUBLE
ufunc_eval_chebys_types[14] = <char>NPY_CDOUBLE
ufunc_eval_chebys_ptr[2*0] = <void*>_func_eval_chebys_l
ufunc_eval_chebys_ptr[2*0+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_ptr[2*1] = <void*>_func_eval_chebys[double]
ufunc_eval_chebys_ptr[2*1+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_ptr[2*2] = <void*>_func_eval_chebys[double_complex]
ufunc_eval_chebys_ptr[2*2+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_ptr[2*3] = <void*>_func_eval_chebys[double]
ufunc_eval_chebys_ptr[2*3+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_ptr[2*4] = <void*>_func_eval_chebys[double_complex]
ufunc_eval_chebys_ptr[2*4+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_data[0] = &ufunc_eval_chebys_ptr[2*0]
ufunc_eval_chebys_data[1] = &ufunc_eval_chebys_ptr[2*1]
ufunc_eval_chebys_data[2] = &ufunc_eval_chebys_ptr[2*2]
ufunc_eval_chebys_data[3] = &ufunc_eval_chebys_ptr[2*3]
ufunc_eval_chebys_data[4] = &ufunc_eval_chebys_ptr[2*4]
eval_chebys = np.PyUFunc_FromFuncAndData(ufunc_eval_chebys_loops, ufunc_eval_chebys_data, ufunc_eval_chebys_types, 5, 2, 1, 0, "eval_chebys", ufunc_eval_chebys_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_chebyt_loops[5]
cdef void *ufunc_eval_chebyt_ptr[10]
cdef void *ufunc_eval_chebyt_data[5]
cdef char ufunc_eval_chebyt_types[15]
cdef char *ufunc_eval_chebyt_doc = (
    "eval_chebyt(n, x, out=None)\n"
    "\n"
    "Evaluate Chebyshev polynomial of the first kind at a point.\n"
    "\n"
    "The Chebyshev polynomials of the first kind can be defined via the\n"
    "Gauss hypergeometric function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    T_n(x) = {}_2F_1(n, -n; 1/2; (1 - x)/2).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`. See 22.5.47 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Chebyshev polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "T : scalar or ndarray\n"
    "    Values of the Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_chebyt : roots and quadrature weights of Chebyshev\n"
    "               polynomials of the first kind\n"
    "chebyu : Chebychev polynomial object\n"
    "eval_chebyu : evaluate Chebyshev polynomials of the second kind\n"
    "hyp2f1 : Gauss hypergeometric function\n"
    "numpy.polynomial.chebyshev.Chebyshev : Chebyshev series\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This routine is numerically stable for `x` in ``[-1, 1]`` at least\n"
    "up to order ``10000``.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_chebyt_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_chebyt_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_chebyt_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_chebyt_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_chebyt_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_chebyt_types[0] = <char>NPY_LONG
ufunc_eval_chebyt_types[1] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[2] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[3] = <char>NPY_FLOAT
ufunc_eval_chebyt_types[4] = <char>NPY_FLOAT
ufunc_eval_chebyt_types[5] = <char>NPY_FLOAT
ufunc_eval_chebyt_types[6] = <char>NPY_FLOAT
ufunc_eval_chebyt_types[7] = <char>NPY_CFLOAT
ufunc_eval_chebyt_types[8] = <char>NPY_CFLOAT
ufunc_eval_chebyt_types[9] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[10] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[11] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[12] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[13] = <char>NPY_CDOUBLE
ufunc_eval_chebyt_types[14] = <char>NPY_CDOUBLE
ufunc_eval_chebyt_ptr[2*0] = <void*>_func_eval_chebyt_l
ufunc_eval_chebyt_ptr[2*0+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_ptr[2*1] = <void*>_func_eval_chebyt[double]
ufunc_eval_chebyt_ptr[2*1+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_ptr[2*2] = <void*>_func_eval_chebyt[double_complex]
ufunc_eval_chebyt_ptr[2*2+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_ptr[2*3] = <void*>_func_eval_chebyt[double]
ufunc_eval_chebyt_ptr[2*3+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_ptr[2*4] = <void*>_func_eval_chebyt[double_complex]
ufunc_eval_chebyt_ptr[2*4+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_data[0] = &ufunc_eval_chebyt_ptr[2*0]
ufunc_eval_chebyt_data[1] = &ufunc_eval_chebyt_ptr[2*1]
ufunc_eval_chebyt_data[2] = &ufunc_eval_chebyt_ptr[2*2]
ufunc_eval_chebyt_data[3] = &ufunc_eval_chebyt_ptr[2*3]
ufunc_eval_chebyt_data[4] = &ufunc_eval_chebyt_ptr[2*4]
eval_chebyt = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyt_loops, ufunc_eval_chebyt_data, ufunc_eval_chebyt_types, 5, 2, 1, 0, "eval_chebyt", ufunc_eval_chebyt_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_chebyu_loops[5]
cdef void *ufunc_eval_chebyu_ptr[10]
cdef void *ufunc_eval_chebyu_data[5]
cdef char ufunc_eval_chebyu_types[15]
cdef char *ufunc_eval_chebyu_doc = (
    "eval_chebyu(n, x, out=None)\n"
    "\n"
    "Evaluate Chebyshev polynomial of the second kind at a point.\n"
    "\n"
    "The Chebyshev polynomials of the second kind can be defined via\n"
    "the Gauss hypergeometric function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    U_n(x) = (n + 1) {}_2F_1(-n, n + 2; 3/2; (1 - x)/2).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`. See 22.5.48 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Chebyshev polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "U : scalar or ndarray\n"
    "    Values of the Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_chebyu : roots and quadrature weights of Chebyshev\n"
    "               polynomials of the second kind\n"
    "chebyu : Chebyshev polynomial object\n"
    "eval_chebyt : evaluate Chebyshev polynomials of the first kind\n"
    "hyp2f1 : Gauss hypergeometric function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_chebyu_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_chebyu_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_chebyu_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_chebyu_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_chebyu_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_chebyu_types[0] = <char>NPY_LONG
ufunc_eval_chebyu_types[1] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[2] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[3] = <char>NPY_FLOAT
ufunc_eval_chebyu_types[4] = <char>NPY_FLOAT
ufunc_eval_chebyu_types[5] = <char>NPY_FLOAT
ufunc_eval_chebyu_types[6] = <char>NPY_FLOAT
ufunc_eval_chebyu_types[7] = <char>NPY_CFLOAT
ufunc_eval_chebyu_types[8] = <char>NPY_CFLOAT
ufunc_eval_chebyu_types[9] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[10] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[11] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[12] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[13] = <char>NPY_CDOUBLE
ufunc_eval_chebyu_types[14] = <char>NPY_CDOUBLE
ufunc_eval_chebyu_ptr[2*0] = <void*>_func_eval_chebyu_l
ufunc_eval_chebyu_ptr[2*0+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_ptr[2*1] = <void*>_func_eval_chebyu[double]
ufunc_eval_chebyu_ptr[2*1+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_ptr[2*2] = <void*>_func_eval_chebyu[double_complex]
ufunc_eval_chebyu_ptr[2*2+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_ptr[2*3] = <void*>_func_eval_chebyu[double]
ufunc_eval_chebyu_ptr[2*3+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_ptr[2*4] = <void*>_func_eval_chebyu[double_complex]
ufunc_eval_chebyu_ptr[2*4+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_data[0] = &ufunc_eval_chebyu_ptr[2*0]
ufunc_eval_chebyu_data[1] = &ufunc_eval_chebyu_ptr[2*1]
ufunc_eval_chebyu_data[2] = &ufunc_eval_chebyu_ptr[2*2]
ufunc_eval_chebyu_data[3] = &ufunc_eval_chebyu_ptr[2*3]
ufunc_eval_chebyu_data[4] = &ufunc_eval_chebyu_ptr[2*4]
eval_chebyu = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyu_loops, ufunc_eval_chebyu_data, ufunc_eval_chebyu_types, 5, 2, 1, 0, "eval_chebyu", ufunc_eval_chebyu_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_gegenbauer_loops[5]
cdef void *ufunc_eval_gegenbauer_ptr[10]
cdef void *ufunc_eval_gegenbauer_data[5]
cdef char ufunc_eval_gegenbauer_types[20]
cdef char *ufunc_eval_gegenbauer_doc = (
    "eval_gegenbauer(n, alpha, x, out=None)\n"
    "\n"
    "Evaluate Gegenbauer polynomial at a point.\n"
    "\n"
    "The Gegenbauer polynomials can be defined via the Gauss\n"
    "hypergeometric function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    C_n^{(\\alpha)} = \\frac{(2\\alpha)_n}{\\Gamma(n + 1)}\n"
    "      {}_2F_1(-n, 2\\alpha + n; \\alpha + 1/2; (1 - z)/2).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`. See 22.5.46 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "alpha : array_like\n"
    "    Parameter\n"
    "x : array_like\n"
    "    Points at which to evaluate the Gegenbauer polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "C : scalar or ndarray\n"
    "    Values of the Gegenbauer polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_gegenbauer : roots and quadrature weights of Gegenbauer\n"
    "                   polynomials\n"
    "gegenbauer : Gegenbauer polynomial object\n"
    "hyp2f1 : Gauss hypergeometric function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_gegenbauer_loops[0] = <np.PyUFuncGenericFunction>loop_d_ldd__As_ldd_d
ufunc_eval_gegenbauer_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_eval_gegenbauer_loops[2] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ffF_F
ufunc_eval_gegenbauer_loops[3] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_eval_gegenbauer_loops[4] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ddD_D
ufunc_eval_gegenbauer_types[0] = <char>NPY_LONG
ufunc_eval_gegenbauer_types[1] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[2] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[3] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[4] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[5] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[6] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[7] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[8] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[9] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[10] = <char>NPY_CFLOAT
ufunc_eval_gegenbauer_types[11] = <char>NPY_CFLOAT
ufunc_eval_gegenbauer_types[12] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[13] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[14] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[15] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[16] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[17] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[18] = <char>NPY_CDOUBLE
ufunc_eval_gegenbauer_types[19] = <char>NPY_CDOUBLE
ufunc_eval_gegenbauer_ptr[2*0] = <void*>_func_eval_gegenbauer_l
ufunc_eval_gegenbauer_ptr[2*0+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_ptr[2*1] = <void*>_func_eval_gegenbauer[double]
ufunc_eval_gegenbauer_ptr[2*1+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_ptr[2*2] = <void*>_func_eval_gegenbauer[double_complex]
ufunc_eval_gegenbauer_ptr[2*2+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_ptr[2*3] = <void*>_func_eval_gegenbauer[double]
ufunc_eval_gegenbauer_ptr[2*3+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_ptr[2*4] = <void*>_func_eval_gegenbauer[double_complex]
ufunc_eval_gegenbauer_ptr[2*4+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_data[0] = &ufunc_eval_gegenbauer_ptr[2*0]
ufunc_eval_gegenbauer_data[1] = &ufunc_eval_gegenbauer_ptr[2*1]
ufunc_eval_gegenbauer_data[2] = &ufunc_eval_gegenbauer_ptr[2*2]
ufunc_eval_gegenbauer_data[3] = &ufunc_eval_gegenbauer_ptr[2*3]
ufunc_eval_gegenbauer_data[4] = &ufunc_eval_gegenbauer_ptr[2*4]
eval_gegenbauer = np.PyUFunc_FromFuncAndData(ufunc_eval_gegenbauer_loops, ufunc_eval_gegenbauer_data, ufunc_eval_gegenbauer_types, 5, 3, 1, 0, "eval_gegenbauer", ufunc_eval_gegenbauer_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_genlaguerre_loops[5]
cdef void *ufunc_eval_genlaguerre_ptr[10]
cdef void *ufunc_eval_genlaguerre_data[5]
cdef char ufunc_eval_genlaguerre_types[20]
cdef char *ufunc_eval_genlaguerre_doc = (
    "eval_genlaguerre(n, alpha, x, out=None)\n"
    "\n"
    "Evaluate generalized Laguerre polynomial at a point.\n"
    "\n"
    "The generalized Laguerre polynomials can be defined via the\n"
    "confluent hypergeometric function :math:`{}_1F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    L_n^{(\\alpha)}(x) = \\binom{n + \\alpha}{n}\n"
    "      {}_1F_1(-n, \\alpha + 1, x).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`. See 22.5.54 in [AS]_ for details. The Laguerre\n"
    "polynomials are the special case where :math:`\\alpha = 0`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to the confluent hypergeometric\n"
    "    function.\n"
    "alpha : array_like\n"
    "    Parameter; must have ``alpha > -1``\n"
    "x : array_like\n"
    "    Points at which to evaluate the generalized Laguerre\n"
    "    polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "L : scalar or ndarray\n"
    "    Values of the generalized Laguerre polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_genlaguerre : roots and quadrature weights of generalized\n"
    "                    Laguerre polynomials\n"
    "genlaguerre : generalized Laguerre polynomial object\n"
    "hyp1f1 : confluent hypergeometric function\n"
    "eval_laguerre : evaluate Laguerre polynomials\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_genlaguerre_loops[0] = <np.PyUFuncGenericFunction>loop_d_ldd__As_ldd_d
ufunc_eval_genlaguerre_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_eval_genlaguerre_loops[2] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ffF_F
ufunc_eval_genlaguerre_loops[3] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_eval_genlaguerre_loops[4] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ddD_D
ufunc_eval_genlaguerre_types[0] = <char>NPY_LONG
ufunc_eval_genlaguerre_types[1] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[2] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[3] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[4] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[5] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[6] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[7] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[8] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[9] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[10] = <char>NPY_CFLOAT
ufunc_eval_genlaguerre_types[11] = <char>NPY_CFLOAT
ufunc_eval_genlaguerre_types[12] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[13] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[14] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[15] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[16] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[17] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[18] = <char>NPY_CDOUBLE
ufunc_eval_genlaguerre_types[19] = <char>NPY_CDOUBLE
ufunc_eval_genlaguerre_ptr[2*0] = <void*>_func_eval_genlaguerre_l
ufunc_eval_genlaguerre_ptr[2*0+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_ptr[2*1] = <void*>_func_eval_genlaguerre[double]
ufunc_eval_genlaguerre_ptr[2*1+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_ptr[2*2] = <void*>_func_eval_genlaguerre[double_complex]
ufunc_eval_genlaguerre_ptr[2*2+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_ptr[2*3] = <void*>_func_eval_genlaguerre[double]
ufunc_eval_genlaguerre_ptr[2*3+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_ptr[2*4] = <void*>_func_eval_genlaguerre[double_complex]
ufunc_eval_genlaguerre_ptr[2*4+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_data[0] = &ufunc_eval_genlaguerre_ptr[2*0]
ufunc_eval_genlaguerre_data[1] = &ufunc_eval_genlaguerre_ptr[2*1]
ufunc_eval_genlaguerre_data[2] = &ufunc_eval_genlaguerre_ptr[2*2]
ufunc_eval_genlaguerre_data[3] = &ufunc_eval_genlaguerre_ptr[2*3]
ufunc_eval_genlaguerre_data[4] = &ufunc_eval_genlaguerre_ptr[2*4]
eval_genlaguerre = np.PyUFunc_FromFuncAndData(ufunc_eval_genlaguerre_loops, ufunc_eval_genlaguerre_data, ufunc_eval_genlaguerre_types, 5, 3, 1, 0, "eval_genlaguerre", ufunc_eval_genlaguerre_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_hermite_loops[1]
cdef void *ufunc_eval_hermite_ptr[2]
cdef void *ufunc_eval_hermite_data[1]
cdef char ufunc_eval_hermite_types[3]
cdef char *ufunc_eval_hermite_doc = (
    "eval_hermite(n, x, out=None)\n"
    "\n"
    "Evaluate physicist's Hermite polynomial at a point.\n"
    "\n"
    "Defined by\n"
    "\n"
    ".. math::\n"
    "\n"
    "    H_n(x) = (-1)^n e^{x^2} \\frac{d^n}{dx^n} e^{-x^2};\n"
    "\n"
    ":math:`H_n` is a polynomial of degree :math:`n`. See 22.11.7 in\n"
    "[AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial\n"
    "x : array_like\n"
    "    Points at which to evaluate the Hermite polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "H : scalar or ndarray\n"
    "    Values of the Hermite polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_hermite : roots and quadrature weights of physicist's\n"
    "                Hermite polynomials\n"
    "hermite : physicist's Hermite polynomial object\n"
    "numpy.polynomial.hermite.Hermite : Physicist's Hermite series\n"
    "eval_hermitenorm : evaluate Probabilist's Hermite polynomials\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_hermite_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_hermite_types[0] = <char>NPY_LONG
ufunc_eval_hermite_types[1] = <char>NPY_DOUBLE
ufunc_eval_hermite_types[2] = <char>NPY_DOUBLE
ufunc_eval_hermite_ptr[2*0] = <void*>_func_eval_hermite
ufunc_eval_hermite_ptr[2*0+1] = <void*>(<char*>"eval_hermite")
ufunc_eval_hermite_data[0] = &ufunc_eval_hermite_ptr[2*0]
eval_hermite = np.PyUFunc_FromFuncAndData(ufunc_eval_hermite_loops, ufunc_eval_hermite_data, ufunc_eval_hermite_types, 1, 2, 1, 0, "eval_hermite", ufunc_eval_hermite_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_hermitenorm_loops[1]
cdef void *ufunc_eval_hermitenorm_ptr[2]
cdef void *ufunc_eval_hermitenorm_data[1]
cdef char ufunc_eval_hermitenorm_types[3]
cdef char *ufunc_eval_hermitenorm_doc = (
    "eval_hermitenorm(n, x, out=None)\n"
    "\n"
    "Evaluate probabilist's (normalized) Hermite polynomial at a\n"
    "point.\n"
    "\n"
    "Defined by\n"
    "\n"
    ".. math::\n"
    "\n"
    "    He_n(x) = (-1)^n e^{x^2/2} \\frac{d^n}{dx^n} e^{-x^2/2};\n"
    "\n"
    ":math:`He_n` is a polynomial of degree :math:`n`. See 22.11.8 in\n"
    "[AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial\n"
    "x : array_like\n"
    "    Points at which to evaluate the Hermite polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "He : scalar or ndarray\n"
    "    Values of the Hermite polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_hermitenorm : roots and quadrature weights of probabilist's\n"
    "                    Hermite polynomials\n"
    "hermitenorm : probabilist's Hermite polynomial object\n"
    "numpy.polynomial.hermite_e.HermiteE : Probabilist's Hermite series\n"
    "eval_hermite : evaluate physicist's Hermite polynomials\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_hermitenorm_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_hermitenorm_types[0] = <char>NPY_LONG
ufunc_eval_hermitenorm_types[1] = <char>NPY_DOUBLE
ufunc_eval_hermitenorm_types[2] = <char>NPY_DOUBLE
ufunc_eval_hermitenorm_ptr[2*0] = <void*>_func_eval_hermitenorm
ufunc_eval_hermitenorm_ptr[2*0+1] = <void*>(<char*>"eval_hermitenorm")
ufunc_eval_hermitenorm_data[0] = &ufunc_eval_hermitenorm_ptr[2*0]
eval_hermitenorm = np.PyUFunc_FromFuncAndData(ufunc_eval_hermitenorm_loops, ufunc_eval_hermitenorm_data, ufunc_eval_hermitenorm_types, 1, 2, 1, 0, "eval_hermitenorm", ufunc_eval_hermitenorm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_jacobi_loops[5]
cdef void *ufunc_eval_jacobi_ptr[10]
cdef void *ufunc_eval_jacobi_data[5]
cdef char ufunc_eval_jacobi_types[25]
cdef char *ufunc_eval_jacobi_doc = (
    "eval_jacobi(n, alpha, beta, x, out=None)\n"
    "\n"
    "Evaluate Jacobi polynomial at a point.\n"
    "\n"
    "The Jacobi polynomials can be defined via the Gauss hypergeometric\n"
    "function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_n^{(\\alpha, \\beta)}(x) = \\frac{(\\alpha + 1)_n}{\\Gamma(n + 1)}\n"
    "      {}_2F_1(-n, 1 + \\alpha + \\beta + n; \\alpha + 1; (1 - z)/2)\n"
    "\n"
    "where :math:`(\\cdot)_n` is the Pochhammer symbol; see `poch`. When\n"
    ":math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`. See 22.5.42 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "alpha : array_like\n"
    "    Parameter\n"
    "beta : array_like\n"
    "    Parameter\n"
    "x : array_like\n"
    "    Points at which to evaluate the polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "P : scalar or ndarray\n"
    "    Values of the Jacobi polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_jacobi : roots and quadrature weights of Jacobi polynomials\n"
    "jacobi : Jacobi polynomial object\n"
    "hyp2f1 : Gauss hypergeometric function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_jacobi_loops[0] = <np.PyUFuncGenericFunction>loop_d_lddd__As_lddd_d
ufunc_eval_jacobi_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_eval_jacobi_loops[2] = <np.PyUFuncGenericFunction>loop_D_dddD__As_fffF_F
ufunc_eval_jacobi_loops[3] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_eval_jacobi_loops[4] = <np.PyUFuncGenericFunction>loop_D_dddD__As_dddD_D
ufunc_eval_jacobi_types[0] = <char>NPY_LONG
ufunc_eval_jacobi_types[1] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[2] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[3] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[4] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[5] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[6] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[7] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[8] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[9] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[10] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[11] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[12] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[13] = <char>NPY_CFLOAT
ufunc_eval_jacobi_types[14] = <char>NPY_CFLOAT
ufunc_eval_jacobi_types[15] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[16] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[17] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[18] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[19] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[20] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[21] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[22] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[23] = <char>NPY_CDOUBLE
ufunc_eval_jacobi_types[24] = <char>NPY_CDOUBLE
ufunc_eval_jacobi_ptr[2*0] = <void*>_func_eval_jacobi_l
ufunc_eval_jacobi_ptr[2*0+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_ptr[2*1] = <void*>_func_eval_jacobi[double]
ufunc_eval_jacobi_ptr[2*1+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_ptr[2*2] = <void*>_func_eval_jacobi[double_complex]
ufunc_eval_jacobi_ptr[2*2+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_ptr[2*3] = <void*>_func_eval_jacobi[double]
ufunc_eval_jacobi_ptr[2*3+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_ptr[2*4] = <void*>_func_eval_jacobi[double_complex]
ufunc_eval_jacobi_ptr[2*4+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_data[0] = &ufunc_eval_jacobi_ptr[2*0]
ufunc_eval_jacobi_data[1] = &ufunc_eval_jacobi_ptr[2*1]
ufunc_eval_jacobi_data[2] = &ufunc_eval_jacobi_ptr[2*2]
ufunc_eval_jacobi_data[3] = &ufunc_eval_jacobi_ptr[2*3]
ufunc_eval_jacobi_data[4] = &ufunc_eval_jacobi_ptr[2*4]
eval_jacobi = np.PyUFunc_FromFuncAndData(ufunc_eval_jacobi_loops, ufunc_eval_jacobi_data, ufunc_eval_jacobi_types, 5, 4, 1, 0, "eval_jacobi", ufunc_eval_jacobi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_laguerre_loops[5]
cdef void *ufunc_eval_laguerre_ptr[10]
cdef void *ufunc_eval_laguerre_data[5]
cdef char ufunc_eval_laguerre_types[15]
cdef char *ufunc_eval_laguerre_doc = (
    "eval_laguerre(n, x, out=None)\n"
    "\n"
    "Evaluate Laguerre polynomial at a point.\n"
    "\n"
    "The Laguerre polynomials can be defined via the confluent\n"
    "hypergeometric function :math:`{}_1F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    L_n(x) = {}_1F_1(-n, 1, x).\n"
    "\n"
    "See 22.5.16 and 22.5.54 in [AS]_ for details. When :math:`n` is an\n"
    "integer the result is a polynomial of degree :math:`n`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer the result is\n"
    "    determined via the relation to the confluent hypergeometric\n"
    "    function.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Laguerre polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "L : scalar or ndarray\n"
    "    Values of the Laguerre polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_laguerre : roots and quadrature weights of Laguerre\n"
    "                 polynomials\n"
    "laguerre : Laguerre polynomial object\n"
    "numpy.polynomial.laguerre.Laguerre : Laguerre series\n"
    "eval_genlaguerre : evaluate generalized Laguerre polynomials\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_laguerre_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_laguerre_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_laguerre_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_laguerre_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_laguerre_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_laguerre_types[0] = <char>NPY_LONG
ufunc_eval_laguerre_types[1] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[2] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[3] = <char>NPY_FLOAT
ufunc_eval_laguerre_types[4] = <char>NPY_FLOAT
ufunc_eval_laguerre_types[5] = <char>NPY_FLOAT
ufunc_eval_laguerre_types[6] = <char>NPY_FLOAT
ufunc_eval_laguerre_types[7] = <char>NPY_CFLOAT
ufunc_eval_laguerre_types[8] = <char>NPY_CFLOAT
ufunc_eval_laguerre_types[9] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[10] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[11] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[12] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[13] = <char>NPY_CDOUBLE
ufunc_eval_laguerre_types[14] = <char>NPY_CDOUBLE
ufunc_eval_laguerre_ptr[2*0] = <void*>_func_eval_laguerre_l
ufunc_eval_laguerre_ptr[2*0+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_ptr[2*1] = <void*>_func_eval_laguerre[double]
ufunc_eval_laguerre_ptr[2*1+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_ptr[2*2] = <void*>_func_eval_laguerre[double_complex]
ufunc_eval_laguerre_ptr[2*2+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_ptr[2*3] = <void*>_func_eval_laguerre[double]
ufunc_eval_laguerre_ptr[2*3+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_ptr[2*4] = <void*>_func_eval_laguerre[double_complex]
ufunc_eval_laguerre_ptr[2*4+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_data[0] = &ufunc_eval_laguerre_ptr[2*0]
ufunc_eval_laguerre_data[1] = &ufunc_eval_laguerre_ptr[2*1]
ufunc_eval_laguerre_data[2] = &ufunc_eval_laguerre_ptr[2*2]
ufunc_eval_laguerre_data[3] = &ufunc_eval_laguerre_ptr[2*3]
ufunc_eval_laguerre_data[4] = &ufunc_eval_laguerre_ptr[2*4]
eval_laguerre = np.PyUFunc_FromFuncAndData(ufunc_eval_laguerre_loops, ufunc_eval_laguerre_data, ufunc_eval_laguerre_types, 5, 2, 1, 0, "eval_laguerre", ufunc_eval_laguerre_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_legendre_loops[5]
cdef void *ufunc_eval_legendre_ptr[10]
cdef void *ufunc_eval_legendre_data[5]
cdef char ufunc_eval_legendre_types[15]
cdef char *ufunc_eval_legendre_doc = (
    "eval_legendre(n, x, out=None)\n"
    "\n"
    "Evaluate Legendre polynomial at a point.\n"
    "\n"
    "The Legendre polynomials can be defined via the Gauss\n"
    "hypergeometric function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_n(x) = {}_2F_1(-n, n + 1; 1; (1 - x)/2).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`. See 22.5.49 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Legendre polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "P : scalar or ndarray\n"
    "    Values of the Legendre polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_legendre : roots and quadrature weights of Legendre\n"
    "                 polynomials\n"
    "legendre : Legendre polynomial object\n"
    "hyp2f1 : Gauss hypergeometric function\n"
    "numpy.polynomial.legendre.Legendre : Legendre series\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import eval_legendre\n"
    "\n"
    "Evaluate the zero-order Legendre polynomial at x = 0\n"
    "\n"
    ">>> eval_legendre(0, 0)\n"
    "1.0\n"
    "\n"
    "Evaluate the first-order Legendre polynomial between -1 and 1\n"
    "\n"
    ">>> X = np.linspace(-1, 1, 5)  # Domain of Legendre polynomials\n"
    ">>> eval_legendre(1, X)\n"
    "array([-1. , -0.5,  0. ,  0.5,  1. ])\n"
    "\n"
    "Evaluate Legendre polynomials of order 0 through 4 at x = 0\n"
    "\n"
    ">>> N = range(0, 5)\n"
    ">>> eval_legendre(N, 0)\n"
    "array([ 1.   ,  0.   , -0.5  ,  0.   ,  0.375])\n"
    "\n"
    "Plot Legendre polynomials of order 0 through 4\n"
    "\n"
    ">>> X = np.linspace(-1, 1)\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> for n in range(0, 5):\n"
    "...     y = eval_legendre(n, X)\n"
    "...     plt.plot(X, y, label=r'$P_{}(x)$'.format(n))\n"
    "\n"
    ">>> plt.title(\"Legendre Polynomials\")\n"
    ">>> plt.xlabel(\"x\")\n"
    ">>> plt.ylabel(r'$P_n(x)$')\n"
    ">>> plt.legend(loc='lower right')\n"
    ">>> plt.show()")
ufunc_eval_legendre_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_legendre_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_legendre_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_legendre_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_legendre_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_legendre_types[0] = <char>NPY_LONG
ufunc_eval_legendre_types[1] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[2] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[3] = <char>NPY_FLOAT
ufunc_eval_legendre_types[4] = <char>NPY_FLOAT
ufunc_eval_legendre_types[5] = <char>NPY_FLOAT
ufunc_eval_legendre_types[6] = <char>NPY_FLOAT
ufunc_eval_legendre_types[7] = <char>NPY_CFLOAT
ufunc_eval_legendre_types[8] = <char>NPY_CFLOAT
ufunc_eval_legendre_types[9] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[10] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[11] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[12] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[13] = <char>NPY_CDOUBLE
ufunc_eval_legendre_types[14] = <char>NPY_CDOUBLE
ufunc_eval_legendre_ptr[2*0] = <void*>_func_eval_legendre_l
ufunc_eval_legendre_ptr[2*0+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_ptr[2*1] = <void*>_func_eval_legendre[double]
ufunc_eval_legendre_ptr[2*1+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_ptr[2*2] = <void*>_func_eval_legendre[double_complex]
ufunc_eval_legendre_ptr[2*2+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_ptr[2*3] = <void*>_func_eval_legendre[double]
ufunc_eval_legendre_ptr[2*3+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_ptr[2*4] = <void*>_func_eval_legendre[double_complex]
ufunc_eval_legendre_ptr[2*4+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_data[0] = &ufunc_eval_legendre_ptr[2*0]
ufunc_eval_legendre_data[1] = &ufunc_eval_legendre_ptr[2*1]
ufunc_eval_legendre_data[2] = &ufunc_eval_legendre_ptr[2*2]
ufunc_eval_legendre_data[3] = &ufunc_eval_legendre_ptr[2*3]
ufunc_eval_legendre_data[4] = &ufunc_eval_legendre_ptr[2*4]
eval_legendre = np.PyUFunc_FromFuncAndData(ufunc_eval_legendre_loops, ufunc_eval_legendre_data, ufunc_eval_legendre_types, 5, 2, 1, 0, "eval_legendre", ufunc_eval_legendre_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_sh_chebyt_loops[5]
cdef void *ufunc_eval_sh_chebyt_ptr[10]
cdef void *ufunc_eval_sh_chebyt_data[5]
cdef char ufunc_eval_sh_chebyt_types[15]
cdef char *ufunc_eval_sh_chebyt_doc = (
    "eval_sh_chebyt(n, x, out=None)\n"
    "\n"
    "Evaluate shifted Chebyshev polynomial of the first kind at a\n"
    "point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    T_n^*(x) = T_n(2x - 1)\n"
    "\n"
    "where :math:`T_n` is a Chebyshev polynomial of the first kind. See\n"
    "22.5.14 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `eval_chebyt`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the shifted Chebyshev polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "T : scalar or ndarray\n"
    "    Values of the shifted Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_sh_chebyt : roots and quadrature weights of shifted\n"
    "                  Chebyshev polynomials of the first kind\n"
    "sh_chebyt : shifted Chebyshev polynomial object\n"
    "eval_chebyt : evaluate Chebyshev polynomials of the first kind\n"
    "numpy.polynomial.chebyshev.Chebyshev : Chebyshev series\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_sh_chebyt_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_sh_chebyt_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_sh_chebyt_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_sh_chebyt_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_sh_chebyt_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_sh_chebyt_types[0] = <char>NPY_LONG
ufunc_eval_sh_chebyt_types[1] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[2] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[3] = <char>NPY_FLOAT
ufunc_eval_sh_chebyt_types[4] = <char>NPY_FLOAT
ufunc_eval_sh_chebyt_types[5] = <char>NPY_FLOAT
ufunc_eval_sh_chebyt_types[6] = <char>NPY_FLOAT
ufunc_eval_sh_chebyt_types[7] = <char>NPY_CFLOAT
ufunc_eval_sh_chebyt_types[8] = <char>NPY_CFLOAT
ufunc_eval_sh_chebyt_types[9] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[10] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[11] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[12] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[13] = <char>NPY_CDOUBLE
ufunc_eval_sh_chebyt_types[14] = <char>NPY_CDOUBLE
ufunc_eval_sh_chebyt_ptr[2*0] = <void*>_func_eval_sh_chebyt_l
ufunc_eval_sh_chebyt_ptr[2*0+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_ptr[2*1] = <void*>_func_eval_sh_chebyt[double]
ufunc_eval_sh_chebyt_ptr[2*1+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_ptr[2*2] = <void*>_func_eval_sh_chebyt[double_complex]
ufunc_eval_sh_chebyt_ptr[2*2+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_ptr[2*3] = <void*>_func_eval_sh_chebyt[double]
ufunc_eval_sh_chebyt_ptr[2*3+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_ptr[2*4] = <void*>_func_eval_sh_chebyt[double_complex]
ufunc_eval_sh_chebyt_ptr[2*4+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_data[0] = &ufunc_eval_sh_chebyt_ptr[2*0]
ufunc_eval_sh_chebyt_data[1] = &ufunc_eval_sh_chebyt_ptr[2*1]
ufunc_eval_sh_chebyt_data[2] = &ufunc_eval_sh_chebyt_ptr[2*2]
ufunc_eval_sh_chebyt_data[3] = &ufunc_eval_sh_chebyt_ptr[2*3]
ufunc_eval_sh_chebyt_data[4] = &ufunc_eval_sh_chebyt_ptr[2*4]
eval_sh_chebyt = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_chebyt_loops, ufunc_eval_sh_chebyt_data, ufunc_eval_sh_chebyt_types, 5, 2, 1, 0, "eval_sh_chebyt", ufunc_eval_sh_chebyt_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_sh_chebyu_loops[5]
cdef void *ufunc_eval_sh_chebyu_ptr[10]
cdef void *ufunc_eval_sh_chebyu_data[5]
cdef char ufunc_eval_sh_chebyu_types[15]
cdef char *ufunc_eval_sh_chebyu_doc = (
    "eval_sh_chebyu(n, x, out=None)\n"
    "\n"
    "Evaluate shifted Chebyshev polynomial of the second kind at a\n"
    "point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    U_n^*(x) = U_n(2x - 1)\n"
    "\n"
    "where :math:`U_n` is a Chebyshev polynomial of the first kind. See\n"
    "22.5.15 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `eval_chebyu`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the shifted Chebyshev polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "U : scalar or ndarray\n"
    "    Values of the shifted Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_sh_chebyu : roots and quadrature weights of shifted\n"
    "                  Chebychev polynomials of the second kind\n"
    "sh_chebyu : shifted Chebyshev polynomial object\n"
    "eval_chebyu : evaluate Chebyshev polynomials of the second kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_sh_chebyu_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_sh_chebyu_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_sh_chebyu_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_sh_chebyu_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_sh_chebyu_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_sh_chebyu_types[0] = <char>NPY_LONG
ufunc_eval_sh_chebyu_types[1] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[2] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[3] = <char>NPY_FLOAT
ufunc_eval_sh_chebyu_types[4] = <char>NPY_FLOAT
ufunc_eval_sh_chebyu_types[5] = <char>NPY_FLOAT
ufunc_eval_sh_chebyu_types[6] = <char>NPY_FLOAT
ufunc_eval_sh_chebyu_types[7] = <char>NPY_CFLOAT
ufunc_eval_sh_chebyu_types[8] = <char>NPY_CFLOAT
ufunc_eval_sh_chebyu_types[9] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[10] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[11] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[12] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[13] = <char>NPY_CDOUBLE
ufunc_eval_sh_chebyu_types[14] = <char>NPY_CDOUBLE
ufunc_eval_sh_chebyu_ptr[2*0] = <void*>_func_eval_sh_chebyu_l
ufunc_eval_sh_chebyu_ptr[2*0+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_ptr[2*1] = <void*>_func_eval_sh_chebyu[double]
ufunc_eval_sh_chebyu_ptr[2*1+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_ptr[2*2] = <void*>_func_eval_sh_chebyu[double_complex]
ufunc_eval_sh_chebyu_ptr[2*2+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_ptr[2*3] = <void*>_func_eval_sh_chebyu[double]
ufunc_eval_sh_chebyu_ptr[2*3+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_ptr[2*4] = <void*>_func_eval_sh_chebyu[double_complex]
ufunc_eval_sh_chebyu_ptr[2*4+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_data[0] = &ufunc_eval_sh_chebyu_ptr[2*0]
ufunc_eval_sh_chebyu_data[1] = &ufunc_eval_sh_chebyu_ptr[2*1]
ufunc_eval_sh_chebyu_data[2] = &ufunc_eval_sh_chebyu_ptr[2*2]
ufunc_eval_sh_chebyu_data[3] = &ufunc_eval_sh_chebyu_ptr[2*3]
ufunc_eval_sh_chebyu_data[4] = &ufunc_eval_sh_chebyu_ptr[2*4]
eval_sh_chebyu = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_chebyu_loops, ufunc_eval_sh_chebyu_data, ufunc_eval_sh_chebyu_types, 5, 2, 1, 0, "eval_sh_chebyu", ufunc_eval_sh_chebyu_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_sh_jacobi_loops[5]
cdef void *ufunc_eval_sh_jacobi_ptr[10]
cdef void *ufunc_eval_sh_jacobi_data[5]
cdef char ufunc_eval_sh_jacobi_types[25]
cdef char *ufunc_eval_sh_jacobi_doc = (
    "eval_sh_jacobi(n, p, q, x, out=None)\n"
    "\n"
    "Evaluate shifted Jacobi polynomial at a point.\n"
    "\n"
    "Defined by\n"
    "\n"
    ".. math::\n"
    "\n"
    "    G_n^{(p, q)}(x)\n"
    "      = \\binom{2n + p - 1}{n}^{-1} P_n^{(p - q, q - 1)}(2x - 1),\n"
    "\n"
    "where :math:`P_n^{(\\cdot, \\cdot)}` is the n-th Jacobi\n"
    "polynomial. See 22.5.2 in [AS]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : int\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `binom` and `eval_jacobi`.\n"
    "p : float\n"
    "    Parameter\n"
    "q : float\n"
    "    Parameter\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "G : scalar or ndarray\n"
    "    Values of the shifted Jacobi polynomial.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_sh_jacobi : roots and quadrature weights of shifted Jacobi\n"
    "                  polynomials\n"
    "sh_jacobi : shifted Jacobi polynomial object\n"
    "eval_jacobi : evaluate Jacobi polynomials\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_sh_jacobi_loops[0] = <np.PyUFuncGenericFunction>loop_d_lddd__As_lddd_d
ufunc_eval_sh_jacobi_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_eval_sh_jacobi_loops[2] = <np.PyUFuncGenericFunction>loop_D_dddD__As_fffF_F
ufunc_eval_sh_jacobi_loops[3] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_eval_sh_jacobi_loops[4] = <np.PyUFuncGenericFunction>loop_D_dddD__As_dddD_D
ufunc_eval_sh_jacobi_types[0] = <char>NPY_LONG
ufunc_eval_sh_jacobi_types[1] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[2] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[3] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[4] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[5] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[6] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[7] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[8] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[9] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[10] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[11] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[12] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[13] = <char>NPY_CFLOAT
ufunc_eval_sh_jacobi_types[14] = <char>NPY_CFLOAT
ufunc_eval_sh_jacobi_types[15] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[16] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[17] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[18] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[19] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[20] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[21] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[22] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[23] = <char>NPY_CDOUBLE
ufunc_eval_sh_jacobi_types[24] = <char>NPY_CDOUBLE
ufunc_eval_sh_jacobi_ptr[2*0] = <void*>_func_eval_sh_jacobi_l
ufunc_eval_sh_jacobi_ptr[2*0+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_ptr[2*1] = <void*>_func_eval_sh_jacobi[double]
ufunc_eval_sh_jacobi_ptr[2*1+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_ptr[2*2] = <void*>_func_eval_sh_jacobi[double_complex]
ufunc_eval_sh_jacobi_ptr[2*2+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_ptr[2*3] = <void*>_func_eval_sh_jacobi[double]
ufunc_eval_sh_jacobi_ptr[2*3+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_ptr[2*4] = <void*>_func_eval_sh_jacobi[double_complex]
ufunc_eval_sh_jacobi_ptr[2*4+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_data[0] = &ufunc_eval_sh_jacobi_ptr[2*0]
ufunc_eval_sh_jacobi_data[1] = &ufunc_eval_sh_jacobi_ptr[2*1]
ufunc_eval_sh_jacobi_data[2] = &ufunc_eval_sh_jacobi_ptr[2*2]
ufunc_eval_sh_jacobi_data[3] = &ufunc_eval_sh_jacobi_ptr[2*3]
ufunc_eval_sh_jacobi_data[4] = &ufunc_eval_sh_jacobi_ptr[2*4]
eval_sh_jacobi = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_jacobi_loops, ufunc_eval_sh_jacobi_data, ufunc_eval_sh_jacobi_types, 5, 4, 1, 0, "eval_sh_jacobi", ufunc_eval_sh_jacobi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_sh_legendre_loops[5]
cdef void *ufunc_eval_sh_legendre_ptr[10]
cdef void *ufunc_eval_sh_legendre_data[5]
cdef char ufunc_eval_sh_legendre_types[15]
cdef char *ufunc_eval_sh_legendre_doc = (
    "eval_sh_legendre(n, x, out=None)\n"
    "\n"
    "Evaluate shifted Legendre polynomial at a point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_n^*(x) = P_n(2x - 1)\n"
    "\n"
    "where :math:`P_n` is a Legendre polynomial. See 2.2.11 in [AS]_\n"
    "for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the value is\n"
    "    determined via the relation to `eval_legendre`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the shifted Legendre polynomial\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "P : scalar or ndarray\n"
    "    Values of the shifted Legendre polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_sh_legendre : roots and quadrature weights of shifted\n"
    "                    Legendre polynomials\n"
    "sh_legendre : shifted Legendre polynomial object\n"
    "eval_legendre : evaluate Legendre polynomials\n"
    "numpy.polynomial.legendre.Legendre : Legendre series\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [AS] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_eval_sh_legendre_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_sh_legendre_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_sh_legendre_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_sh_legendre_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_sh_legendre_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_sh_legendre_types[0] = <char>NPY_LONG
ufunc_eval_sh_legendre_types[1] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[2] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[3] = <char>NPY_FLOAT
ufunc_eval_sh_legendre_types[4] = <char>NPY_FLOAT
ufunc_eval_sh_legendre_types[5] = <char>NPY_FLOAT
ufunc_eval_sh_legendre_types[6] = <char>NPY_FLOAT
ufunc_eval_sh_legendre_types[7] = <char>NPY_CFLOAT
ufunc_eval_sh_legendre_types[8] = <char>NPY_CFLOAT
ufunc_eval_sh_legendre_types[9] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[10] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[11] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[12] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[13] = <char>NPY_CDOUBLE
ufunc_eval_sh_legendre_types[14] = <char>NPY_CDOUBLE
ufunc_eval_sh_legendre_ptr[2*0] = <void*>_func_eval_sh_legendre_l
ufunc_eval_sh_legendre_ptr[2*0+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_ptr[2*1] = <void*>_func_eval_sh_legendre[double]
ufunc_eval_sh_legendre_ptr[2*1+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_ptr[2*2] = <void*>_func_eval_sh_legendre[double_complex]
ufunc_eval_sh_legendre_ptr[2*2+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_ptr[2*3] = <void*>_func_eval_sh_legendre[double]
ufunc_eval_sh_legendre_ptr[2*3+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_ptr[2*4] = <void*>_func_eval_sh_legendre[double_complex]
ufunc_eval_sh_legendre_ptr[2*4+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_data[0] = &ufunc_eval_sh_legendre_ptr[2*0]
ufunc_eval_sh_legendre_data[1] = &ufunc_eval_sh_legendre_ptr[2*1]
ufunc_eval_sh_legendre_data[2] = &ufunc_eval_sh_legendre_ptr[2*2]
ufunc_eval_sh_legendre_data[3] = &ufunc_eval_sh_legendre_ptr[2*3]
ufunc_eval_sh_legendre_data[4] = &ufunc_eval_sh_legendre_ptr[2*4]
eval_sh_legendre = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_legendre_loops, ufunc_eval_sh_legendre_data, ufunc_eval_sh_legendre_types, 5, 2, 1, 0, "eval_sh_legendre", ufunc_eval_sh_legendre_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_exp1_loops[4]
cdef void *ufunc_exp1_ptr[8]
cdef void *ufunc_exp1_data[4]
cdef char ufunc_exp1_types[8]
cdef char *ufunc_exp1_doc = (
    "exp1(z, out=None)\n"
    "\n"
    "Exponential integral E1.\n"
    "\n"
    "For complex :math:`z \\ne 0` the exponential integral can be defined as\n"
    "[1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "   E_1(z) = \\int_z^\\infty \\frac{e^{-t}}{t} dt,\n"
    "\n"
    "where the path of the integral does not cross the negative real\n"
    "axis or pass through the origin.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z: array_like\n"
    "    Real or complex argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the exponential integral E1\n"
    "\n"
    "See Also\n"
    "--------\n"
    "expi : exponential integral :math:`Ei`\n"
    "expn : generalization of :math:`E_1`\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For :math:`x > 0` it is related to the exponential integral\n"
    ":math:`Ei` (see `expi`) via the relation\n"
    "\n"
    ".. math::\n"
    "\n"
    "   E_1(x) = -Ei(-x).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Digital Library of Mathematical Functions, 6.2.1\n"
    "       https://dlmf.nist.gov/6.2#E1\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It has a pole at 0.\n"
    "\n"
    ">>> sc.exp1(0)\n"
    "inf\n"
    "\n"
    "It has a branch cut on the negative real axis.\n"
    "\n"
    ">>> sc.exp1(-1)\n"
    "nan\n"
    ">>> sc.exp1(complex(-1, 0))\n"
    "(-1.8951178163559368-3.141592653589793j)\n"
    ">>> sc.exp1(complex(-1, -0.0))\n"
    "(-1.8951178163559368+3.141592653589793j)\n"
    "\n"
    "It approaches 0 along the positive real axis.\n"
    "\n"
    ">>> sc.exp1([1, 10, 100, 1000])\n"
    "array([2.19383934e-01, 4.15696893e-06, 3.68359776e-46, 0.00000000e+00])\n"
    "\n"
    "It is related to `expi`.\n"
    "\n"
    ">>> x = np.array([1, 2, 3, 4])\n"
    ">>> sc.exp1(x)\n"
    "array([0.21938393, 0.04890051, 0.01304838, 0.00377935])\n"
    ">>> -sc.expi(-x)\n"
    "array([0.21938393, 0.04890051, 0.01304838, 0.00377935])")
ufunc_exp1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_exp1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_exp1_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_exp1_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_exp1_types[0] = <char>NPY_FLOAT
ufunc_exp1_types[1] = <char>NPY_FLOAT
ufunc_exp1_types[2] = <char>NPY_DOUBLE
ufunc_exp1_types[3] = <char>NPY_DOUBLE
ufunc_exp1_types[4] = <char>NPY_CFLOAT
ufunc_exp1_types[5] = <char>NPY_CFLOAT
ufunc_exp1_types[6] = <char>NPY_CDOUBLE
ufunc_exp1_types[7] = <char>NPY_CDOUBLE
ufunc_exp1_ptr[2*0] = <void*>_func_exp1_wrap
ufunc_exp1_ptr[2*0+1] = <void*>(<char*>"exp1")
ufunc_exp1_ptr[2*1] = <void*>_func_exp1_wrap
ufunc_exp1_ptr[2*1+1] = <void*>(<char*>"exp1")
ufunc_exp1_ptr[2*2] = <void*>_func_cexp1_wrap
ufunc_exp1_ptr[2*2+1] = <void*>(<char*>"exp1")
ufunc_exp1_ptr[2*3] = <void*>_func_cexp1_wrap
ufunc_exp1_ptr[2*3+1] = <void*>(<char*>"exp1")
ufunc_exp1_data[0] = &ufunc_exp1_ptr[2*0]
ufunc_exp1_data[1] = &ufunc_exp1_ptr[2*1]
ufunc_exp1_data[2] = &ufunc_exp1_ptr[2*2]
ufunc_exp1_data[3] = &ufunc_exp1_ptr[2*3]
exp1 = np.PyUFunc_FromFuncAndData(ufunc_exp1_loops, ufunc_exp1_data, ufunc_exp1_types, 4, 1, 1, 0, "exp1", ufunc_exp1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_exp10_loops[2]
cdef void *ufunc_exp10_ptr[4]
cdef void *ufunc_exp10_data[2]
cdef char ufunc_exp10_types[4]
cdef char *ufunc_exp10_doc = (
    "exp10(x, out=None)\n"
    "\n"
    "Compute ``10**x`` element-wise.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    `x` must contain real numbers.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    ``10**x``, computed element-wise.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import exp10\n"
    "\n"
    ">>> exp10(3)\n"
    "1000.0\n"
    ">>> x = np.array([[-1, -0.5, 0], [0.5, 1, 1.5]])\n"
    ">>> exp10(x)\n"
    "array([[  0.1       ,   0.31622777,   1.        ],\n"
    "       [  3.16227766,  10.        ,  31.6227766 ]])")
ufunc_exp10_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_exp10_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_exp10_types[0] = <char>NPY_FLOAT
ufunc_exp10_types[1] = <char>NPY_FLOAT
ufunc_exp10_types[2] = <char>NPY_DOUBLE
ufunc_exp10_types[3] = <char>NPY_DOUBLE
ufunc_exp10_ptr[2*0] = <void*>_func_exp10
ufunc_exp10_ptr[2*0+1] = <void*>(<char*>"exp10")
ufunc_exp10_ptr[2*1] = <void*>_func_exp10
ufunc_exp10_ptr[2*1+1] = <void*>(<char*>"exp10")
ufunc_exp10_data[0] = &ufunc_exp10_ptr[2*0]
ufunc_exp10_data[1] = &ufunc_exp10_ptr[2*1]
exp10 = np.PyUFunc_FromFuncAndData(ufunc_exp10_loops, ufunc_exp10_data, ufunc_exp10_types, 2, 1, 1, 0, "exp10", ufunc_exp10_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_exp2_loops[2]
cdef void *ufunc_exp2_ptr[4]
cdef void *ufunc_exp2_data[2]
cdef char ufunc_exp2_types[4]
cdef char *ufunc_exp2_doc = (
    "exp2(x, out=None)\n"
    "\n"
    "Compute ``2**x`` element-wise.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    `x` must contain real numbers.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    ``2**x``, computed element-wise.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import exp2\n"
    "\n"
    ">>> exp2(3)\n"
    "8.0\n"
    ">>> x = np.array([[-1, -0.5, 0], [0.5, 1, 1.5]])\n"
    ">>> exp2(x)\n"
    "array([[ 0.5       ,  0.70710678,  1.        ],\n"
    "       [ 1.41421356,  2.        ,  2.82842712]])")
ufunc_exp2_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_exp2_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_exp2_types[0] = <char>NPY_FLOAT
ufunc_exp2_types[1] = <char>NPY_FLOAT
ufunc_exp2_types[2] = <char>NPY_DOUBLE
ufunc_exp2_types[3] = <char>NPY_DOUBLE
ufunc_exp2_ptr[2*0] = <void*>_func_exp2
ufunc_exp2_ptr[2*0+1] = <void*>(<char*>"exp2")
ufunc_exp2_ptr[2*1] = <void*>_func_exp2
ufunc_exp2_ptr[2*1+1] = <void*>(<char*>"exp2")
ufunc_exp2_data[0] = &ufunc_exp2_ptr[2*0]
ufunc_exp2_data[1] = &ufunc_exp2_ptr[2*1]
exp2 = np.PyUFunc_FromFuncAndData(ufunc_exp2_loops, ufunc_exp2_data, ufunc_exp2_types, 2, 1, 1, 0, "exp2", ufunc_exp2_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_expi_loops[4]
cdef void *ufunc_expi_ptr[8]
cdef void *ufunc_expi_data[4]
cdef char ufunc_expi_types[8]
cdef char *ufunc_expi_doc = (
    "expi(x, out=None)\n"
    "\n"
    "Exponential integral Ei.\n"
    "\n"
    "For real :math:`x`, the exponential integral is defined as [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    Ei(x) = \\int_{-\\infty}^x \\frac{e^t}{t} dt.\n"
    "\n"
    "For :math:`x > 0` the integral is understood as a Cauchy principal\n"
    "value.\n"
    "\n"
    "It is extended to the complex plane by analytic continuation of\n"
    "the function on the interval :math:`(0, \\infty)`. The complex\n"
    "variant has a branch cut on the negative real axis.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real or complex valued argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the exponential integral\n"
    "\n"
    "See Also\n"
    "--------\n"
    "exp1 : Exponential integral :math:`E_1`\n"
    "expn : Generalized exponential integral :math:`E_n`\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The exponential integrals :math:`E_1` and :math:`Ei` satisfy the\n"
    "relation\n"
    "\n"
    ".. math::\n"
    "\n"
    "    E_1(x) = -Ei(-x)\n"
    "\n"
    "for :math:`x > 0`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Digital Library of Mathematical Functions, 6.2.5\n"
    "       https://dlmf.nist.gov/6.2#E5\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is related to `exp1`.\n"
    "\n"
    ">>> x = np.array([1, 2, 3, 4])\n"
    ">>> -sc.expi(-x)\n"
    "array([0.21938393, 0.04890051, 0.01304838, 0.00377935])\n"
    ">>> sc.exp1(x)\n"
    "array([0.21938393, 0.04890051, 0.01304838, 0.00377935])\n"
    "\n"
    "The complex variant has a branch cut on the negative real axis.\n"
    "\n"
    ">>> sc.expi(-1 + 1e-12j)\n"
    "(-0.21938393439552062+3.1415926535894254j)\n"
    ">>> sc.expi(-1 - 1e-12j)\n"
    "(-0.21938393439552062-3.1415926535894254j)\n"
    "\n"
    "As the complex variant approaches the branch cut, the real parts\n"
    "approach the value of the real variant.\n"
    "\n"
    ">>> sc.expi(-1)\n"
    "-0.21938393439552062\n"
    "\n"
    "The SciPy implementation returns the real variant for complex\n"
    "values on the branch cut.\n"
    "\n"
    ">>> sc.expi(complex(-1, 0.0))\n"
    "(-0.21938393439552062-0j)\n"
    ">>> sc.expi(complex(-1, -0.0))\n"
    "(-0.21938393439552062-0j)")
ufunc_expi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_expi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_expi_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_expi_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_expi_types[0] = <char>NPY_FLOAT
ufunc_expi_types[1] = <char>NPY_FLOAT
ufunc_expi_types[2] = <char>NPY_DOUBLE
ufunc_expi_types[3] = <char>NPY_DOUBLE
ufunc_expi_types[4] = <char>NPY_CFLOAT
ufunc_expi_types[5] = <char>NPY_CFLOAT
ufunc_expi_types[6] = <char>NPY_CDOUBLE
ufunc_expi_types[7] = <char>NPY_CDOUBLE
ufunc_expi_ptr[2*0] = <void*>_func_expi_wrap
ufunc_expi_ptr[2*0+1] = <void*>(<char*>"expi")
ufunc_expi_ptr[2*1] = <void*>_func_expi_wrap
ufunc_expi_ptr[2*1+1] = <void*>(<char*>"expi")
ufunc_expi_ptr[2*2] = <void*>_func_cexpi_wrap
ufunc_expi_ptr[2*2+1] = <void*>(<char*>"expi")
ufunc_expi_ptr[2*3] = <void*>_func_cexpi_wrap
ufunc_expi_ptr[2*3+1] = <void*>(<char*>"expi")
ufunc_expi_data[0] = &ufunc_expi_ptr[2*0]
ufunc_expi_data[1] = &ufunc_expi_ptr[2*1]
ufunc_expi_data[2] = &ufunc_expi_ptr[2*2]
ufunc_expi_data[3] = &ufunc_expi_ptr[2*3]
expi = np.PyUFunc_FromFuncAndData(ufunc_expi_loops, ufunc_expi_data, ufunc_expi_types, 4, 1, 1, 0, "expi", ufunc_expi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_expit_loops[3]
cdef void *ufunc_expit_ptr[6]
cdef void *ufunc_expit_data[3]
cdef char ufunc_expit_types[6]
cdef char *ufunc_expit_doc = (
    "expit(x, out=None)\n"
    "\n"
    "Expit (a.k.a. logistic sigmoid) ufunc for ndarrays.\n"
    "\n"
    "The expit function, also known as the logistic sigmoid function, is\n"
    "defined as ``expit(x) = 1/(1+exp(-x))``.  It is the inverse of the\n"
    "logit function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : ndarray\n"
    "    The ndarray to apply expit to element-wise.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    An ndarray of the same shape as x. Its entries\n"
    "    are `expit` of the corresponding entry of x.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "logit\n"
    "\n"
    "Notes\n"
    "-----\n"
    "As a ufunc expit takes a number of optional\n"
    "keyword arguments. For more information\n"
    "see `ufuncs <https://docs.scipy.org/doc/numpy/reference/ufuncs.html>`_\n"
    "\n"
    ".. versionadded:: 0.10.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import expit, logit\n"
    "\n"
    ">>> expit([-np.inf, -1.5, 0, 1.5, np.inf])\n"
    "array([ 0.        ,  0.18242552,  0.5       ,  0.81757448,  1.        ])\n"
    "\n"
    "`logit` is the inverse of `expit`:\n"
    "\n"
    ">>> logit(expit([-2.5, 0, 3.1, 5.0]))\n"
    "array([-2.5,  0. ,  3.1,  5. ])\n"
    "\n"
    "Plot expit(x) for x in [-6, 6]:\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-6, 6, 121)\n"
    ">>> y = expit(x)\n"
    ">>> plt.plot(x, y)\n"
    ">>> plt.grid()\n"
    ">>> plt.xlim(-6, 6)\n"
    ">>> plt.xlabel('x')\n"
    ">>> plt.title('expit(x)')\n"
    ">>> plt.show()")
ufunc_expit_loops[0] = <np.PyUFuncGenericFunction>loop_f_f__As_f_f
ufunc_expit_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_expit_loops[2] = <np.PyUFuncGenericFunction>loop_g_g__As_g_g
ufunc_expit_types[0] = <char>NPY_FLOAT
ufunc_expit_types[1] = <char>NPY_FLOAT
ufunc_expit_types[2] = <char>NPY_DOUBLE
ufunc_expit_types[3] = <char>NPY_DOUBLE
ufunc_expit_types[4] = <char>NPY_LONGDOUBLE
ufunc_expit_types[5] = <char>NPY_LONGDOUBLE
ufunc_expit_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_expitf
ufunc_expit_ptr[2*0+1] = <void*>(<char*>"expit")
ufunc_expit_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_expit
ufunc_expit_ptr[2*1+1] = <void*>(<char*>"expit")
ufunc_expit_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_expitl
ufunc_expit_ptr[2*2+1] = <void*>(<char*>"expit")
ufunc_expit_data[0] = &ufunc_expit_ptr[2*0]
ufunc_expit_data[1] = &ufunc_expit_ptr[2*1]
ufunc_expit_data[2] = &ufunc_expit_ptr[2*2]
expit = np.PyUFunc_FromFuncAndData(ufunc_expit_loops, ufunc_expit_data, ufunc_expit_types, 3, 1, 1, 0, "expit", ufunc_expit_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_expm1_loops[4]
cdef void *ufunc_expm1_ptr[8]
cdef void *ufunc_expm1_data[4]
cdef char ufunc_expm1_types[8]
cdef char *ufunc_expm1_doc = (
    "expm1(x, out=None)\n"
    "\n"
    "Compute ``exp(x) - 1``.\n"
    "\n"
    "When `x` is near zero, ``exp(x)`` is near 1, so the numerical calculation\n"
    "of ``exp(x) - 1`` can suffer from catastrophic loss of precision.\n"
    "``expm1(x)`` is implemented to avoid the loss of precision that occurs when\n"
    "`x` is near zero.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    `x` must contain real numbers.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    ``exp(x) - 1`` computed element-wise.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import expm1\n"
    "\n"
    ">>> expm1(1.0)\n"
    "1.7182818284590451\n"
    ">>> expm1([-0.2, -0.1, 0, 0.1, 0.2])\n"
    "array([-0.18126925, -0.09516258,  0.        ,  0.10517092,  0.22140276])\n"
    "\n"
    "The exact value of ``exp(7.5e-13) - 1`` is::\n"
    "\n"
    "    7.5000000000028125000000007031250000001318...*10**-13.\n"
    "\n"
    "Here is what ``expm1(7.5e-13)`` gives:\n"
    "\n"
    ">>> expm1(7.5e-13)\n"
    "7.5000000000028135e-13\n"
    "\n"
    "Compare that to ``exp(7.5e-13) - 1``, where the subtraction results in\n"
    "a \"catastrophic\" loss of precision:\n"
    "\n"
    ">>> np.exp(7.5e-13) - 1\n"
    "7.5006667543675576e-13")
ufunc_expm1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_expm1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_expm1_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_expm1_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_expm1_types[0] = <char>NPY_FLOAT
ufunc_expm1_types[1] = <char>NPY_FLOAT
ufunc_expm1_types[2] = <char>NPY_DOUBLE
ufunc_expm1_types[3] = <char>NPY_DOUBLE
ufunc_expm1_types[4] = <char>NPY_CFLOAT
ufunc_expm1_types[5] = <char>NPY_CFLOAT
ufunc_expm1_types[6] = <char>NPY_CDOUBLE
ufunc_expm1_types[7] = <char>NPY_CDOUBLE
ufunc_expm1_ptr[2*0] = <void*>_func_expm1
ufunc_expm1_ptr[2*0+1] = <void*>(<char*>"expm1")
ufunc_expm1_ptr[2*1] = <void*>_func_expm1
ufunc_expm1_ptr[2*1+1] = <void*>(<char*>"expm1")
ufunc_expm1_ptr[2*2] = <void*>_func_cexpm1
ufunc_expm1_ptr[2*2+1] = <void*>(<char*>"expm1")
ufunc_expm1_ptr[2*3] = <void*>_func_cexpm1
ufunc_expm1_ptr[2*3+1] = <void*>(<char*>"expm1")
ufunc_expm1_data[0] = &ufunc_expm1_ptr[2*0]
ufunc_expm1_data[1] = &ufunc_expm1_ptr[2*1]
ufunc_expm1_data[2] = &ufunc_expm1_ptr[2*2]
ufunc_expm1_data[3] = &ufunc_expm1_ptr[2*3]
expm1 = np.PyUFunc_FromFuncAndData(ufunc_expm1_loops, ufunc_expm1_data, ufunc_expm1_types, 4, 1, 1, 0, "expm1", ufunc_expm1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_expn_loops[3]
cdef void *ufunc_expn_ptr[6]
cdef void *ufunc_expn_data[3]
cdef char ufunc_expn_types[9]
cdef char *ufunc_expn_doc = (
    "expn(n, x, out=None)\n"
    "\n"
    "Generalized exponential integral En.\n"
    "\n"
    "For integer :math:`n \\geq 0` and real :math:`x \\geq 0` the\n"
    "generalized exponential integral is defined as [dlmf]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "    E_n(x) = x^{n - 1} \\int_x^\\infty \\frac{e^{-t}}{t^n} dt.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Non-negative integers\n"
    "x : array_like\n"
    "    Real argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the generalized exponential integral\n"
    "\n"
    "See Also\n"
    "--------\n"
    "exp1 : special case of :math:`E_n` for :math:`n = 1`\n"
    "expi : related to :math:`E_n` when :math:`n = 1`\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] Digital Library of Mathematical Functions, 8.19.2\n"
    "          https://dlmf.nist.gov/8.19#E2\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "Its domain is nonnegative n and x.\n"
    "\n"
    ">>> sc.expn(-1, 1.0), sc.expn(1, -1.0)\n"
    "(nan, nan)\n"
    "\n"
    "It has a pole at ``x = 0`` for ``n = 1, 2``; for larger ``n`` it\n"
    "is equal to ``1 / (n - 1)``.\n"
    "\n"
    ">>> sc.expn([0, 1, 2, 3, 4], 0)\n"
    "array([       inf,        inf, 1.        , 0.5       , 0.33333333])\n"
    "\n"
    "For n equal to 0 it reduces to ``exp(-x) / x``.\n"
    "\n"
    ">>> x = np.array([1, 2, 3, 4])\n"
    ">>> sc.expn(0, x)\n"
    "array([0.36787944, 0.06766764, 0.01659569, 0.00457891])\n"
    ">>> np.exp(-x) / x\n"
    "array([0.36787944, 0.06766764, 0.01659569, 0.00457891])\n"
    "\n"
    "For n equal to 1 it reduces to `exp1`.\n"
    "\n"
    ">>> sc.expn(1, x)\n"
    "array([0.21938393, 0.04890051, 0.01304838, 0.00377935])\n"
    ">>> sc.exp1(x)\n"
    "array([0.21938393, 0.04890051, 0.01304838, 0.00377935])")
ufunc_expn_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_expn_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_expn_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_expn_types[0] = <char>NPY_LONG
ufunc_expn_types[1] = <char>NPY_DOUBLE
ufunc_expn_types[2] = <char>NPY_DOUBLE
ufunc_expn_types[3] = <char>NPY_FLOAT
ufunc_expn_types[4] = <char>NPY_FLOAT
ufunc_expn_types[5] = <char>NPY_FLOAT
ufunc_expn_types[6] = <char>NPY_DOUBLE
ufunc_expn_types[7] = <char>NPY_DOUBLE
ufunc_expn_types[8] = <char>NPY_DOUBLE
ufunc_expn_ptr[2*0] = <void*>_func_expn
ufunc_expn_ptr[2*0+1] = <void*>(<char*>"expn")
ufunc_expn_ptr[2*1] = <void*>_func_expn_unsafe
ufunc_expn_ptr[2*1+1] = <void*>(<char*>"expn")
ufunc_expn_ptr[2*2] = <void*>_func_expn_unsafe
ufunc_expn_ptr[2*2+1] = <void*>(<char*>"expn")
ufunc_expn_data[0] = &ufunc_expn_ptr[2*0]
ufunc_expn_data[1] = &ufunc_expn_ptr[2*1]
ufunc_expn_data[2] = &ufunc_expn_ptr[2*2]
expn = np.PyUFunc_FromFuncAndData(ufunc_expn_loops, ufunc_expn_data, ufunc_expn_types, 3, 2, 1, 0, "expn", ufunc_expn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_exprel_loops[2]
cdef void *ufunc_exprel_ptr[4]
cdef void *ufunc_exprel_data[2]
cdef char ufunc_exprel_types[4]
cdef char *ufunc_exprel_doc = (
    "exprel(x, out=None)\n"
    "\n"
    "Relative error exponential, ``(exp(x) - 1)/x``.\n"
    "\n"
    "When `x` is near zero, ``exp(x)`` is near 1, so the numerical calculation\n"
    "of ``exp(x) - 1`` can suffer from catastrophic loss of precision.\n"
    "``exprel(x)`` is implemented to avoid the loss of precision that occurs when\n"
    "`x` is near zero.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : ndarray\n"
    "    Input array.  `x` must contain real numbers.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    ``(exp(x) - 1)/x``, computed element-wise.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "expm1\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 0.17.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import exprel\n"
    "\n"
    ">>> exprel(0.01)\n"
    "1.0050167084168056\n"
    ">>> exprel([-0.25, -0.1, 0, 0.1, 0.25])\n"
    "array([ 0.88479687,  0.95162582,  1.        ,  1.05170918,  1.13610167])\n"
    "\n"
    "Compare ``exprel(5e-9)`` to the naive calculation.  The exact value\n"
    "is ``1.00000000250000000416...``.\n"
    "\n"
    ">>> exprel(5e-9)\n"
    "1.0000000025\n"
    "\n"
    ">>> (np.exp(5e-9) - 1)/5e-9\n"
    "0.99999999392252903")
ufunc_exprel_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_exprel_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_exprel_types[0] = <char>NPY_FLOAT
ufunc_exprel_types[1] = <char>NPY_FLOAT
ufunc_exprel_types[2] = <char>NPY_DOUBLE
ufunc_exprel_types[3] = <char>NPY_DOUBLE
ufunc_exprel_ptr[2*0] = <void*>_func_exprel
ufunc_exprel_ptr[2*0+1] = <void*>(<char*>"exprel")
ufunc_exprel_ptr[2*1] = <void*>_func_exprel
ufunc_exprel_ptr[2*1+1] = <void*>(<char*>"exprel")
ufunc_exprel_data[0] = &ufunc_exprel_ptr[2*0]
ufunc_exprel_data[1] = &ufunc_exprel_ptr[2*1]
exprel = np.PyUFunc_FromFuncAndData(ufunc_exprel_loops, ufunc_exprel_data, ufunc_exprel_types, 2, 1, 1, 0, "exprel", ufunc_exprel_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_fdtr_loops[2]
cdef void *ufunc_fdtr_ptr[4]
cdef void *ufunc_fdtr_data[2]
cdef char ufunc_fdtr_types[8]
cdef char *ufunc_fdtr_doc = (
    "fdtr(dfn, dfd, x, out=None)\n"
    "\n"
    "F cumulative distribution function.\n"
    "\n"
    "Returns the value of the cumulative distribution function of the\n"
    "F-distribution, also known as Snedecor's F-distribution or the\n"
    "Fisher-Snedecor distribution.\n"
    "\n"
    "The F-distribution with parameters :math:`d_n` and :math:`d_d` is the\n"
    "distribution of the random variable,\n"
    "\n"
    ".. math::\n"
    "    X = \\frac{U_n/d_n}{U_d/d_d},\n"
    "\n"
    "where :math:`U_n` and :math:`U_d` are random variables distributed\n"
    ":math:`\\chi^2`, with :math:`d_n` and :math:`d_d` degrees of freedom,\n"
    "respectively.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    First parameter (positive float).\n"
    "dfd : array_like\n"
    "    Second parameter (positive float).\n"
    "x : array_like\n"
    "    Argument (nonnegative float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    The CDF of the F-distribution with parameters `dfn` and `dfd` at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "fdtrc : F distribution survival function\n"
    "fdtri : F distribution inverse cumulative distribution\n"
    "scipy.stats.f : F distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The regularized incomplete beta function is used, according to the\n"
    "formula,\n"
    "\n"
    ".. math::\n"
    "    F(d_n, d_d; x) = I_{xd_n/(d_d + xd_n)}(d_n/2, d_d/2).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `fdtr`. The F distribution is also\n"
    "available as `scipy.stats.f`. Calling `fdtr` directly can improve\n"
    "performance compared to the ``cdf`` method of `scipy.stats.f` (see last\n"
    "example below).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function for ``dfn=1`` and ``dfd=2`` at ``x=1``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import fdtr\n"
    ">>> fdtr(1, 2, 1)\n"
    "0.5773502691896258\n"
    "\n"
    "Calculate the function at several points by providing a NumPy array for\n"
    "`x`.\n"
    "\n"
    ">>> x = np.array([0.5, 2., 3.])\n"
    ">>> fdtr(1, 2, x)\n"
    "array([0.4472136 , 0.70710678, 0.77459667])\n"
    "\n"
    "Plot the function for several parameter sets.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> dfn_parameters = [1, 5, 10, 50]\n"
    ">>> dfd_parameters = [1, 1, 2, 3]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(dfn_parameters, dfd_parameters,\n"
    "...                            linestyles))\n"
    ">>> x = np.linspace(0, 30, 1000)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     dfn, dfd, style = parameter_set\n"
    "...     fdtr_vals = fdtr(dfn, dfd, x)\n"
    "...     ax.plot(x, fdtr_vals, label=rf\"$d_n={dfn},\\, d_d={dfd}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(\"$x$\")\n"
    ">>> ax.set_title(\"F distribution cumulative distribution function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The F distribution is also available as `scipy.stats.f`. Using `fdtr`\n"
    "directly can be much faster than calling the ``cdf`` method of\n"
    "`scipy.stats.f`, especially for small arrays or individual values.\n"
    "To get the same results one must use the following parametrization:\n"
    "``stats.f(dfn, dfd).cdf(x)=fdtr(dfn, dfd, x)``.\n"
    "\n"
    ">>> from scipy.stats import f\n"
    ">>> dfn, dfd = 1, 2\n"
    ">>> x = 1\n"
    ">>> fdtr_res = fdtr(dfn, dfd, x)  # this will often be faster than below\n"
    ">>> f_dist_res = f(dfn, dfd).cdf(x)\n"
    ">>> fdtr_res == f_dist_res  # test that results are equal\n"
    "True")
ufunc_fdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_fdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_fdtr_types[0] = <char>NPY_FLOAT
ufunc_fdtr_types[1] = <char>NPY_FLOAT
ufunc_fdtr_types[2] = <char>NPY_FLOAT
ufunc_fdtr_types[3] = <char>NPY_FLOAT
ufunc_fdtr_types[4] = <char>NPY_DOUBLE
ufunc_fdtr_types[5] = <char>NPY_DOUBLE
ufunc_fdtr_types[6] = <char>NPY_DOUBLE
ufunc_fdtr_types[7] = <char>NPY_DOUBLE
ufunc_fdtr_ptr[2*0] = <void*>_func_fdtr
ufunc_fdtr_ptr[2*0+1] = <void*>(<char*>"fdtr")
ufunc_fdtr_ptr[2*1] = <void*>_func_fdtr
ufunc_fdtr_ptr[2*1+1] = <void*>(<char*>"fdtr")
ufunc_fdtr_data[0] = &ufunc_fdtr_ptr[2*0]
ufunc_fdtr_data[1] = &ufunc_fdtr_ptr[2*1]
fdtr = np.PyUFunc_FromFuncAndData(ufunc_fdtr_loops, ufunc_fdtr_data, ufunc_fdtr_types, 2, 3, 1, 0, "fdtr", ufunc_fdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_fdtrc_loops[2]
cdef void *ufunc_fdtrc_ptr[4]
cdef void *ufunc_fdtrc_data[2]
cdef char ufunc_fdtrc_types[8]
cdef char *ufunc_fdtrc_doc = (
    "fdtrc(dfn, dfd, x, out=None)\n"
    "\n"
    "F survival function.\n"
    "\n"
    "Returns the complemented F-distribution function (the integral of the\n"
    "density from `x` to infinity).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    First parameter (positive float).\n"
    "dfd : array_like\n"
    "    Second parameter (positive float).\n"
    "x : array_like\n"
    "    Argument (nonnegative float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    The complemented F-distribution function with parameters `dfn` and\n"
    "    `dfd` at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "fdtr : F distribution cumulative distribution function\n"
    "fdtri : F distribution inverse cumulative distribution function\n"
    "scipy.stats.f : F distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The regularized incomplete beta function is used, according to the\n"
    "formula,\n"
    "\n"
    ".. math::\n"
    "    F(d_n, d_d; x) = I_{d_d/(d_d + xd_n)}(d_d/2, d_n/2).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `fdtrc`. The F distribution is also\n"
    "available as `scipy.stats.f`. Calling `fdtrc` directly can improve\n"
    "performance compared to the ``sf`` method of `scipy.stats.f` (see last\n"
    "example below).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function for ``dfn=1`` and ``dfd=2`` at ``x=1``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import fdtrc\n"
    ">>> fdtrc(1, 2, 1)\n"
    "0.42264973081037427\n"
    "\n"
    "Calculate the function at several points by providing a NumPy array for\n"
    "`x`.\n"
    "\n"
    ">>> x = np.array([0.5, 2., 3.])\n"
    ">>> fdtrc(1, 2, x)\n"
    "array([0.5527864 , 0.29289322, 0.22540333])\n"
    "\n"
    "Plot the function for several parameter sets.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> dfn_parameters = [1, 5, 10, 50]\n"
    ">>> dfd_parameters = [1, 1, 2, 3]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(dfn_parameters, dfd_parameters,\n"
    "...                            linestyles))\n"
    ">>> x = np.linspace(0, 30, 1000)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     dfn, dfd, style = parameter_set\n"
    "...     fdtrc_vals = fdtrc(dfn, dfd, x)\n"
    "...     ax.plot(x, fdtrc_vals, label=rf\"$d_n={dfn},\\, d_d={dfd}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(\"$x$\")\n"
    ">>> ax.set_title(\"F distribution survival function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The F distribution is also available as `scipy.stats.f`. Using `fdtrc`\n"
    "directly can be much faster than calling the ``sf`` method of\n"
    "`scipy.stats.f`, especially for small arrays or individual values.\n"
    "To get the same results one must use the following parametrization:\n"
    "``stats.f(dfn, dfd).sf(x)=fdtrc(dfn, dfd, x)``.\n"
    "\n"
    ">>> from scipy.stats import f\n"
    ">>> dfn, dfd = 1, 2\n"
    ">>> x = 1\n"
    ">>> fdtrc_res = fdtrc(dfn, dfd, x)  # this will often be faster than below\n"
    ">>> f_dist_res = f(dfn, dfd).sf(x)\n"
    ">>> f_dist_res == fdtrc_res  # test that results are equal\n"
    "True")
ufunc_fdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_fdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_fdtrc_types[0] = <char>NPY_FLOAT
ufunc_fdtrc_types[1] = <char>NPY_FLOAT
ufunc_fdtrc_types[2] = <char>NPY_FLOAT
ufunc_fdtrc_types[3] = <char>NPY_FLOAT
ufunc_fdtrc_types[4] = <char>NPY_DOUBLE
ufunc_fdtrc_types[5] = <char>NPY_DOUBLE
ufunc_fdtrc_types[6] = <char>NPY_DOUBLE
ufunc_fdtrc_types[7] = <char>NPY_DOUBLE
ufunc_fdtrc_ptr[2*0] = <void*>_func_fdtrc
ufunc_fdtrc_ptr[2*0+1] = <void*>(<char*>"fdtrc")
ufunc_fdtrc_ptr[2*1] = <void*>_func_fdtrc
ufunc_fdtrc_ptr[2*1+1] = <void*>(<char*>"fdtrc")
ufunc_fdtrc_data[0] = &ufunc_fdtrc_ptr[2*0]
ufunc_fdtrc_data[1] = &ufunc_fdtrc_ptr[2*1]
fdtrc = np.PyUFunc_FromFuncAndData(ufunc_fdtrc_loops, ufunc_fdtrc_data, ufunc_fdtrc_types, 2, 3, 1, 0, "fdtrc", ufunc_fdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_fdtri_loops[2]
cdef void *ufunc_fdtri_ptr[4]
cdef void *ufunc_fdtri_data[2]
cdef char ufunc_fdtri_types[8]
cdef char *ufunc_fdtri_doc = (
    "fdtri(dfn, dfd, p, out=None)\n"
    "\n"
    "The `p`-th quantile of the F-distribution.\n"
    "\n"
    "This function is the inverse of the F-distribution CDF, `fdtr`, returning\n"
    "the `x` such that `fdtr(dfn, dfd, x) = p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    First parameter (positive float).\n"
    "dfd : array_like\n"
    "    Second parameter (positive float).\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    The quantile corresponding to `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "fdtr : F distribution cumulative distribution function\n"
    "fdtrc : F distribution survival function\n"
    "scipy.stats.f : F distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The computation is carried out using the relation to the inverse\n"
    "regularized beta function, :math:`I^{-1}_x(a, b)`.  Let\n"
    ":math:`z = I^{-1}_p(d_d/2, d_n/2).`  Then,\n"
    "\n"
    ".. math::\n"
    "    x = \\frac{d_d (1 - z)}{d_n z}.\n"
    "\n"
    "If `p` is such that :math:`x < 0.5`, the following relation is used\n"
    "instead for improved stability: let\n"
    ":math:`z' = I^{-1}_{1 - p}(d_n/2, d_d/2).` Then,\n"
    "\n"
    ".. math::\n"
    "    x = \\frac{d_d z'}{d_n (1 - z')}.\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `fdtri`.\n"
    "\n"
    "The F distribution is also available as `scipy.stats.f`. Calling\n"
    "`fdtri` directly can improve performance compared to the ``ppf``\n"
    "method of `scipy.stats.f` (see last example below).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "`fdtri` represents the inverse of the F distribution CDF which is\n"
    "available as `fdtr`. Here, we calculate the CDF for ``df1=1``, ``df2=2``\n"
    "at ``x=3``. `fdtri` then returns ``3`` given the same values for `df1`,\n"
    "`df2` and the computed CDF value.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import fdtri, fdtr\n"
    ">>> df1, df2 = 1, 2\n"
    ">>> x = 3\n"
    ">>> cdf_value =  fdtr(df1, df2, x)\n"
    ">>> fdtri(df1, df2, cdf_value)\n"
    "3.000000000000006\n"
    "\n"
    "Calculate the function at several points by providing a NumPy array for\n"
    "`x`.\n"
    "\n"
    ">>> x = np.array([0.1, 0.4, 0.7])\n"
    ">>> fdtri(1, 2, x)\n"
    "array([0.02020202, 0.38095238, 1.92156863])\n"
    "\n"
    "Plot the function for several parameter sets.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> dfn_parameters = [50, 10, 1, 50]\n"
    ">>> dfd_parameters = [0.5, 1, 1, 5]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(dfn_parameters, dfd_parameters,\n"
    "...                            linestyles))\n"
    ">>> x = np.linspace(0, 1, 1000)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     dfn, dfd, style = parameter_set\n"
    "...     fdtri_vals = fdtri(dfn, dfd, x)\n"
    "...     ax.plot(x, fdtri_vals, label=rf\"$d_n={dfn},\\, d_d={dfd}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(\"$x$\")\n"
    ">>> title = \"F distribution inverse cumulative distribution function\"\n"
    ">>> ax.set_title(title)\n"
    ">>> ax.set_ylim(0, 30)\n"
    ">>> plt.show()\n"
    "\n"
    "The F distribution is also available as `scipy.stats.f`. Using `fdtri`\n"
    "directly can be much faster than calling the ``ppf`` method of\n"
    "`scipy.stats.f`, especially for small arrays or individual values.\n"
    "To get the same results one must use the following parametrization:\n"
    "``stats.f(dfn, dfd).ppf(x)=fdtri(dfn, dfd, x)``.\n"
    "\n"
    ">>> from scipy.stats import f\n"
    ">>> dfn, dfd = 1, 2\n"
    ">>> x = 0.7\n"
    ">>> fdtri_res = fdtri(dfn, dfd, x)  # this will often be faster than below\n"
    ">>> f_dist_res = f(dfn, dfd).ppf(x)\n"
    ">>> f_dist_res == fdtri_res  # test that results are equal\n"
    "True")
ufunc_fdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_fdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_fdtri_types[0] = <char>NPY_FLOAT
ufunc_fdtri_types[1] = <char>NPY_FLOAT
ufunc_fdtri_types[2] = <char>NPY_FLOAT
ufunc_fdtri_types[3] = <char>NPY_FLOAT
ufunc_fdtri_types[4] = <char>NPY_DOUBLE
ufunc_fdtri_types[5] = <char>NPY_DOUBLE
ufunc_fdtri_types[6] = <char>NPY_DOUBLE
ufunc_fdtri_types[7] = <char>NPY_DOUBLE
ufunc_fdtri_ptr[2*0] = <void*>_func_fdtri
ufunc_fdtri_ptr[2*0+1] = <void*>(<char*>"fdtri")
ufunc_fdtri_ptr[2*1] = <void*>_func_fdtri
ufunc_fdtri_ptr[2*1+1] = <void*>(<char*>"fdtri")
ufunc_fdtri_data[0] = &ufunc_fdtri_ptr[2*0]
ufunc_fdtri_data[1] = &ufunc_fdtri_ptr[2*1]
fdtri = np.PyUFunc_FromFuncAndData(ufunc_fdtri_loops, ufunc_fdtri_data, ufunc_fdtri_types, 2, 3, 1, 0, "fdtri", ufunc_fdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_fdtridfd_loops[2]
cdef void *ufunc_fdtridfd_ptr[4]
cdef void *ufunc_fdtridfd_data[2]
cdef char ufunc_fdtridfd_types[8]
cdef char *ufunc_fdtridfd_doc = (
    "fdtridfd(dfn, p, x, out=None)\n"
    "\n"
    "Inverse to `fdtr` vs dfd\n"
    "\n"
    "Finds the F density argument dfd such that ``fdtr(dfn, dfd, x) == p``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    First parameter (positive float).\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "x : array_like\n"
    "    Argument (nonnegative float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "dfd : scalar or ndarray\n"
    "    `dfd` such that ``fdtr(dfn, dfd, x) == p``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "fdtr : F distribution cumulative distribution function\n"
    "fdtrc : F distribution survival function\n"
    "fdtri : F distribution quantile function\n"
    "scipy.stats.f : F distribution\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the F distribution cumulative distribution function for one\n"
    "parameter set.\n"
    "\n"
    ">>> from scipy.special import fdtridfd, fdtr\n"
    ">>> dfn, dfd, x = 10, 5, 2\n"
    ">>> cdf_value = fdtr(dfn, dfd, x)\n"
    ">>> cdf_value\n"
    "0.7700248806501017\n"
    "\n"
    "Verify that `fdtridfd` recovers the original value for `dfd`:\n"
    "\n"
    ">>> fdtridfd(dfn, cdf_value, x)\n"
    "5.0")
ufunc_fdtridfd_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_fdtridfd_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_fdtridfd_types[0] = <char>NPY_FLOAT
ufunc_fdtridfd_types[1] = <char>NPY_FLOAT
ufunc_fdtridfd_types[2] = <char>NPY_FLOAT
ufunc_fdtridfd_types[3] = <char>NPY_FLOAT
ufunc_fdtridfd_types[4] = <char>NPY_DOUBLE
ufunc_fdtridfd_types[5] = <char>NPY_DOUBLE
ufunc_fdtridfd_types[6] = <char>NPY_DOUBLE
ufunc_fdtridfd_types[7] = <char>NPY_DOUBLE
ufunc_fdtridfd_ptr[2*0] = <void*>_func_cdff4_wrap
ufunc_fdtridfd_ptr[2*0+1] = <void*>(<char*>"fdtridfd")
ufunc_fdtridfd_ptr[2*1] = <void*>_func_cdff4_wrap
ufunc_fdtridfd_ptr[2*1+1] = <void*>(<char*>"fdtridfd")
ufunc_fdtridfd_data[0] = &ufunc_fdtridfd_ptr[2*0]
ufunc_fdtridfd_data[1] = &ufunc_fdtridfd_ptr[2*1]
fdtridfd = np.PyUFunc_FromFuncAndData(ufunc_fdtridfd_loops, ufunc_fdtridfd_data, ufunc_fdtridfd_types, 2, 3, 1, 0, "fdtridfd", ufunc_fdtridfd_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_fresnel_loops[4]
cdef void *ufunc_fresnel_ptr[8]
cdef void *ufunc_fresnel_data[4]
cdef char ufunc_fresnel_types[12]
cdef char *ufunc_fresnel_doc = (
    "fresnel(z, out=None)\n"
    "\n"
    "Fresnel integrals.\n"
    "\n"
    "The Fresnel integrals are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "   S(z) &= \\int_0^z \\sin(\\pi t^2 /2) dt \\\\\n"
    "   C(z) &= \\int_0^z \\cos(\\pi t^2 /2) dt.\n"
    "\n"
    "See [dlmf]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Real or complex valued argument\n"
    "out : 2-tuple of ndarrays, optional\n"
    "    Optional output arrays for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "S, C : 2-tuple of scalar or ndarray\n"
    "    Values of the Fresnel integrals\n"
    "\n"
    "See Also\n"
    "--------\n"
    "fresnel_zeros : zeros of the Fresnel integrals\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST Digital Library of Mathematical Functions\n"
    "          https://dlmf.nist.gov/7.2#iii\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "As z goes to infinity along the real axis, S and C converge to 0.5.\n"
    "\n"
    ">>> S, C = sc.fresnel([0.1, 1, 10, 100, np.inf])\n"
    ">>> S\n"
    "array([0.00052359, 0.43825915, 0.46816998, 0.4968169 , 0.5       ])\n"
    ">>> C\n"
    "array([0.09999753, 0.7798934 , 0.49989869, 0.4999999 , 0.5       ])\n"
    "\n"
    "They are related to the error function `erf`.\n"
    "\n"
    ">>> z = np.array([1, 2, 3, 4])\n"
    ">>> zeta = 0.5 * np.sqrt(np.pi) * (1 - 1j) * z\n"
    ">>> S, C = sc.fresnel(z)\n"
    ">>> C + 1j*S\n"
    "array([0.7798934 +0.43825915j, 0.48825341+0.34341568j,\n"
    "       0.60572079+0.496313j  , 0.49842603+0.42051575j])\n"
    ">>> 0.5 * (1 + 1j) * sc.erf(zeta)\n"
    "array([0.7798934 +0.43825915j, 0.48825341+0.34341568j,\n"
    "       0.60572079+0.496313j  , 0.49842603+0.42051575j])")
ufunc_fresnel_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_fresnel_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_fresnel_loops[2] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_F_FF
ufunc_fresnel_loops[3] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_D_DD
ufunc_fresnel_types[0] = <char>NPY_FLOAT
ufunc_fresnel_types[1] = <char>NPY_FLOAT
ufunc_fresnel_types[2] = <char>NPY_FLOAT
ufunc_fresnel_types[3] = <char>NPY_DOUBLE
ufunc_fresnel_types[4] = <char>NPY_DOUBLE
ufunc_fresnel_types[5] = <char>NPY_DOUBLE
ufunc_fresnel_types[6] = <char>NPY_CFLOAT
ufunc_fresnel_types[7] = <char>NPY_CFLOAT
ufunc_fresnel_types[8] = <char>NPY_CFLOAT
ufunc_fresnel_types[9] = <char>NPY_CDOUBLE
ufunc_fresnel_types[10] = <char>NPY_CDOUBLE
ufunc_fresnel_types[11] = <char>NPY_CDOUBLE
ufunc_fresnel_ptr[2*0] = <void*>_func_fresnl
ufunc_fresnel_ptr[2*0+1] = <void*>(<char*>"fresnel")
ufunc_fresnel_ptr[2*1] = <void*>_func_fresnl
ufunc_fresnel_ptr[2*1+1] = <void*>(<char*>"fresnel")
ufunc_fresnel_ptr[2*2] = <void*>_func_cfresnl_wrap
ufunc_fresnel_ptr[2*2+1] = <void*>(<char*>"fresnel")
ufunc_fresnel_ptr[2*3] = <void*>_func_cfresnl_wrap
ufunc_fresnel_ptr[2*3+1] = <void*>(<char*>"fresnel")
ufunc_fresnel_data[0] = &ufunc_fresnel_ptr[2*0]
ufunc_fresnel_data[1] = &ufunc_fresnel_ptr[2*1]
ufunc_fresnel_data[2] = &ufunc_fresnel_ptr[2*2]
ufunc_fresnel_data[3] = &ufunc_fresnel_ptr[2*3]
fresnel = np.PyUFunc_FromFuncAndData(ufunc_fresnel_loops, ufunc_fresnel_data, ufunc_fresnel_types, 4, 1, 2, 0, "fresnel", ufunc_fresnel_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gamma_loops[4]
cdef void *ufunc_gamma_ptr[8]
cdef void *ufunc_gamma_data[4]
cdef char ufunc_gamma_types[8]
cdef char *ufunc_gamma_doc = (
    "gamma(z, out=None)\n"
    "\n"
    "gamma function.\n"
    "\n"
    "The gamma function is defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "   \\Gamma(z) = \\int_0^\\infty t^{z-1} e^{-t} dt\n"
    "\n"
    "for :math:`\\Re(z) > 0` and is extended to the rest of the complex\n"
    "plane by analytic continuation. See [dlmf]_ for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Real or complex valued argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the gamma function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The gamma function is often referred to as the generalized\n"
    "factorial since :math:`\\Gamma(n + 1) = n!` for natural numbers\n"
    ":math:`n`. More generally it satisfies the recurrence relation\n"
    ":math:`\\Gamma(z + 1) = z \\cdot \\Gamma(z)` for complex :math:`z`,\n"
    "which, combined with the fact that :math:`\\Gamma(1) = 1`, implies\n"
    "the above identity for :math:`z = n`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST Digital Library of Mathematical Functions\n"
    "          https://dlmf.nist.gov/5.2#E1\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import gamma, factorial\n"
    "\n"
    ">>> gamma([0, 0.5, 1, 5])\n"
    "array([         inf,   1.77245385,   1.        ,  24.        ])\n"
    "\n"
    ">>> z = 2.5 + 1j\n"
    ">>> gamma(z)\n"
    "(0.77476210455108352+0.70763120437959293j)\n"
    ">>> gamma(z+1), z*gamma(z)  # Recurrence property\n"
    "((1.2292740569981171+2.5438401155000685j),\n"
    " (1.2292740569981158+2.5438401155000658j))\n"
    "\n"
    ">>> gamma(0.5)**2  # gamma(0.5) = sqrt(pi)\n"
    "3.1415926535897927\n"
    "\n"
    "Plot gamma(x) for real x\n"
    "\n"
    ">>> x = np.linspace(-3.5, 5.5, 2251)\n"
    ">>> y = gamma(x)\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> plt.plot(x, y, 'b', alpha=0.6, label='gamma(x)')\n"
    ">>> k = np.arange(1, 7)\n"
    ">>> plt.plot(k, factorial(k-1), 'k*', alpha=0.6,\n"
    "...          label='(x-1)!, x = 1, 2, ...')\n"
    ">>> plt.xlim(-3.5, 5.5)\n"
    ">>> plt.ylim(-10, 25)\n"
    ">>> plt.grid()\n"
    ">>> plt.xlabel('x')\n"
    ">>> plt.legend(loc='lower right')\n"
    ">>> plt.show()")
ufunc_gamma_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_gamma_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_gamma_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_gamma_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_gamma_types[0] = <char>NPY_FLOAT
ufunc_gamma_types[1] = <char>NPY_FLOAT
ufunc_gamma_types[2] = <char>NPY_DOUBLE
ufunc_gamma_types[3] = <char>NPY_DOUBLE
ufunc_gamma_types[4] = <char>NPY_CFLOAT
ufunc_gamma_types[5] = <char>NPY_CFLOAT
ufunc_gamma_types[6] = <char>NPY_CDOUBLE
ufunc_gamma_types[7] = <char>NPY_CDOUBLE
ufunc_gamma_ptr[2*0] = <void*>_func_Gamma
ufunc_gamma_ptr[2*0+1] = <void*>(<char*>"gamma")
ufunc_gamma_ptr[2*1] = <void*>_func_Gamma
ufunc_gamma_ptr[2*1+1] = <void*>(<char*>"gamma")
ufunc_gamma_ptr[2*2] = <void*>_func_cgamma
ufunc_gamma_ptr[2*2+1] = <void*>(<char*>"gamma")
ufunc_gamma_ptr[2*3] = <void*>_func_cgamma
ufunc_gamma_ptr[2*3+1] = <void*>(<char*>"gamma")
ufunc_gamma_data[0] = &ufunc_gamma_ptr[2*0]
ufunc_gamma_data[1] = &ufunc_gamma_ptr[2*1]
ufunc_gamma_data[2] = &ufunc_gamma_ptr[2*2]
ufunc_gamma_data[3] = &ufunc_gamma_ptr[2*3]
gamma = np.PyUFunc_FromFuncAndData(ufunc_gamma_loops, ufunc_gamma_data, ufunc_gamma_types, 4, 1, 1, 0, "gamma", ufunc_gamma_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gammainc_loops[2]
cdef void *ufunc_gammainc_ptr[4]
cdef void *ufunc_gammainc_data[2]
cdef char ufunc_gammainc_types[6]
cdef char *ufunc_gammainc_doc = (
    "gammainc(a, x, out=None)\n"
    "\n"
    "Regularized lower incomplete gamma function.\n"
    "\n"
    "It is defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P(a, x) = \\frac{1}{\\Gamma(a)} \\int_0^x t^{a - 1}e^{-t} dt\n"
    "\n"
    "for :math:`a > 0` and :math:`x \\geq 0`. See [dlmf]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Positive parameter\n"
    "x : array_like\n"
    "    Nonnegative argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the lower incomplete gamma function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gammaincc : regularized upper incomplete gamma function\n"
    "gammaincinv : inverse of the regularized lower incomplete gamma function\n"
    "gammainccinv : inverse of the regularized upper incomplete gamma function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The function satisfies the relation ``gammainc(a, x) +\n"
    "gammaincc(a, x) = 1`` where `gammaincc` is the regularized upper\n"
    "incomplete gamma function.\n"
    "\n"
    "The implementation largely follows that of [boost]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST Digital Library of Mathematical functions\n"
    "          https://dlmf.nist.gov/8.2#E4\n"
    ".. [boost] Maddock et. al., \"Incomplete Gamma Functions\",\n"
    "   https://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is the CDF of the gamma distribution, so it starts at 0 and\n"
    "monotonically increases to 1.\n"
    "\n"
    ">>> sc.gammainc(0.5, [0, 1, 10, 100])\n"
    "array([0.        , 0.84270079, 0.99999226, 1.        ])\n"
    "\n"
    "It is equal to one minus the upper incomplete gamma function.\n"
    "\n"
    ">>> a, x = 0.5, 0.4\n"
    ">>> sc.gammainc(a, x)\n"
    "0.6289066304773024\n"
    ">>> 1 - sc.gammaincc(a, x)\n"
    "0.6289066304773024")
ufunc_gammainc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_gammainc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_gammainc_types[0] = <char>NPY_FLOAT
ufunc_gammainc_types[1] = <char>NPY_FLOAT
ufunc_gammainc_types[2] = <char>NPY_FLOAT
ufunc_gammainc_types[3] = <char>NPY_DOUBLE
ufunc_gammainc_types[4] = <char>NPY_DOUBLE
ufunc_gammainc_types[5] = <char>NPY_DOUBLE
ufunc_gammainc_ptr[2*0] = <void*>_func_igam
ufunc_gammainc_ptr[2*0+1] = <void*>(<char*>"gammainc")
ufunc_gammainc_ptr[2*1] = <void*>_func_igam
ufunc_gammainc_ptr[2*1+1] = <void*>(<char*>"gammainc")
ufunc_gammainc_data[0] = &ufunc_gammainc_ptr[2*0]
ufunc_gammainc_data[1] = &ufunc_gammainc_ptr[2*1]
gammainc = np.PyUFunc_FromFuncAndData(ufunc_gammainc_loops, ufunc_gammainc_data, ufunc_gammainc_types, 2, 2, 1, 0, "gammainc", ufunc_gammainc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gammaincc_loops[2]
cdef void *ufunc_gammaincc_ptr[4]
cdef void *ufunc_gammaincc_data[2]
cdef char ufunc_gammaincc_types[6]
cdef char *ufunc_gammaincc_doc = (
    "gammaincc(a, x, out=None)\n"
    "\n"
    "Regularized upper incomplete gamma function.\n"
    "\n"
    "It is defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    Q(a, x) = \\frac{1}{\\Gamma(a)} \\int_x^\\infty t^{a - 1}e^{-t} dt\n"
    "\n"
    "for :math:`a > 0` and :math:`x \\geq 0`. See [dlmf]_ for details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Positive parameter\n"
    "x : array_like\n"
    "    Nonnegative argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the upper incomplete gamma function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gammainc : regularized lower incomplete gamma function\n"
    "gammaincinv : inverse of the regularized lower incomplete gamma function\n"
    "gammainccinv : inverse of the regularized upper incomplete gamma function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The function satisfies the relation ``gammainc(a, x) +\n"
    "gammaincc(a, x) = 1`` where `gammainc` is the regularized lower\n"
    "incomplete gamma function.\n"
    "\n"
    "The implementation largely follows that of [boost]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST Digital Library of Mathematical functions\n"
    "          https://dlmf.nist.gov/8.2#E4\n"
    ".. [boost] Maddock et. al., \"Incomplete Gamma Functions\",\n"
    "   https://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is the survival function of the gamma distribution, so it\n"
    "starts at 1 and monotonically decreases to 0.\n"
    "\n"
    ">>> sc.gammaincc(0.5, [0, 1, 10, 100, 1000])\n"
    "array([1.00000000e+00, 1.57299207e-01, 7.74421643e-06, 2.08848758e-45,\n"
    "       0.00000000e+00])\n"
    "\n"
    "It is equal to one minus the lower incomplete gamma function.\n"
    "\n"
    ">>> a, x = 0.5, 0.4\n"
    ">>> sc.gammaincc(a, x)\n"
    "0.37109336952269756\n"
    ">>> 1 - sc.gammainc(a, x)\n"
    "0.37109336952269756")
ufunc_gammaincc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_gammaincc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_gammaincc_types[0] = <char>NPY_FLOAT
ufunc_gammaincc_types[1] = <char>NPY_FLOAT
ufunc_gammaincc_types[2] = <char>NPY_FLOAT
ufunc_gammaincc_types[3] = <char>NPY_DOUBLE
ufunc_gammaincc_types[4] = <char>NPY_DOUBLE
ufunc_gammaincc_types[5] = <char>NPY_DOUBLE
ufunc_gammaincc_ptr[2*0] = <void*>_func_igamc
ufunc_gammaincc_ptr[2*0+1] = <void*>(<char*>"gammaincc")
ufunc_gammaincc_ptr[2*1] = <void*>_func_igamc
ufunc_gammaincc_ptr[2*1+1] = <void*>(<char*>"gammaincc")
ufunc_gammaincc_data[0] = &ufunc_gammaincc_ptr[2*0]
ufunc_gammaincc_data[1] = &ufunc_gammaincc_ptr[2*1]
gammaincc = np.PyUFunc_FromFuncAndData(ufunc_gammaincc_loops, ufunc_gammaincc_data, ufunc_gammaincc_types, 2, 2, 1, 0, "gammaincc", ufunc_gammaincc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gammainccinv_loops[2]
cdef void *ufunc_gammainccinv_ptr[4]
cdef void *ufunc_gammainccinv_data[2]
cdef char ufunc_gammainccinv_types[6]
cdef char *ufunc_gammainccinv_doc = (
    "gammainccinv(a, y, out=None)\n"
    "\n"
    "Inverse of the regularized upper incomplete gamma function.\n"
    "\n"
    "Given an input :math:`y` between 0 and 1, returns :math:`x` such\n"
    "that :math:`y = Q(a, x)`. Here :math:`Q` is the regularized upper\n"
    "incomplete gamma function; see `gammaincc`. This is well-defined\n"
    "because the upper incomplete gamma function is monotonic as can\n"
    "be seen from its definition in [dlmf]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Positive parameter\n"
    "y : array_like\n"
    "    Argument between 0 and 1, inclusive\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the inverse of the upper incomplete gamma function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gammaincc : regularized upper incomplete gamma function\n"
    "gammainc : regularized lower incomplete gamma function\n"
    "gammaincinv : inverse of the regularized lower incomplete gamma function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST Digital Library of Mathematical Functions\n"
    "          https://dlmf.nist.gov/8.2#E4\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It starts at infinity and monotonically decreases to 0.\n"
    "\n"
    ">>> sc.gammainccinv(0.5, [0, 0.1, 0.5, 1])\n"
    "array([       inf, 1.35277173, 0.22746821, 0.        ])\n"
    "\n"
    "It inverts the upper incomplete gamma function.\n"
    "\n"
    ">>> a, x = 0.5, [0, 0.1, 0.5, 1]\n"
    ">>> sc.gammaincc(a, sc.gammainccinv(a, x))\n"
    "array([0. , 0.1, 0.5, 1. ])\n"
    "\n"
    ">>> a, x = 0.5, [0, 10, 50]\n"
    ">>> sc.gammainccinv(a, sc.gammaincc(a, x))\n"
    "array([ 0., 10., 50.])")
ufunc_gammainccinv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_gammainccinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_gammainccinv_types[0] = <char>NPY_FLOAT
ufunc_gammainccinv_types[1] = <char>NPY_FLOAT
ufunc_gammainccinv_types[2] = <char>NPY_FLOAT
ufunc_gammainccinv_types[3] = <char>NPY_DOUBLE
ufunc_gammainccinv_types[4] = <char>NPY_DOUBLE
ufunc_gammainccinv_types[5] = <char>NPY_DOUBLE
ufunc_gammainccinv_ptr[2*0] = <void*>_func_igamci
ufunc_gammainccinv_ptr[2*0+1] = <void*>(<char*>"gammainccinv")
ufunc_gammainccinv_ptr[2*1] = <void*>_func_igamci
ufunc_gammainccinv_ptr[2*1+1] = <void*>(<char*>"gammainccinv")
ufunc_gammainccinv_data[0] = &ufunc_gammainccinv_ptr[2*0]
ufunc_gammainccinv_data[1] = &ufunc_gammainccinv_ptr[2*1]
gammainccinv = np.PyUFunc_FromFuncAndData(ufunc_gammainccinv_loops, ufunc_gammainccinv_data, ufunc_gammainccinv_types, 2, 2, 1, 0, "gammainccinv", ufunc_gammainccinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gammaincinv_loops[2]
cdef void *ufunc_gammaincinv_ptr[4]
cdef void *ufunc_gammaincinv_data[2]
cdef char ufunc_gammaincinv_types[6]
cdef char *ufunc_gammaincinv_doc = (
    "gammaincinv(a, y, out=None)\n"
    "\n"
    "Inverse to the regularized lower incomplete gamma function.\n"
    "\n"
    "Given an input :math:`y` between 0 and 1, returns :math:`x` such\n"
    "that :math:`y = P(a, x)`. Here :math:`P` is the regularized lower\n"
    "incomplete gamma function; see `gammainc`. This is well-defined\n"
    "because the lower incomplete gamma function is monotonic as can be\n"
    "seen from its definition in [dlmf]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Positive parameter\n"
    "y : array_like\n"
    "    Parameter between 0 and 1, inclusive\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the inverse of the lower incomplete gamma function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gammainc : regularized lower incomplete gamma function\n"
    "gammaincc : regularized upper incomplete gamma function\n"
    "gammainccinv : inverse of the regularized upper incomplete gamma function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST Digital Library of Mathematical Functions\n"
    "          https://dlmf.nist.gov/8.2#E4\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It starts at 0 and monotonically increases to infinity.\n"
    "\n"
    ">>> sc.gammaincinv(0.5, [0, 0.1 ,0.5, 1])\n"
    "array([0.        , 0.00789539, 0.22746821,        inf])\n"
    "\n"
    "It inverts the lower incomplete gamma function.\n"
    "\n"
    ">>> a, x = 0.5, [0, 0.1, 0.5, 1]\n"
    ">>> sc.gammainc(a, sc.gammaincinv(a, x))\n"
    "array([0. , 0.1, 0.5, 1. ])\n"
    "\n"
    ">>> a, x = 0.5, [0, 10, 25]\n"
    ">>> sc.gammaincinv(a, sc.gammainc(a, x))\n"
    "array([ 0.        , 10.        , 25.00001465])")
ufunc_gammaincinv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_gammaincinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_gammaincinv_types[0] = <char>NPY_FLOAT
ufunc_gammaincinv_types[1] = <char>NPY_FLOAT
ufunc_gammaincinv_types[2] = <char>NPY_FLOAT
ufunc_gammaincinv_types[3] = <char>NPY_DOUBLE
ufunc_gammaincinv_types[4] = <char>NPY_DOUBLE
ufunc_gammaincinv_types[5] = <char>NPY_DOUBLE
ufunc_gammaincinv_ptr[2*0] = <void*>_func_igami
ufunc_gammaincinv_ptr[2*0+1] = <void*>(<char*>"gammaincinv")
ufunc_gammaincinv_ptr[2*1] = <void*>_func_igami
ufunc_gammaincinv_ptr[2*1+1] = <void*>(<char*>"gammaincinv")
ufunc_gammaincinv_data[0] = &ufunc_gammaincinv_ptr[2*0]
ufunc_gammaincinv_data[1] = &ufunc_gammaincinv_ptr[2*1]
gammaincinv = np.PyUFunc_FromFuncAndData(ufunc_gammaincinv_loops, ufunc_gammaincinv_data, ufunc_gammaincinv_types, 2, 2, 1, 0, "gammaincinv", ufunc_gammaincinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gammaln_loops[2]
cdef void *ufunc_gammaln_ptr[4]
cdef void *ufunc_gammaln_data[2]
cdef char ufunc_gammaln_types[4]
cdef char *ufunc_gammaln_doc = (
    "gammaln(x, out=None)\n"
    "\n"
    "Logarithm of the absolute value of the gamma function.\n"
    "\n"
    "Defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "   \\ln(\\lvert\\Gamma(x)\\rvert)\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function. For more details on\n"
    "the gamma function, see [dlmf]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the log of the absolute value of gamma\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gammasgn : sign of the gamma function\n"
    "loggamma : principal branch of the logarithm of the gamma function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "It is the same function as the Python standard library function\n"
    ":func:`math.lgamma`.\n"
    "\n"
    "When used in conjunction with `gammasgn`, this function is useful\n"
    "for working in logspace on the real axis without having to deal\n"
    "with complex numbers via the relation ``exp(gammaln(x)) =\n"
    "gammasgn(x) * gamma(x)``.\n"
    "\n"
    "For complex-valued log-gamma, use `loggamma` instead of `gammaln`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST Digital Library of Mathematical Functions\n"
    "          https://dlmf.nist.gov/5\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It has two positive zeros.\n"
    "\n"
    ">>> sc.gammaln([1, 2])\n"
    "array([0., 0.])\n"
    "\n"
    "It has poles at nonpositive integers.\n"
    "\n"
    ">>> sc.gammaln([0, -1, -2, -3, -4])\n"
    "array([inf, inf, inf, inf, inf])\n"
    "\n"
    "It asymptotically approaches ``x * log(x)`` (Stirling's formula).\n"
    "\n"
    ">>> x = np.array([1e10, 1e20, 1e40, 1e80])\n"
    ">>> sc.gammaln(x)\n"
    "array([2.20258509e+11, 4.50517019e+21, 9.11034037e+41, 1.83206807e+82])\n"
    ">>> x * np.log(x)\n"
    "array([2.30258509e+11, 4.60517019e+21, 9.21034037e+41, 1.84206807e+82])")
ufunc_gammaln_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_gammaln_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_gammaln_types[0] = <char>NPY_FLOAT
ufunc_gammaln_types[1] = <char>NPY_FLOAT
ufunc_gammaln_types[2] = <char>NPY_DOUBLE
ufunc_gammaln_types[3] = <char>NPY_DOUBLE
ufunc_gammaln_ptr[2*0] = <void*>_func_lgam
ufunc_gammaln_ptr[2*0+1] = <void*>(<char*>"gammaln")
ufunc_gammaln_ptr[2*1] = <void*>_func_lgam
ufunc_gammaln_ptr[2*1+1] = <void*>(<char*>"gammaln")
ufunc_gammaln_data[0] = &ufunc_gammaln_ptr[2*0]
ufunc_gammaln_data[1] = &ufunc_gammaln_ptr[2*1]
gammaln = np.PyUFunc_FromFuncAndData(ufunc_gammaln_loops, ufunc_gammaln_data, ufunc_gammaln_types, 2, 1, 1, 0, "gammaln", ufunc_gammaln_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gammasgn_loops[2]
cdef void *ufunc_gammasgn_ptr[4]
cdef void *ufunc_gammasgn_data[2]
cdef char ufunc_gammasgn_types[4]
cdef char *ufunc_gammasgn_doc = (
    "gammasgn(x, out=None)\n"
    "\n"
    "Sign of the gamma function.\n"
    "\n"
    "It is defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "   \\text{gammasgn}(x) =\n"
    "   \\begin{cases}\n"
    "     +1 & \\Gamma(x) > 0 \\\\\n"
    "     -1 & \\Gamma(x) < 0\n"
    "   \\end{cases}\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function; see `gamma`. This\n"
    "definition is complete since the gamma function is never zero;\n"
    "see the discussion after [dlmf]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Sign of the gamma function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gamma : the gamma function\n"
    "gammaln : log of the absolute value of the gamma function\n"
    "loggamma : analytic continuation of the log of the gamma function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The gamma function can be computed as ``gammasgn(x) *\n"
    "np.exp(gammaln(x))``.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST Digital Library of Mathematical Functions\n"
    "          https://dlmf.nist.gov/5.2#E1\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is 1 for `x > 0`.\n"
    "\n"
    ">>> sc.gammasgn([1, 2, 3, 4])\n"
    "array([1., 1., 1., 1.])\n"
    "\n"
    "It alternates between -1 and 1 for negative integers.\n"
    "\n"
    ">>> sc.gammasgn([-0.5, -1.5, -2.5, -3.5])\n"
    "array([-1.,  1., -1.,  1.])\n"
    "\n"
    "It can be used to compute the gamma function.\n"
    "\n"
    ">>> x = [1.5, 0.5, -0.5, -1.5]\n"
    ">>> sc.gammasgn(x) * np.exp(sc.gammaln(x))\n"
    "array([ 0.88622693,  1.77245385, -3.5449077 ,  2.3632718 ])\n"
    ">>> sc.gamma(x)\n"
    "array([ 0.88622693,  1.77245385, -3.5449077 ,  2.3632718 ])")
ufunc_gammasgn_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_gammasgn_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_gammasgn_types[0] = <char>NPY_FLOAT
ufunc_gammasgn_types[1] = <char>NPY_FLOAT
ufunc_gammasgn_types[2] = <char>NPY_DOUBLE
ufunc_gammasgn_types[3] = <char>NPY_DOUBLE
ufunc_gammasgn_ptr[2*0] = <void*>_func_gammasgn
ufunc_gammasgn_ptr[2*0+1] = <void*>(<char*>"gammasgn")
ufunc_gammasgn_ptr[2*1] = <void*>_func_gammasgn
ufunc_gammasgn_ptr[2*1+1] = <void*>(<char*>"gammasgn")
ufunc_gammasgn_data[0] = &ufunc_gammasgn_ptr[2*0]
ufunc_gammasgn_data[1] = &ufunc_gammasgn_ptr[2*1]
gammasgn = np.PyUFunc_FromFuncAndData(ufunc_gammasgn_loops, ufunc_gammasgn_data, ufunc_gammasgn_types, 2, 1, 1, 0, "gammasgn", ufunc_gammasgn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtr_loops[2]
cdef void *ufunc_gdtr_ptr[4]
cdef void *ufunc_gdtr_data[2]
cdef char ufunc_gdtr_types[8]
cdef char *ufunc_gdtr_doc = (
    "gdtr(a, b, x, out=None)\n"
    "\n"
    "Gamma distribution cumulative distribution function.\n"
    "\n"
    "Returns the integral from zero to `x` of the gamma probability density\n"
    "function,\n"
    "\n"
    ".. math::\n"
    "\n"
    "    F = \\int_0^x \\frac{a^b}{\\Gamma(b)} t^{b-1} e^{-at}\\,dt,\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    The rate parameter of the gamma distribution, sometimes denoted\n"
    "    :math:`\\beta` (float).  It is also the reciprocal of the scale\n"
    "    parameter :math:`\\theta`.\n"
    "b : array_like\n"
    "    The shape parameter of the gamma distribution, sometimes denoted\n"
    "    :math:`\\alpha` (float).\n"
    "x : array_like\n"
    "    The quantile (upper limit of integration; float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "F : scalar or ndarray\n"
    "    The CDF of the gamma distribution with parameters `a` and `b`\n"
    "    evaluated at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gdtrc : 1 - CDF of the gamma distribution.\n"
    "scipy.stats.gamma: Gamma distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The evaluation is carried out using the relation to the incomplete gamma\n"
    "integral (regularized gamma function).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `gdtr`. Calling `gdtr` directly can\n"
    "improve performance compared to the ``cdf`` method of `scipy.stats.gamma`\n"
    "(see last example below).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the function for ``a=1``, ``b=2`` at ``x=5``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import gdtr\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> gdtr(1., 2., 5.)\n"
    "0.9595723180054873\n"
    "\n"
    "Compute the function for ``a=1`` and ``b=2`` at several points by\n"
    "providing a NumPy array for `x`.\n"
    "\n"
    ">>> xvalues = np.array([1., 2., 3., 4])\n"
    ">>> gdtr(1., 1., xvalues)\n"
    "array([0.63212056, 0.86466472, 0.95021293, 0.98168436])\n"
    "\n"
    "`gdtr` can evaluate different parameter sets by providing arrays with\n"
    "broadcasting compatible shapes for `a`, `b` and `x`. Here we compute the\n"
    "function for three different `a` at four positions `x` and ``b=3``,\n"
    "resulting in a 3x4 array.\n"
    "\n"
    ">>> a = np.array([[0.5], [1.5], [2.5]])\n"
    ">>> x = np.array([1., 2., 3., 4])\n"
    ">>> a.shape, x.shape\n"
    "((3, 1), (4,))\n"
    "\n"
    ">>> gdtr(a, 3., x)\n"
    "array([[0.01438768, 0.0803014 , 0.19115317, 0.32332358],\n"
    "       [0.19115317, 0.57680992, 0.82642193, 0.9380312 ],\n"
    "       [0.45618688, 0.87534798, 0.97974328, 0.9972306 ]])\n"
    "\n"
    "Plot the function for four different parameter sets.\n"
    "\n"
    ">>> a_parameters = [0.3, 1, 2, 6]\n"
    ">>> b_parameters = [2, 10, 15, 20]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(a_parameters, b_parameters, linestyles))\n"
    ">>> x = np.linspace(0, 30, 1000)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     a, b, style = parameter_set\n"
    "...     gdtr_vals = gdtr(a, b, x)\n"
    "...     ax.plot(x, gdtr_vals, label=f\"$a= {a},\\, b={b}$\", ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(\"$x$\")\n"
    ">>> ax.set_title(\"Gamma distribution cumulative distribution function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The gamma distribution is also available as `scipy.stats.gamma`. Using\n"
    "`gdtr` directly can be much faster than calling the ``cdf`` method of\n"
    "`scipy.stats.gamma`, especially for small arrays or individual values.\n"
    "To get the same results one must use the following parametrization:\n"
    "``stats.gamma(b, scale=1/a).cdf(x)=gdtr(a, b, x)``.\n"
    "\n"
    ">>> from scipy.stats import gamma\n"
    ">>> a = 2.\n"
    ">>> b = 3\n"
    ">>> x = 1.\n"
    ">>> gdtr_result = gdtr(a, b, x)  # this will often be faster than below\n"
    ">>> gamma_dist_result = gamma(b, scale=1/a).cdf(x)\n"
    ">>> gdtr_result == gamma_dist_result  # test that results are equal\n"
    "True")
ufunc_gdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtr_types[0] = <char>NPY_FLOAT
ufunc_gdtr_types[1] = <char>NPY_FLOAT
ufunc_gdtr_types[2] = <char>NPY_FLOAT
ufunc_gdtr_types[3] = <char>NPY_FLOAT
ufunc_gdtr_types[4] = <char>NPY_DOUBLE
ufunc_gdtr_types[5] = <char>NPY_DOUBLE
ufunc_gdtr_types[6] = <char>NPY_DOUBLE
ufunc_gdtr_types[7] = <char>NPY_DOUBLE
ufunc_gdtr_ptr[2*0] = <void*>_func_gdtr
ufunc_gdtr_ptr[2*0+1] = <void*>(<char*>"gdtr")
ufunc_gdtr_ptr[2*1] = <void*>_func_gdtr
ufunc_gdtr_ptr[2*1+1] = <void*>(<char*>"gdtr")
ufunc_gdtr_data[0] = &ufunc_gdtr_ptr[2*0]
ufunc_gdtr_data[1] = &ufunc_gdtr_ptr[2*1]
gdtr = np.PyUFunc_FromFuncAndData(ufunc_gdtr_loops, ufunc_gdtr_data, ufunc_gdtr_types, 2, 3, 1, 0, "gdtr", ufunc_gdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtrc_loops[2]
cdef void *ufunc_gdtrc_ptr[4]
cdef void *ufunc_gdtrc_data[2]
cdef char ufunc_gdtrc_types[8]
cdef char *ufunc_gdtrc_doc = (
    "gdtrc(a, b, x, out=None)\n"
    "\n"
    "Gamma distribution survival function.\n"
    "\n"
    "Integral from `x` to infinity of the gamma probability density function,\n"
    "\n"
    ".. math::\n"
    "\n"
    "    F = \\int_x^\\infty \\frac{a^b}{\\Gamma(b)} t^{b-1} e^{-at}\\,dt,\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    The rate parameter of the gamma distribution, sometimes denoted\n"
    "    :math:`\\beta` (float). It is also the reciprocal of the scale\n"
    "    parameter :math:`\\theta`.\n"
    "b : array_like\n"
    "    The shape parameter of the gamma distribution, sometimes denoted\n"
    "    :math:`\\alpha` (float).\n"
    "x : array_like\n"
    "    The quantile (lower limit of integration; float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "F : scalar or ndarray\n"
    "    The survival function of the gamma distribution with parameters `a`\n"
    "    and `b` evaluated at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gdtr: Gamma distribution cumulative distribution function\n"
    "scipy.stats.gamma: Gamma distribution\n"
    "gdtrix\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The evaluation is carried out using the relation to the incomplete gamma\n"
    "integral (regularized gamma function).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `gdtrc`. Calling `gdtrc` directly can\n"
    "improve performance compared to the ``sf`` method of `scipy.stats.gamma`\n"
    "(see last example below).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the function for ``a=1`` and ``b=2`` at ``x=5``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import gdtrc\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> gdtrc(1., 2., 5.)\n"
    "0.04042768199451279\n"
    "\n"
    "Compute the function for ``a=1``, ``b=2`` at several points by providing\n"
    "a NumPy array for `x`.\n"
    "\n"
    ">>> xvalues = np.array([1., 2., 3., 4])\n"
    ">>> gdtrc(1., 1., xvalues)\n"
    "array([0.36787944, 0.13533528, 0.04978707, 0.01831564])\n"
    "\n"
    "`gdtrc` can evaluate different parameter sets by providing arrays with\n"
    "broadcasting compatible shapes for `a`, `b` and `x`. Here we compute the\n"
    "function for three different `a` at four positions `x` and ``b=3``,\n"
    "resulting in a 3x4 array.\n"
    "\n"
    ">>> a = np.array([[0.5], [1.5], [2.5]])\n"
    ">>> x = np.array([1., 2., 3., 4])\n"
    ">>> a.shape, x.shape\n"
    "((3, 1), (4,))\n"
    "\n"
    ">>> gdtrc(a, 3., x)\n"
    "array([[0.98561232, 0.9196986 , 0.80884683, 0.67667642],\n"
    "       [0.80884683, 0.42319008, 0.17357807, 0.0619688 ],\n"
    "       [0.54381312, 0.12465202, 0.02025672, 0.0027694 ]])\n"
    "\n"
    "Plot the function for four different parameter sets.\n"
    "\n"
    ">>> a_parameters = [0.3, 1, 2, 6]\n"
    ">>> b_parameters = [2, 10, 15, 20]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(a_parameters, b_parameters, linestyles))\n"
    ">>> x = np.linspace(0, 30, 1000)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     a, b, style = parameter_set\n"
    "...     gdtrc_vals = gdtrc(a, b, x)\n"
    "...     ax.plot(x, gdtrc_vals, label=f\"$a= {a},\\, b={b}$\", ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(\"$x$\")\n"
    ">>> ax.set_title(\"Gamma distribution survival function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The gamma distribution is also available as `scipy.stats.gamma`.\n"
    "Using `gdtrc` directly can be much faster than calling the ``sf`` method\n"
    "of `scipy.stats.gamma`, especially for small arrays or individual\n"
    "values. To get the same results one must use the following parametrization:\n"
    "``stats.gamma(b, scale=1/a).sf(x)=gdtrc(a, b, x)``.\n"
    "\n"
    ">>> from scipy.stats import gamma\n"
    ">>> a = 2\n"
    ">>> b = 3\n"
    ">>> x = 1.\n"
    ">>> gdtrc_result = gdtrc(a, b, x)  # this will often be faster than below\n"
    ">>> gamma_dist_result = gamma(b, scale=1/a).sf(x)\n"
    ">>> gdtrc_result == gamma_dist_result  # test that results are equal\n"
    "True")
ufunc_gdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtrc_types[0] = <char>NPY_FLOAT
ufunc_gdtrc_types[1] = <char>NPY_FLOAT
ufunc_gdtrc_types[2] = <char>NPY_FLOAT
ufunc_gdtrc_types[3] = <char>NPY_FLOAT
ufunc_gdtrc_types[4] = <char>NPY_DOUBLE
ufunc_gdtrc_types[5] = <char>NPY_DOUBLE
ufunc_gdtrc_types[6] = <char>NPY_DOUBLE
ufunc_gdtrc_types[7] = <char>NPY_DOUBLE
ufunc_gdtrc_ptr[2*0] = <void*>_func_gdtrc
ufunc_gdtrc_ptr[2*0+1] = <void*>(<char*>"gdtrc")
ufunc_gdtrc_ptr[2*1] = <void*>_func_gdtrc
ufunc_gdtrc_ptr[2*1+1] = <void*>(<char*>"gdtrc")
ufunc_gdtrc_data[0] = &ufunc_gdtrc_ptr[2*0]
ufunc_gdtrc_data[1] = &ufunc_gdtrc_ptr[2*1]
gdtrc = np.PyUFunc_FromFuncAndData(ufunc_gdtrc_loops, ufunc_gdtrc_data, ufunc_gdtrc_types, 2, 3, 1, 0, "gdtrc", ufunc_gdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtria_loops[2]
cdef void *ufunc_gdtria_ptr[4]
cdef void *ufunc_gdtria_data[2]
cdef char ufunc_gdtria_types[8]
cdef char *ufunc_gdtria_doc = (
    "gdtria(p, b, x, out=None)\n"
    "\n"
    "Inverse of `gdtr` vs a.\n"
    "\n"
    "Returns the inverse with respect to the parameter `a` of ``p =\n"
    "gdtr(a, b, x)``, the cumulative distribution function of the gamma\n"
    "distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability values.\n"
    "b : array_like\n"
    "    `b` parameter values of `gdtr(a, b, x)`. `b` is the \"shape\" parameter\n"
    "    of the gamma distribution.\n"
    "x : array_like\n"
    "    Nonnegative real values, from the domain of the gamma distribution.\n"
    "out : ndarray, optional\n"
    "    If a fourth argument is given, it must be a numpy.ndarray whose size\n"
    "    matches the broadcast result of `a`, `b` and `x`.  `out` is then the\n"
    "    array returned by the function.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "a : scalar or ndarray\n"
    "    Values of the `a` parameter such that `p = gdtr(a, b, x)`.  `1/a`\n"
    "    is the \"scale\" parameter of the gamma distribution.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gdtr : CDF of the gamma distribution.\n"
    "gdtrib : Inverse with respect to `b` of `gdtr(a, b, x)`.\n"
    "gdtrix : Inverse with respect to `x` of `gdtr(a, b, x)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_. Computation of `a` involves a search for a value\n"
    "that produces the desired value of `p`. The search relies on the\n"
    "monotonicity of `p` with `a`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Computation of the incomplete gamma function ratios and their\n"
    "       inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "First evaluate `gdtr`.\n"
    "\n"
    ">>> from scipy.special import gdtr, gdtria\n"
    ">>> p = gdtr(1.2, 3.4, 5.6)\n"
    ">>> print(p)\n"
    "0.94378087442\n"
    "\n"
    "Verify the inverse.\n"
    "\n"
    ">>> gdtria(p, 3.4, 5.6)\n"
    "1.2")
ufunc_gdtria_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtria_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtria_types[0] = <char>NPY_FLOAT
ufunc_gdtria_types[1] = <char>NPY_FLOAT
ufunc_gdtria_types[2] = <char>NPY_FLOAT
ufunc_gdtria_types[3] = <char>NPY_FLOAT
ufunc_gdtria_types[4] = <char>NPY_DOUBLE
ufunc_gdtria_types[5] = <char>NPY_DOUBLE
ufunc_gdtria_types[6] = <char>NPY_DOUBLE
ufunc_gdtria_types[7] = <char>NPY_DOUBLE
ufunc_gdtria_ptr[2*0] = <void*>_func_cdfgam4_wrap
ufunc_gdtria_ptr[2*0+1] = <void*>(<char*>"gdtria")
ufunc_gdtria_ptr[2*1] = <void*>_func_cdfgam4_wrap
ufunc_gdtria_ptr[2*1+1] = <void*>(<char*>"gdtria")
ufunc_gdtria_data[0] = &ufunc_gdtria_ptr[2*0]
ufunc_gdtria_data[1] = &ufunc_gdtria_ptr[2*1]
gdtria = np.PyUFunc_FromFuncAndData(ufunc_gdtria_loops, ufunc_gdtria_data, ufunc_gdtria_types, 2, 3, 1, 0, "gdtria", ufunc_gdtria_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtrib_loops[2]
cdef void *ufunc_gdtrib_ptr[4]
cdef void *ufunc_gdtrib_data[2]
cdef char ufunc_gdtrib_types[8]
cdef char *ufunc_gdtrib_doc = (
    "gdtrib(a, p, x, out=None)\n"
    "\n"
    "Inverse of `gdtr` vs b.\n"
    "\n"
    "Returns the inverse with respect to the parameter `b` of ``p =\n"
    "gdtr(a, b, x)``, the cumulative distribution function of the gamma\n"
    "distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    `a` parameter values of `gdtr(a, b, x)`. `1/a` is the \"scale\"\n"
    "    parameter of the gamma distribution.\n"
    "p : array_like\n"
    "    Probability values.\n"
    "x : array_like\n"
    "    Nonnegative real values, from the domain of the gamma distribution.\n"
    "out : ndarray, optional\n"
    "    If a fourth argument is given, it must be a numpy.ndarray whose size\n"
    "    matches the broadcast result of `a`, `b` and `x`.  `out` is then the\n"
    "    array returned by the function.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "b : scalar or ndarray\n"
    "    Values of the `b` parameter such that `p = gdtr(a, b, x)`.  `b` is\n"
    "    the \"shape\" parameter of the gamma distribution.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gdtr : CDF of the gamma distribution.\n"
    "gdtria : Inverse with respect to `a` of `gdtr(a, b, x)`.\n"
    "gdtrix : Inverse with respect to `x` of `gdtr(a, b, x)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_. Computation of `b` involves a search for a value\n"
    "that produces the desired value of `p`. The search relies on the\n"
    "monotonicity of `p` with `b`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Computation of the incomplete gamma function ratios and their\n"
    "       inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "First evaluate `gdtr`.\n"
    "\n"
    ">>> from scipy.special import gdtr, gdtrib\n"
    ">>> p = gdtr(1.2, 3.4, 5.6)\n"
    ">>> print(p)\n"
    "0.94378087442\n"
    "\n"
    "Verify the inverse.\n"
    "\n"
    ">>> gdtrib(1.2, p, 5.6)\n"
    "3.3999999999723882")
ufunc_gdtrib_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtrib_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtrib_types[0] = <char>NPY_FLOAT
ufunc_gdtrib_types[1] = <char>NPY_FLOAT
ufunc_gdtrib_types[2] = <char>NPY_FLOAT
ufunc_gdtrib_types[3] = <char>NPY_FLOAT
ufunc_gdtrib_types[4] = <char>NPY_DOUBLE
ufunc_gdtrib_types[5] = <char>NPY_DOUBLE
ufunc_gdtrib_types[6] = <char>NPY_DOUBLE
ufunc_gdtrib_types[7] = <char>NPY_DOUBLE
ufunc_gdtrib_ptr[2*0] = <void*>_func_cdfgam3_wrap
ufunc_gdtrib_ptr[2*0+1] = <void*>(<char*>"gdtrib")
ufunc_gdtrib_ptr[2*1] = <void*>_func_cdfgam3_wrap
ufunc_gdtrib_ptr[2*1+1] = <void*>(<char*>"gdtrib")
ufunc_gdtrib_data[0] = &ufunc_gdtrib_ptr[2*0]
ufunc_gdtrib_data[1] = &ufunc_gdtrib_ptr[2*1]
gdtrib = np.PyUFunc_FromFuncAndData(ufunc_gdtrib_loops, ufunc_gdtrib_data, ufunc_gdtrib_types, 2, 3, 1, 0, "gdtrib", ufunc_gdtrib_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtrix_loops[2]
cdef void *ufunc_gdtrix_ptr[4]
cdef void *ufunc_gdtrix_data[2]
cdef char ufunc_gdtrix_types[8]
cdef char *ufunc_gdtrix_doc = (
    "gdtrix(a, b, p, out=None)\n"
    "\n"
    "Inverse of `gdtr` vs x.\n"
    "\n"
    "Returns the inverse with respect to the parameter `x` of ``p =\n"
    "gdtr(a, b, x)``, the cumulative distribution function of the gamma\n"
    "distribution. This is also known as the pth quantile of the\n"
    "distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    `a` parameter values of `gdtr(a, b, x)`. `1/a` is the \"scale\"\n"
    "    parameter of the gamma distribution.\n"
    "b : array_like\n"
    "    `b` parameter values of `gdtr(a, b, x)`. `b` is the \"shape\" parameter\n"
    "    of the gamma distribution.\n"
    "p : array_like\n"
    "    Probability values.\n"
    "out : ndarray, optional\n"
    "    If a fourth argument is given, it must be a numpy.ndarray whose size\n"
    "    matches the broadcast result of `a`, `b` and `x`. `out` is then the\n"
    "    array returned by the function.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Values of the `x` parameter such that `p = gdtr(a, b, x)`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gdtr : CDF of the gamma distribution.\n"
    "gdtria : Inverse with respect to `a` of `gdtr(a, b, x)`.\n"
    "gdtrib : Inverse with respect to `b` of `gdtr(a, b, x)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_. Computation of `x` involves a search for a value\n"
    "that produces the desired value of `p`. The search relies on the\n"
    "monotonicity of `p` with `x`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Computation of the incomplete gamma function ratios and their\n"
    "       inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "First evaluate `gdtr`.\n"
    "\n"
    ">>> from scipy.special import gdtr, gdtrix\n"
    ">>> p = gdtr(1.2, 3.4, 5.6)\n"
    ">>> print(p)\n"
    "0.94378087442\n"
    "\n"
    "Verify the inverse.\n"
    "\n"
    ">>> gdtrix(1.2, 3.4, p)\n"
    "5.5999999999999996")
ufunc_gdtrix_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtrix_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtrix_types[0] = <char>NPY_FLOAT
ufunc_gdtrix_types[1] = <char>NPY_FLOAT
ufunc_gdtrix_types[2] = <char>NPY_FLOAT
ufunc_gdtrix_types[3] = <char>NPY_FLOAT
ufunc_gdtrix_types[4] = <char>NPY_DOUBLE
ufunc_gdtrix_types[5] = <char>NPY_DOUBLE
ufunc_gdtrix_types[6] = <char>NPY_DOUBLE
ufunc_gdtrix_types[7] = <char>NPY_DOUBLE
ufunc_gdtrix_ptr[2*0] = <void*>_func_cdfgam2_wrap
ufunc_gdtrix_ptr[2*0+1] = <void*>(<char*>"gdtrix")
ufunc_gdtrix_ptr[2*1] = <void*>_func_cdfgam2_wrap
ufunc_gdtrix_ptr[2*1+1] = <void*>(<char*>"gdtrix")
ufunc_gdtrix_data[0] = &ufunc_gdtrix_ptr[2*0]
ufunc_gdtrix_data[1] = &ufunc_gdtrix_ptr[2*1]
gdtrix = np.PyUFunc_FromFuncAndData(ufunc_gdtrix_loops, ufunc_gdtrix_data, ufunc_gdtrix_types, 2, 3, 1, 0, "gdtrix", ufunc_gdtrix_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hankel1_loops[2]
cdef void *ufunc_hankel1_ptr[4]
cdef void *ufunc_hankel1_data[2]
cdef char ufunc_hankel1_types[6]
cdef char *ufunc_hankel1_doc = (
    "hankel1(v, z, out=None)\n"
    "\n"
    "Hankel function of the first kind\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the Hankel function of the first kind.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "hankel1e : ndarray\n"
    "    This function with leading exponential behavior stripped off.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the\n"
    "computation using the relation,\n"
    "\n"
    ".. math:: H^{(1)}_v(z) =\n"
    "          \\frac{2}{\\imath\\pi} \\exp(-\\imath \\pi v/2) K_v(z \\exp(-\\imath\\pi/2))\n"
    "\n"
    "where :math:`K_v` is the modified Bessel function of the second kind.\n"
    "For negative orders, the relation\n"
    "\n"
    ".. math:: H^{(1)}_{-v}(z) = H^{(1)}_v(z) \\exp(\\imath\\pi v)\n"
    "\n"
    "is used.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_hankel1_loops[0] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_hankel1_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_hankel1_types[0] = <char>NPY_FLOAT
ufunc_hankel1_types[1] = <char>NPY_CFLOAT
ufunc_hankel1_types[2] = <char>NPY_CFLOAT
ufunc_hankel1_types[3] = <char>NPY_DOUBLE
ufunc_hankel1_types[4] = <char>NPY_CDOUBLE
ufunc_hankel1_types[5] = <char>NPY_CDOUBLE
ufunc_hankel1_ptr[2*0] = <void*>_func_cbesh_wrap1
ufunc_hankel1_ptr[2*0+1] = <void*>(<char*>"hankel1")
ufunc_hankel1_ptr[2*1] = <void*>_func_cbesh_wrap1
ufunc_hankel1_ptr[2*1+1] = <void*>(<char*>"hankel1")
ufunc_hankel1_data[0] = &ufunc_hankel1_ptr[2*0]
ufunc_hankel1_data[1] = &ufunc_hankel1_ptr[2*1]
hankel1 = np.PyUFunc_FromFuncAndData(ufunc_hankel1_loops, ufunc_hankel1_data, ufunc_hankel1_types, 2, 2, 1, 0, "hankel1", ufunc_hankel1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hankel1e_loops[2]
cdef void *ufunc_hankel1e_ptr[4]
cdef void *ufunc_hankel1e_data[2]
cdef char ufunc_hankel1e_types[6]
cdef char *ufunc_hankel1e_doc = (
    "hankel1e(v, z, out=None)\n"
    "\n"
    "Exponentially scaled Hankel function of the first kind\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    hankel1e(v, z) = hankel1(v, z) * exp(-1j * z)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the exponentially scaled Hankel function.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the\n"
    "computation using the relation,\n"
    "\n"
    ".. math:: H^{(1)}_v(z) =\n"
    "          \\frac{2}{\\imath\\pi} \\exp(-\\imath \\pi v/2) K_v(z \\exp(-\\imath\\pi/2))\n"
    "\n"
    "where :math:`K_v` is the modified Bessel function of the second kind.\n"
    "For negative orders, the relation\n"
    "\n"
    ".. math:: H^{(1)}_{-v}(z) = H^{(1)}_v(z) \\exp(\\imath\\pi v)\n"
    "\n"
    "is used.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_hankel1e_loops[0] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_hankel1e_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_hankel1e_types[0] = <char>NPY_FLOAT
ufunc_hankel1e_types[1] = <char>NPY_CFLOAT
ufunc_hankel1e_types[2] = <char>NPY_CFLOAT
ufunc_hankel1e_types[3] = <char>NPY_DOUBLE
ufunc_hankel1e_types[4] = <char>NPY_CDOUBLE
ufunc_hankel1e_types[5] = <char>NPY_CDOUBLE
ufunc_hankel1e_ptr[2*0] = <void*>_func_cbesh_wrap1_e
ufunc_hankel1e_ptr[2*0+1] = <void*>(<char*>"hankel1e")
ufunc_hankel1e_ptr[2*1] = <void*>_func_cbesh_wrap1_e
ufunc_hankel1e_ptr[2*1+1] = <void*>(<char*>"hankel1e")
ufunc_hankel1e_data[0] = &ufunc_hankel1e_ptr[2*0]
ufunc_hankel1e_data[1] = &ufunc_hankel1e_ptr[2*1]
hankel1e = np.PyUFunc_FromFuncAndData(ufunc_hankel1e_loops, ufunc_hankel1e_data, ufunc_hankel1e_types, 2, 2, 1, 0, "hankel1e", ufunc_hankel1e_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hankel2_loops[2]
cdef void *ufunc_hankel2_ptr[4]
cdef void *ufunc_hankel2_data[2]
cdef char ufunc_hankel2_types[6]
cdef char *ufunc_hankel2_doc = (
    "hankel2(v, z, out=None)\n"
    "\n"
    "Hankel function of the second kind\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the Hankel function of the second kind.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "hankel2e : this function with leading exponential behavior stripped off.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the\n"
    "computation using the relation,\n"
    "\n"
    ".. math:: H^{(2)}_v(z) =\n"
    "          -\\frac{2}{\\imath\\pi} \\exp(\\imath \\pi v/2) K_v(z \\exp(\\imath\\pi/2))\n"
    "\n"
    "where :math:`K_v` is the modified Bessel function of the second kind.\n"
    "For negative orders, the relation\n"
    "\n"
    ".. math:: H^{(2)}_{-v}(z) = H^{(2)}_v(z) \\exp(-\\imath\\pi v)\n"
    "\n"
    "is used.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_hankel2_loops[0] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_hankel2_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_hankel2_types[0] = <char>NPY_FLOAT
ufunc_hankel2_types[1] = <char>NPY_CFLOAT
ufunc_hankel2_types[2] = <char>NPY_CFLOAT
ufunc_hankel2_types[3] = <char>NPY_DOUBLE
ufunc_hankel2_types[4] = <char>NPY_CDOUBLE
ufunc_hankel2_types[5] = <char>NPY_CDOUBLE
ufunc_hankel2_ptr[2*0] = <void*>_func_cbesh_wrap2
ufunc_hankel2_ptr[2*0+1] = <void*>(<char*>"hankel2")
ufunc_hankel2_ptr[2*1] = <void*>_func_cbesh_wrap2
ufunc_hankel2_ptr[2*1+1] = <void*>(<char*>"hankel2")
ufunc_hankel2_data[0] = &ufunc_hankel2_ptr[2*0]
ufunc_hankel2_data[1] = &ufunc_hankel2_ptr[2*1]
hankel2 = np.PyUFunc_FromFuncAndData(ufunc_hankel2_loops, ufunc_hankel2_data, ufunc_hankel2_types, 2, 2, 1, 0, "hankel2", ufunc_hankel2_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hankel2e_loops[2]
cdef void *ufunc_hankel2e_ptr[4]
cdef void *ufunc_hankel2e_data[2]
cdef char ufunc_hankel2e_types[6]
cdef char *ufunc_hankel2e_doc = (
    "hankel2e(v, z, out=None)\n"
    "\n"
    "Exponentially scaled Hankel function of the second kind\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    hankel2e(v, z) = hankel2(v, z) * exp(1j * z)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the exponentially scaled Hankel function of the second kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the\n"
    "computation using the relation,\n"
    "\n"
    ".. math:: H^{(2)}_v(z) = -\\frac{2}{\\imath\\pi}\n"
    "          \\exp(\\frac{\\imath \\pi v}{2}) K_v(z exp(\\frac{\\imath\\pi}{2}))\n"
    "\n"
    "where :math:`K_v` is the modified Bessel function of the second kind.\n"
    "For negative orders, the relation\n"
    "\n"
    ".. math:: H^{(2)}_{-v}(z) = H^{(2)}_v(z) \\exp(-\\imath\\pi v)\n"
    "\n"
    "is used.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_hankel2e_loops[0] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_hankel2e_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_hankel2e_types[0] = <char>NPY_FLOAT
ufunc_hankel2e_types[1] = <char>NPY_CFLOAT
ufunc_hankel2e_types[2] = <char>NPY_CFLOAT
ufunc_hankel2e_types[3] = <char>NPY_DOUBLE
ufunc_hankel2e_types[4] = <char>NPY_CDOUBLE
ufunc_hankel2e_types[5] = <char>NPY_CDOUBLE
ufunc_hankel2e_ptr[2*0] = <void*>_func_cbesh_wrap2_e
ufunc_hankel2e_ptr[2*0+1] = <void*>(<char*>"hankel2e")
ufunc_hankel2e_ptr[2*1] = <void*>_func_cbesh_wrap2_e
ufunc_hankel2e_ptr[2*1+1] = <void*>(<char*>"hankel2e")
ufunc_hankel2e_data[0] = &ufunc_hankel2e_ptr[2*0]
ufunc_hankel2e_data[1] = &ufunc_hankel2e_ptr[2*1]
hankel2e = np.PyUFunc_FromFuncAndData(ufunc_hankel2e_loops, ufunc_hankel2e_data, ufunc_hankel2e_types, 2, 2, 1, 0, "hankel2e", ufunc_hankel2e_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_huber_loops[2]
cdef void *ufunc_huber_ptr[4]
cdef void *ufunc_huber_data[2]
cdef char ufunc_huber_types[6]
cdef char *ufunc_huber_doc = (
    "huber(delta, r, out=None)\n"
    "\n"
    "Huber loss function.\n"
    "\n"
    ".. math:: \\text{huber}(\\delta, r) = \\begin{cases} \\infty & \\delta < 0  \\\\\n"
    "          \\frac{1}{2}r^2 & 0 \\le \\delta, | r | \\le \\delta \\\\\n"
    "          \\delta ( |r| - \\frac{1}{2}\\delta ) & \\text{otherwise} \\end{cases}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "delta : ndarray\n"
    "    Input array, indicating the quadratic vs. linear loss changepoint.\n"
    "r : ndarray\n"
    "    Input array, possibly representing residuals.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The computed Huber loss function values.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "pseudo_huber : smooth approximation of this function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "`huber` is useful as a loss function in robust statistics or machine\n"
    "learning to reduce the influence of outliers as compared to the common\n"
    "squared error loss, residuals with a magnitude higher than `delta` are\n"
    "not squared [1]_.\n"
    "\n"
    "Typically, `r` represents residuals, the difference\n"
    "between a model prediction and data. Then, for :math:`|r|\\leq\\delta`,\n"
    "`huber` resembles the squared error and for :math:`|r|>\\delta` the\n"
    "absolute error. This way, the Huber loss often achieves\n"
    "a fast convergence in model fitting for small residuals like the squared\n"
    "error loss function and still reduces the influence of outliers\n"
    "(:math:`|r|>\\delta`) like the absolute error loss. As :math:`\\delta` is\n"
    "the cutoff between squared and absolute error regimes, it has\n"
    "to be tuned carefully for each problem. `huber` is also\n"
    "convex, making it suitable for gradient based optimization.\n"
    "\n"
    ".. versionadded:: 0.15.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Peter Huber. \"Robust Estimation of a Location Parameter\",\n"
    "       1964. Annals of Statistics. 53 (1): 73 - 101.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Import all necessary modules.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import huber\n"
    ">>> import matplotlib.pyplot as plt\n"
    "\n"
    "Compute the function for ``delta=1`` at ``r=2``\n"
    "\n"
    ">>> huber(1., 2.)\n"
    "1.5\n"
    "\n"
    "Compute the function for different `delta` by providing a NumPy array or\n"
    "list for `delta`.\n"
    "\n"
    ">>> huber([1., 3., 5.], 4.)\n"
    "array([3.5, 7.5, 8. ])\n"
    "\n"
    "Compute the function at different points by providing a NumPy array or\n"
    "list for `r`.\n"
    "\n"
    ">>> huber(2., np.array([1., 1.5, 3.]))\n"
    "array([0.5  , 1.125, 4.   ])\n"
    "\n"
    "The function can be calculated for different `delta` and `r` by\n"
    "providing arrays for both with compatible shapes for broadcasting.\n"
    "\n"
    ">>> r = np.array([1., 2.5, 8., 10.])\n"
    ">>> deltas = np.array([[1.], [5.], [9.]])\n"
    ">>> print(r.shape, deltas.shape)\n"
    "(4,) (3, 1)\n"
    "\n"
    ">>> huber(deltas, r)\n"
    "array([[ 0.5  ,  2.   ,  7.5  ,  9.5  ],\n"
    "       [ 0.5  ,  3.125, 27.5  , 37.5  ],\n"
    "       [ 0.5  ,  3.125, 32.   , 49.5  ]])\n"
    "\n"
    "Plot the function for different `delta`.\n"
    "\n"
    ">>> x = np.linspace(-4, 4, 500)\n"
    ">>> deltas = [1, 2, 3]\n"
    ">>> linestyles = [\"dashed\", \"dotted\", \"dashdot\"]\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> combined_plot_parameters = list(zip(deltas, linestyles))\n"
    ">>> for delta, style in combined_plot_parameters:\n"
    "...     ax.plot(x, huber(delta, x), label=f\"$\\delta={delta}$\", ls=style)\n"
    ">>> ax.legend(loc=\"upper center\")\n"
    ">>> ax.set_xlabel(\"$x$\")\n"
    ">>> ax.set_title(\"Huber loss function $h_{\\delta}(x)$\")\n"
    ">>> ax.set_xlim(-4, 4)\n"
    ">>> ax.set_ylim(0, 8)\n"
    ">>> plt.show()")
ufunc_huber_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_huber_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_huber_types[0] = <char>NPY_FLOAT
ufunc_huber_types[1] = <char>NPY_FLOAT
ufunc_huber_types[2] = <char>NPY_FLOAT
ufunc_huber_types[3] = <char>NPY_DOUBLE
ufunc_huber_types[4] = <char>NPY_DOUBLE
ufunc_huber_types[5] = <char>NPY_DOUBLE
ufunc_huber_ptr[2*0] = <void*>_func_huber
ufunc_huber_ptr[2*0+1] = <void*>(<char*>"huber")
ufunc_huber_ptr[2*1] = <void*>_func_huber
ufunc_huber_ptr[2*1+1] = <void*>(<char*>"huber")
ufunc_huber_data[0] = &ufunc_huber_ptr[2*0]
ufunc_huber_data[1] = &ufunc_huber_ptr[2*1]
huber = np.PyUFunc_FromFuncAndData(ufunc_huber_loops, ufunc_huber_data, ufunc_huber_types, 2, 2, 1, 0, "huber", ufunc_huber_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hyp0f1_loops[4]
cdef void *ufunc_hyp0f1_ptr[8]
cdef void *ufunc_hyp0f1_data[4]
cdef char ufunc_hyp0f1_types[12]
cdef char *ufunc_hyp0f1_doc = (
    "hyp0f1(v, z, out=None)\n"
    "\n"
    "Confluent hypergeometric limit function 0F1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Real-valued parameter\n"
    "z : array_like\n"
    "    Real- or complex-valued argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The confluent hypergeometric limit function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function is defined as:\n"
    "\n"
    ".. math:: _0F_1(v, z) = \\sum_{k=0}^{\\infty}\\frac{z^k}{(v)_k k!}.\n"
    "\n"
    "It's also the limit as :math:`q \\to \\infty` of :math:`_1F_1(q; v; z/q)`,\n"
    "and satisfies the differential equation :math:`f''(z) + vf'(z) =\n"
    "f(z)`. See [1]_ for more information.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Wolfram MathWorld, \"Confluent Hypergeometric Limit Function\",\n"
    "       http://mathworld.wolfram.com/ConfluentHypergeometricLimitFunction.html\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is one when `z` is zero.\n"
    "\n"
    ">>> sc.hyp0f1(1, 0)\n"
    "1.0\n"
    "\n"
    "It is the limit of the confluent hypergeometric function as `q`\n"
    "goes to infinity.\n"
    "\n"
    ">>> q = np.array([1, 10, 100, 1000])\n"
    ">>> v = 1\n"
    ">>> z = 1\n"
    ">>> sc.hyp1f1(q, v, z / q)\n"
    "array([2.71828183, 2.31481985, 2.28303778, 2.27992985])\n"
    ">>> sc.hyp0f1(v, z)\n"
    "2.2795853023360673\n"
    "\n"
    "It is related to Bessel functions.\n"
    "\n"
    ">>> n = 1\n"
    ">>> x = np.linspace(0, 1, 5)\n"
    ">>> sc.jv(n, x)\n"
    "array([0.        , 0.12402598, 0.24226846, 0.3492436 , 0.44005059])\n"
    ">>> (0.5 * x)**n / sc.factorial(n) * sc.hyp0f1(n + 1, -0.25 * x**2)\n"
    "array([0.        , 0.12402598, 0.24226846, 0.3492436 , 0.44005059])")
ufunc_hyp0f1_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_hyp0f1_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_hyp0f1_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_hyp0f1_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_hyp0f1_types[0] = <char>NPY_FLOAT
ufunc_hyp0f1_types[1] = <char>NPY_FLOAT
ufunc_hyp0f1_types[2] = <char>NPY_FLOAT
ufunc_hyp0f1_types[3] = <char>NPY_FLOAT
ufunc_hyp0f1_types[4] = <char>NPY_CFLOAT
ufunc_hyp0f1_types[5] = <char>NPY_CFLOAT
ufunc_hyp0f1_types[6] = <char>NPY_DOUBLE
ufunc_hyp0f1_types[7] = <char>NPY_DOUBLE
ufunc_hyp0f1_types[8] = <char>NPY_DOUBLE
ufunc_hyp0f1_types[9] = <char>NPY_DOUBLE
ufunc_hyp0f1_types[10] = <char>NPY_CDOUBLE
ufunc_hyp0f1_types[11] = <char>NPY_CDOUBLE
ufunc_hyp0f1_ptr[2*0] = <void*>_func__hyp0f1_real
ufunc_hyp0f1_ptr[2*0+1] = <void*>(<char*>"hyp0f1")
ufunc_hyp0f1_ptr[2*1] = <void*>_func__hyp0f1_cmplx
ufunc_hyp0f1_ptr[2*1+1] = <void*>(<char*>"hyp0f1")
ufunc_hyp0f1_ptr[2*2] = <void*>_func__hyp0f1_real
ufunc_hyp0f1_ptr[2*2+1] = <void*>(<char*>"hyp0f1")
ufunc_hyp0f1_ptr[2*3] = <void*>_func__hyp0f1_cmplx
ufunc_hyp0f1_ptr[2*3+1] = <void*>(<char*>"hyp0f1")
ufunc_hyp0f1_data[0] = &ufunc_hyp0f1_ptr[2*0]
ufunc_hyp0f1_data[1] = &ufunc_hyp0f1_ptr[2*1]
ufunc_hyp0f1_data[2] = &ufunc_hyp0f1_ptr[2*2]
ufunc_hyp0f1_data[3] = &ufunc_hyp0f1_ptr[2*3]
hyp0f1 = np.PyUFunc_FromFuncAndData(ufunc_hyp0f1_loops, ufunc_hyp0f1_data, ufunc_hyp0f1_types, 4, 2, 1, 0, "hyp0f1", ufunc_hyp0f1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hyp1f1_loops[4]
cdef void *ufunc_hyp1f1_ptr[8]
cdef void *ufunc_hyp1f1_data[4]
cdef char ufunc_hyp1f1_types[16]
cdef char *ufunc_hyp1f1_doc = (
    "hyp1f1(a, b, x, out=None)\n"
    "\n"
    "Confluent hypergeometric function 1F1.\n"
    "\n"
    "The confluent hypergeometric function is defined by the series\n"
    "\n"
    ".. math::\n"
    "\n"
    "   {}_1F_1(a; b; x) = \\sum_{k = 0}^\\infty \\frac{(a)_k}{(b)_k k!} x^k.\n"
    "\n"
    "See [dlmf]_ for more details. Here :math:`(\\cdot)_k` is the\n"
    "Pochhammer symbol; see `poch`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Real parameters\n"
    "x : array_like\n"
    "    Real or complex argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the confluent hypergeometric function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "hyperu : another confluent hypergeometric function\n"
    "hyp0f1 : confluent hypergeometric limit function\n"
    "hyp2f1 : Gaussian hypergeometric function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST Digital Library of Mathematical Functions\n"
    "          https://dlmf.nist.gov/13.2#E2\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is one when `x` is zero:\n"
    "\n"
    ">>> sc.hyp1f1(0.5, 0.5, 0)\n"
    "1.0\n"
    "\n"
    "It is singular when `b` is a nonpositive integer.\n"
    "\n"
    ">>> sc.hyp1f1(0.5, -1, 0)\n"
    "inf\n"
    "\n"
    "It is a polynomial when `a` is a nonpositive integer.\n"
    "\n"
    ">>> a, b, x = -1, 0.5, np.array([1.0, 2.0, 3.0, 4.0])\n"
    ">>> sc.hyp1f1(a, b, x)\n"
    "array([-1., -3., -5., -7.])\n"
    ">>> 1 + (a / b) * x\n"
    "array([-1., -3., -5., -7.])\n"
    "\n"
    "It reduces to the exponential function when `a = b`.\n"
    "\n"
    ">>> sc.hyp1f1(2, 2, [1, 2, 3, 4])\n"
    "array([ 2.71828183,  7.3890561 , 20.08553692, 54.59815003])\n"
    ">>> np.exp([1, 2, 3, 4])\n"
    "array([ 2.71828183,  7.3890561 , 20.08553692, 54.59815003])")
ufunc_hyp1f1_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_hyp1f1_loops[1] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ffF_F
ufunc_hyp1f1_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_hyp1f1_loops[3] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ddD_D
ufunc_hyp1f1_types[0] = <char>NPY_FLOAT
ufunc_hyp1f1_types[1] = <char>NPY_FLOAT
ufunc_hyp1f1_types[2] = <char>NPY_FLOAT
ufunc_hyp1f1_types[3] = <char>NPY_FLOAT
ufunc_hyp1f1_types[4] = <char>NPY_FLOAT
ufunc_hyp1f1_types[5] = <char>NPY_FLOAT
ufunc_hyp1f1_types[6] = <char>NPY_CFLOAT
ufunc_hyp1f1_types[7] = <char>NPY_CFLOAT
ufunc_hyp1f1_types[8] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[9] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[10] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[11] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[12] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[13] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[14] = <char>NPY_CDOUBLE
ufunc_hyp1f1_types[15] = <char>NPY_CDOUBLE
ufunc_hyp1f1_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_hyp1f1_double
ufunc_hyp1f1_ptr[2*0+1] = <void*>(<char*>"hyp1f1")
ufunc_hyp1f1_ptr[2*1] = <void*>_func_chyp1f1_wrap
ufunc_hyp1f1_ptr[2*1+1] = <void*>(<char*>"hyp1f1")
ufunc_hyp1f1_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_hyp1f1_double
ufunc_hyp1f1_ptr[2*2+1] = <void*>(<char*>"hyp1f1")
ufunc_hyp1f1_ptr[2*3] = <void*>_func_chyp1f1_wrap
ufunc_hyp1f1_ptr[2*3+1] = <void*>(<char*>"hyp1f1")
ufunc_hyp1f1_data[0] = &ufunc_hyp1f1_ptr[2*0]
ufunc_hyp1f1_data[1] = &ufunc_hyp1f1_ptr[2*1]
ufunc_hyp1f1_data[2] = &ufunc_hyp1f1_ptr[2*2]
ufunc_hyp1f1_data[3] = &ufunc_hyp1f1_ptr[2*3]
hyp1f1 = np.PyUFunc_FromFuncAndData(ufunc_hyp1f1_loops, ufunc_hyp1f1_data, ufunc_hyp1f1_types, 4, 3, 1, 0, "hyp1f1", ufunc_hyp1f1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hyp2f1_loops[4]
cdef void *ufunc_hyp2f1_ptr[8]
cdef void *ufunc_hyp2f1_data[4]
cdef char ufunc_hyp2f1_types[20]
cdef char *ufunc_hyp2f1_doc = (
    "hyp2f1(a, b, c, z, out=None)\n"
    "\n"
    "Gauss hypergeometric function 2F1(a, b; c; z)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b, c : array_like\n"
    "    Arguments, should be real-valued.\n"
    "z : array_like\n"
    "    Argument, real or complex.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "hyp2f1 : scalar or ndarray\n"
    "    The values of the gaussian hypergeometric function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "hyp0f1 : confluent hypergeometric limit function.\n"
    "hyp1f1 : Kummer's (confluent hypergeometric) function.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function is defined for :math:`|z| < 1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "   \\mathrm{hyp2f1}(a, b, c, z) = \\sum_{n=0}^\\infty\n"
    "   \\frac{(a)_n (b)_n}{(c)_n}\\frac{z^n}{n!},\n"
    "\n"
    "and defined on the rest of the complex z-plane by analytic\n"
    "continuation [1]_.\n"
    "Here :math:`(\\cdot)_n` is the Pochhammer symbol; see `poch`. When\n"
    ":math:`n` is an integer the result is a polynomial of degree :math:`n`.\n"
    "\n"
    "The implementation for complex values of ``z`` is described in [2]_,\n"
    "except for ``z`` in the region defined by\n"
    "\n"
    ".. math::\n"
    "\n"
    "     0.9 <= \\left|z\\right| < 1.1,\n"
    "     \\left|1 - z\\right| >= 0.9,\n"
    "     \\mathrm{real}(z) >= 0\n"
    "\n"
    "in which the implementation follows [4]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/15.2\n"
    ".. [2] S. Zhang and J.M. Jin, \"Computation of Special Functions\", Wiley 1996\n"
    ".. [3] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    ".. [4] J.L. Lopez and N.M. Temme, \"New series expansions of the Gauss\n"
    "       hypergeometric function\", Adv Comput Math 39, 349-365 (2013).\n"
    "       https://doi.org/10.1007/s10444-012-9283-y\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It has poles when `c` is a negative integer.\n"
    "\n"
    ">>> sc.hyp2f1(1, 1, -2, 1)\n"
    "inf\n"
    "\n"
    "It is a polynomial when `a` or `b` is a negative integer.\n"
    "\n"
    ">>> a, b, c = -1, 1, 1.5\n"
    ">>> z = np.linspace(0, 1, 5)\n"
    ">>> sc.hyp2f1(a, b, c, z)\n"
    "array([1.        , 0.83333333, 0.66666667, 0.5       , 0.33333333])\n"
    ">>> 1 + a * b * z / c\n"
    "array([1.        , 0.83333333, 0.66666667, 0.5       , 0.33333333])\n"
    "\n"
    "It is symmetric in `a` and `b`.\n"
    "\n"
    ">>> a = np.linspace(0, 1, 5)\n"
    ">>> b = np.linspace(0, 1, 5)\n"
    ">>> sc.hyp2f1(a, b, 1, 0.5)\n"
    "array([1.        , 1.03997334, 1.1803406 , 1.47074441, 2.        ])\n"
    ">>> sc.hyp2f1(b, a, 1, 0.5)\n"
    "array([1.        , 1.03997334, 1.1803406 , 1.47074441, 2.        ])\n"
    "\n"
    "It contains many other functions as special cases.\n"
    "\n"
    ">>> z = 0.5\n"
    ">>> sc.hyp2f1(1, 1, 2, z)\n"
    "1.3862943611198901\n"
    ">>> -np.log(1 - z) / z\n"
    "1.3862943611198906\n"
    "\n"
    ">>> sc.hyp2f1(0.5, 1, 1.5, z**2)\n"
    "1.098612288668109\n"
    ">>> np.log((1 + z) / (1 - z)) / (2 * z)\n"
    "1.0986122886681098\n"
    "\n"
    ">>> sc.hyp2f1(0.5, 1, 1.5, -z**2)\n"
    "0.9272952180016117\n"
    ">>> np.arctan(z) / z\n"
    "0.9272952180016122")
ufunc_hyp2f1_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_hyp2f1_loops[1] = <np.PyUFuncGenericFunction>loop_D_dddD__As_fffF_F
ufunc_hyp2f1_loops[2] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_hyp2f1_loops[3] = <np.PyUFuncGenericFunction>loop_D_dddD__As_dddD_D
ufunc_hyp2f1_types[0] = <char>NPY_FLOAT
ufunc_hyp2f1_types[1] = <char>NPY_FLOAT
ufunc_hyp2f1_types[2] = <char>NPY_FLOAT
ufunc_hyp2f1_types[3] = <char>NPY_FLOAT
ufunc_hyp2f1_types[4] = <char>NPY_FLOAT
ufunc_hyp2f1_types[5] = <char>NPY_FLOAT
ufunc_hyp2f1_types[6] = <char>NPY_FLOAT
ufunc_hyp2f1_types[7] = <char>NPY_FLOAT
ufunc_hyp2f1_types[8] = <char>NPY_CFLOAT
ufunc_hyp2f1_types[9] = <char>NPY_CFLOAT
ufunc_hyp2f1_types[10] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[11] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[12] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[13] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[14] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[15] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[16] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[17] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[18] = <char>NPY_CDOUBLE
ufunc_hyp2f1_types[19] = <char>NPY_CDOUBLE
ufunc_hyp2f1_ptr[2*0] = <void*>_func_hyp2f1
ufunc_hyp2f1_ptr[2*0+1] = <void*>(<char*>"hyp2f1")
ufunc_hyp2f1_ptr[2*1] = <void*>_func_hyp2f1_complex
ufunc_hyp2f1_ptr[2*1+1] = <void*>(<char*>"hyp2f1")
ufunc_hyp2f1_ptr[2*2] = <void*>_func_hyp2f1
ufunc_hyp2f1_ptr[2*2+1] = <void*>(<char*>"hyp2f1")
ufunc_hyp2f1_ptr[2*3] = <void*>_func_hyp2f1_complex
ufunc_hyp2f1_ptr[2*3+1] = <void*>(<char*>"hyp2f1")
ufunc_hyp2f1_data[0] = &ufunc_hyp2f1_ptr[2*0]
ufunc_hyp2f1_data[1] = &ufunc_hyp2f1_ptr[2*1]
ufunc_hyp2f1_data[2] = &ufunc_hyp2f1_ptr[2*2]
ufunc_hyp2f1_data[3] = &ufunc_hyp2f1_ptr[2*3]
hyp2f1 = np.PyUFunc_FromFuncAndData(ufunc_hyp2f1_loops, ufunc_hyp2f1_data, ufunc_hyp2f1_types, 4, 4, 1, 0, "hyp2f1", ufunc_hyp2f1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hyperu_loops[2]
cdef void *ufunc_hyperu_ptr[4]
cdef void *ufunc_hyperu_data[2]
cdef char ufunc_hyperu_types[8]
cdef char *ufunc_hyperu_doc = (
    "hyperu(a, b, x, out=None)\n"
    "\n"
    "Confluent hypergeometric function U\n"
    "\n"
    "It is defined as the solution to the equation\n"
    "\n"
    ".. math::\n"
    "\n"
    "   x \\frac{d^2w}{dx^2} + (b - x) \\frac{dw}{dx} - aw = 0\n"
    "\n"
    "which satisfies the property\n"
    "\n"
    ".. math::\n"
    "\n"
    "   U(a, b, x) \\sim x^{-a}\n"
    "\n"
    "as :math:`x \\to \\infty`. See [dlmf]_ for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Real-valued parameters\n"
    "x : array_like\n"
    "    Real-valued argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of `U`\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST Digital Library of Mathematics Functions\n"
    "          https://dlmf.nist.gov/13.2#E6\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It has a branch cut along the negative `x` axis.\n"
    "\n"
    ">>> x = np.linspace(-0.1, -10, 5)\n"
    ">>> sc.hyperu(1, 1, x)\n"
    "array([nan, nan, nan, nan, nan])\n"
    "\n"
    "It approaches zero as `x` goes to infinity.\n"
    "\n"
    ">>> x = np.array([1, 10, 100])\n"
    ">>> sc.hyperu(1, 1, x)\n"
    "array([0.59634736, 0.09156333, 0.00990194])\n"
    "\n"
    "It satisfies Kummer's transformation.\n"
    "\n"
    ">>> a, b, x = 2, 1, 1\n"
    ">>> sc.hyperu(a, b, x)\n"
    "0.1926947246463881\n"
    ">>> x**(1 - b) * sc.hyperu(a - b + 1, 2 - b, x)\n"
    "0.1926947246463881")
ufunc_hyperu_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_hyperu_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_hyperu_types[0] = <char>NPY_FLOAT
ufunc_hyperu_types[1] = <char>NPY_FLOAT
ufunc_hyperu_types[2] = <char>NPY_FLOAT
ufunc_hyperu_types[3] = <char>NPY_FLOAT
ufunc_hyperu_types[4] = <char>NPY_DOUBLE
ufunc_hyperu_types[5] = <char>NPY_DOUBLE
ufunc_hyperu_types[6] = <char>NPY_DOUBLE
ufunc_hyperu_types[7] = <char>NPY_DOUBLE
ufunc_hyperu_ptr[2*0] = <void*>_func_hyperu
ufunc_hyperu_ptr[2*0+1] = <void*>(<char*>"hyperu")
ufunc_hyperu_ptr[2*1] = <void*>_func_hyperu
ufunc_hyperu_ptr[2*1+1] = <void*>(<char*>"hyperu")
ufunc_hyperu_data[0] = &ufunc_hyperu_ptr[2*0]
ufunc_hyperu_data[1] = &ufunc_hyperu_ptr[2*1]
hyperu = np.PyUFunc_FromFuncAndData(ufunc_hyperu_loops, ufunc_hyperu_data, ufunc_hyperu_types, 2, 3, 1, 0, "hyperu", ufunc_hyperu_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_i0_loops[2]
cdef void *ufunc_i0_ptr[4]
cdef void *ufunc_i0_data[2]
cdef char ufunc_i0_types[4]
cdef char *ufunc_i0_doc = (
    "i0(x, out=None)\n"
    "\n"
    "Modified Bessel function of order 0.\n"
    "\n"
    "Defined as,\n"
    "\n"
    ".. math::\n"
    "    I_0(x) = \\sum_{k=0}^\\infty \\frac{(x^2/4)^k}{(k!)^2} = J_0(\\imath x),\n"
    "\n"
    "where :math:`J_0` is the Bessel function of the first kind of order 0.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : scalar or ndarray\n"
    "    Value of the modified Bessel function of order 0 at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "iv: Modified Bessel function of any order\n"
    "i0e: Exponentially scaled modified Bessel function of order 0\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 8] and (8, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `i0`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function at one point:\n"
    "\n"
    ">>> from scipy.special import i0\n"
    ">>> i0(1.)\n"
    "1.2660658777520082\n"
    "\n"
    "Calculate at several points:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> i0(np.array([-2., 0., 3.5]))\n"
    "array([2.2795853 , 1.        , 7.37820343])\n"
    "\n"
    "Plot the function from -10 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-10., 10., 1000)\n"
    ">>> y = i0(x)\n"
    ">>> ax.plot(x, y)\n"
    ">>> plt.show()")
ufunc_i0_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_i0_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_i0_types[0] = <char>NPY_FLOAT
ufunc_i0_types[1] = <char>NPY_FLOAT
ufunc_i0_types[2] = <char>NPY_DOUBLE
ufunc_i0_types[3] = <char>NPY_DOUBLE
ufunc_i0_ptr[2*0] = <void*>_func_i0
ufunc_i0_ptr[2*0+1] = <void*>(<char*>"i0")
ufunc_i0_ptr[2*1] = <void*>_func_i0
ufunc_i0_ptr[2*1+1] = <void*>(<char*>"i0")
ufunc_i0_data[0] = &ufunc_i0_ptr[2*0]
ufunc_i0_data[1] = &ufunc_i0_ptr[2*1]
i0 = np.PyUFunc_FromFuncAndData(ufunc_i0_loops, ufunc_i0_data, ufunc_i0_types, 2, 1, 1, 0, "i0", ufunc_i0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_i0e_loops[2]
cdef void *ufunc_i0e_ptr[4]
cdef void *ufunc_i0e_data[2]
cdef char ufunc_i0e_types[4]
cdef char *ufunc_i0e_doc = (
    "i0e(x, out=None)\n"
    "\n"
    "Exponentially scaled modified Bessel function of order 0.\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    i0e(x) = exp(-abs(x)) * i0(x).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : scalar or ndarray\n"
    "    Value of the exponentially scaled modified Bessel function of order 0\n"
    "    at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "iv: Modified Bessel function of the first kind\n"
    "i0: Modified Bessel function of order 0\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 8] and (8, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval. The\n"
    "polynomial expansions used are the same as those in `i0`, but\n"
    "they are not multiplied by the dominant exponential factor.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `i0e`. `i0e`\n"
    "is useful for large arguments `x`: for these, `i0` quickly overflows.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "In the following example `i0` returns infinity whereas `i0e` still returns\n"
    "a finite number.\n"
    "\n"
    ">>> from scipy.special import i0, i0e\n"
    ">>> i0(1000.), i0e(1000.)\n"
    "(inf, 0.012617240455891257)\n"
    "\n"
    "Calculate the function at several points by providing a NumPy array or\n"
    "list for `x`:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> i0e(np.array([-2., 0., 3.]))\n"
    "array([0.30850832, 1.        , 0.24300035])\n"
    "\n"
    "Plot the function from -10 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-10., 10., 1000)\n"
    ">>> y = i0e(x)\n"
    ">>> ax.plot(x, y)\n"
    ">>> plt.show()")
ufunc_i0e_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_i0e_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_i0e_types[0] = <char>NPY_FLOAT
ufunc_i0e_types[1] = <char>NPY_FLOAT
ufunc_i0e_types[2] = <char>NPY_DOUBLE
ufunc_i0e_types[3] = <char>NPY_DOUBLE
ufunc_i0e_ptr[2*0] = <void*>_func_i0e
ufunc_i0e_ptr[2*0+1] = <void*>(<char*>"i0e")
ufunc_i0e_ptr[2*1] = <void*>_func_i0e
ufunc_i0e_ptr[2*1+1] = <void*>(<char*>"i0e")
ufunc_i0e_data[0] = &ufunc_i0e_ptr[2*0]
ufunc_i0e_data[1] = &ufunc_i0e_ptr[2*1]
i0e = np.PyUFunc_FromFuncAndData(ufunc_i0e_loops, ufunc_i0e_data, ufunc_i0e_types, 2, 1, 1, 0, "i0e", ufunc_i0e_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_i1_loops[2]
cdef void *ufunc_i1_ptr[4]
cdef void *ufunc_i1_data[2]
cdef char ufunc_i1_types[4]
cdef char *ufunc_i1_doc = (
    "i1(x, out=None)\n"
    "\n"
    "Modified Bessel function of order 1.\n"
    "\n"
    "Defined as,\n"
    "\n"
    ".. math::\n"
    "    I_1(x) = \\frac{1}{2}x \\sum_{k=0}^\\infty \\frac{(x^2/4)^k}{k! (k + 1)!}\n"
    "           = -\\imath J_1(\\imath x),\n"
    "\n"
    "where :math:`J_1` is the Bessel function of the first kind of order 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : scalar or ndarray\n"
    "    Value of the modified Bessel function of order 1 at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "iv: Modified Bessel function of the first kind\n"
    "i1e: Exponentially scaled modified Bessel function of order 1\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 8] and (8, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `i1`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function at one point:\n"
    "\n"
    ">>> from scipy.special import i1\n"
    ">>> i1(1.)\n"
    "0.5651591039924851\n"
    "\n"
    "Calculate the function at several points:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> i1(np.array([-2., 0., 6.]))\n"
    "array([-1.59063685,  0.        , 61.34193678])\n"
    "\n"
    "Plot the function between -10 and 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-10., 10., 1000)\n"
    ">>> y = i1(x)\n"
    ">>> ax.plot(x, y)\n"
    ">>> plt.show()")
ufunc_i1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_i1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_i1_types[0] = <char>NPY_FLOAT
ufunc_i1_types[1] = <char>NPY_FLOAT
ufunc_i1_types[2] = <char>NPY_DOUBLE
ufunc_i1_types[3] = <char>NPY_DOUBLE
ufunc_i1_ptr[2*0] = <void*>_func_i1
ufunc_i1_ptr[2*0+1] = <void*>(<char*>"i1")
ufunc_i1_ptr[2*1] = <void*>_func_i1
ufunc_i1_ptr[2*1+1] = <void*>(<char*>"i1")
ufunc_i1_data[0] = &ufunc_i1_ptr[2*0]
ufunc_i1_data[1] = &ufunc_i1_ptr[2*1]
i1 = np.PyUFunc_FromFuncAndData(ufunc_i1_loops, ufunc_i1_data, ufunc_i1_types, 2, 1, 1, 0, "i1", ufunc_i1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_i1e_loops[2]
cdef void *ufunc_i1e_ptr[4]
cdef void *ufunc_i1e_data[2]
cdef char ufunc_i1e_types[4]
cdef char *ufunc_i1e_doc = (
    "i1e(x, out=None)\n"
    "\n"
    "Exponentially scaled modified Bessel function of order 1.\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    i1e(x) = exp(-abs(x)) * i1(x)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : scalar or ndarray\n"
    "    Value of the exponentially scaled modified Bessel function of order 1\n"
    "    at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "iv: Modified Bessel function of the first kind\n"
    "i1: Modified Bessel function of order 1\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 8] and (8, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval. The\n"
    "polynomial expansions used are the same as those in `i1`, but\n"
    "they are not multiplied by the dominant exponential factor.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `i1e`. `i1e`\n"
    "is useful for large arguments `x`: for these, `i1` quickly overflows.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "In the following example `i1` returns infinity whereas `i1e` still returns\n"
    "a finite number.\n"
    "\n"
    ">>> from scipy.special import i1, i1e\n"
    ">>> i1(1000.), i1e(1000.)\n"
    "(inf, 0.01261093025692863)\n"
    "\n"
    "Calculate the function at several points by providing a NumPy array or\n"
    "list for `x`:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> i1e(np.array([-2., 0., 6.]))\n"
    "array([-0.21526929,  0.        ,  0.15205146])\n"
    "\n"
    "Plot the function between -10 and 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-10., 10., 1000)\n"
    ">>> y = i1e(x)\n"
    ">>> ax.plot(x, y)\n"
    ">>> plt.show()")
ufunc_i1e_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_i1e_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_i1e_types[0] = <char>NPY_FLOAT
ufunc_i1e_types[1] = <char>NPY_FLOAT
ufunc_i1e_types[2] = <char>NPY_DOUBLE
ufunc_i1e_types[3] = <char>NPY_DOUBLE
ufunc_i1e_ptr[2*0] = <void*>_func_i1e
ufunc_i1e_ptr[2*0+1] = <void*>(<char*>"i1e")
ufunc_i1e_ptr[2*1] = <void*>_func_i1e
ufunc_i1e_ptr[2*1+1] = <void*>(<char*>"i1e")
ufunc_i1e_data[0] = &ufunc_i1e_ptr[2*0]
ufunc_i1e_data[1] = &ufunc_i1e_ptr[2*1]
i1e = np.PyUFunc_FromFuncAndData(ufunc_i1e_loops, ufunc_i1e_data, ufunc_i1e_types, 2, 1, 1, 0, "i1e", ufunc_i1e_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_inv_boxcox_loops[2]
cdef void *ufunc_inv_boxcox_ptr[4]
cdef void *ufunc_inv_boxcox_data[2]
cdef char ufunc_inv_boxcox_types[6]
cdef char *ufunc_inv_boxcox_doc = (
    "inv_boxcox(y, lmbda, out=None)\n"
    "\n"
    "Compute the inverse of the Box-Cox transformation.\n"
    "\n"
    "Find ``x`` such that::\n"
    "\n"
    "    y = (x**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(x)                  if lmbda == 0\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.16.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox, inv_boxcox\n"
    ">>> y = boxcox([1, 4, 10], 2.5)\n"
    ">>> inv_boxcox(y, 2.5)\n"
    "array([1., 4., 10.])")
ufunc_inv_boxcox_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_inv_boxcox_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_inv_boxcox_types[0] = <char>NPY_FLOAT
ufunc_inv_boxcox_types[1] = <char>NPY_FLOAT
ufunc_inv_boxcox_types[2] = <char>NPY_FLOAT
ufunc_inv_boxcox_types[3] = <char>NPY_DOUBLE
ufunc_inv_boxcox_types[4] = <char>NPY_DOUBLE
ufunc_inv_boxcox_types[5] = <char>NPY_DOUBLE
ufunc_inv_boxcox_ptr[2*0] = <void*>_func_inv_boxcox
ufunc_inv_boxcox_ptr[2*0+1] = <void*>(<char*>"inv_boxcox")
ufunc_inv_boxcox_ptr[2*1] = <void*>_func_inv_boxcox
ufunc_inv_boxcox_ptr[2*1+1] = <void*>(<char*>"inv_boxcox")
ufunc_inv_boxcox_data[0] = &ufunc_inv_boxcox_ptr[2*0]
ufunc_inv_boxcox_data[1] = &ufunc_inv_boxcox_ptr[2*1]
inv_boxcox = np.PyUFunc_FromFuncAndData(ufunc_inv_boxcox_loops, ufunc_inv_boxcox_data, ufunc_inv_boxcox_types, 2, 2, 1, 0, "inv_boxcox", ufunc_inv_boxcox_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_inv_boxcox1p_loops[2]
cdef void *ufunc_inv_boxcox1p_ptr[4]
cdef void *ufunc_inv_boxcox1p_data[2]
cdef char ufunc_inv_boxcox1p_types[6]
cdef char *ufunc_inv_boxcox1p_doc = (
    "inv_boxcox1p(y, lmbda, out=None)\n"
    "\n"
    "Compute the inverse of the Box-Cox transformation.\n"
    "\n"
    "Find ``x`` such that::\n"
    "\n"
    "    y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(1+x)                    if lmbda == 0\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.16.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox1p, inv_boxcox1p\n"
    ">>> y = boxcox1p([1, 4, 10], 2.5)\n"
    ">>> inv_boxcox1p(y, 2.5)\n"
    "array([1., 4., 10.])")
ufunc_inv_boxcox1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_inv_boxcox1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_inv_boxcox1p_types[0] = <char>NPY_FLOAT
ufunc_inv_boxcox1p_types[1] = <char>NPY_FLOAT
ufunc_inv_boxcox1p_types[2] = <char>NPY_FLOAT
ufunc_inv_boxcox1p_types[3] = <char>NPY_DOUBLE
ufunc_inv_boxcox1p_types[4] = <char>NPY_DOUBLE
ufunc_inv_boxcox1p_types[5] = <char>NPY_DOUBLE
ufunc_inv_boxcox1p_ptr[2*0] = <void*>_func_inv_boxcox1p
ufunc_inv_boxcox1p_ptr[2*0+1] = <void*>(<char*>"inv_boxcox1p")
ufunc_inv_boxcox1p_ptr[2*1] = <void*>_func_inv_boxcox1p
ufunc_inv_boxcox1p_ptr[2*1+1] = <void*>(<char*>"inv_boxcox1p")
ufunc_inv_boxcox1p_data[0] = &ufunc_inv_boxcox1p_ptr[2*0]
ufunc_inv_boxcox1p_data[1] = &ufunc_inv_boxcox1p_ptr[2*1]
inv_boxcox1p = np.PyUFunc_FromFuncAndData(ufunc_inv_boxcox1p_loops, ufunc_inv_boxcox1p_data, ufunc_inv_boxcox1p_types, 2, 2, 1, 0, "inv_boxcox1p", ufunc_inv_boxcox1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_it2i0k0_loops[2]
cdef void *ufunc_it2i0k0_ptr[4]
cdef void *ufunc_it2i0k0_data[2]
cdef char ufunc_it2i0k0_types[6]
cdef char *ufunc_it2i0k0_doc = (
    "it2i0k0(x, out=None)\n"
    "\n"
    "Integrals related to modified Bessel functions of order 0.\n"
    "\n"
    "Computes the integrals\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\int_0^x \\frac{I_0(t) - 1}{t} dt \\\\\n"
    "    \\int_x^\\infty \\frac{K_0(t)}{t} dt.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Values at which to evaluate the integrals.\n"
    "out : tuple of ndarrays, optional\n"
    "    Optional output arrays for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ii0 : scalar or ndarray\n"
    "    The integral for `i0`\n"
    "ik0 : scalar or ndarray\n"
    "    The integral for `k0`\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] S. Zhang and J.M. Jin, \"Computation of Special Functions\",\n"
    "       Wiley 1996\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the functions at one point.\n"
    "\n"
    ">>> from scipy.special import it2i0k0\n"
    ">>> int_i, int_k = it2i0k0(1.)\n"
    ">>> int_i, int_k\n"
    "(0.12897944249456852, 0.2085182909001295)\n"
    "\n"
    "Evaluate the functions at several points.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> points = np.array([0.5, 1.5, 3.])\n"
    ">>> int_i, int_k = it2i0k0(points)\n"
    ">>> int_i, int_k\n"
    "(array([0.03149527, 0.30187149, 1.50012461]),\n"
    " array([0.66575102, 0.0823715 , 0.00823631]))\n"
    "\n"
    "Plot the functions from 0 to 5.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0., 5., 1000)\n"
    ">>> int_i, int_k = it2i0k0(x)\n"
    ">>> ax.plot(x, int_i, label=r\"$\\int_0^x \\frac{I_0(t)-1}{t}\\,dt$\")\n"
    ">>> ax.plot(x, int_k, label=r\"$\\int_x^{\\infty} \\frac{K_0(t)}{t}\\,dt$\")\n"
    ">>> ax.legend()\n"
    ">>> ax.set_ylim(0, 10)\n"
    ">>> plt.show()")
ufunc_it2i0k0_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_it2i0k0_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_it2i0k0_types[0] = <char>NPY_FLOAT
ufunc_it2i0k0_types[1] = <char>NPY_FLOAT
ufunc_it2i0k0_types[2] = <char>NPY_FLOAT
ufunc_it2i0k0_types[3] = <char>NPY_DOUBLE
ufunc_it2i0k0_types[4] = <char>NPY_DOUBLE
ufunc_it2i0k0_types[5] = <char>NPY_DOUBLE
ufunc_it2i0k0_ptr[2*0] = <void*>_func_it2i0k0_wrap
ufunc_it2i0k0_ptr[2*0+1] = <void*>(<char*>"it2i0k0")
ufunc_it2i0k0_ptr[2*1] = <void*>_func_it2i0k0_wrap
ufunc_it2i0k0_ptr[2*1+1] = <void*>(<char*>"it2i0k0")
ufunc_it2i0k0_data[0] = &ufunc_it2i0k0_ptr[2*0]
ufunc_it2i0k0_data[1] = &ufunc_it2i0k0_ptr[2*1]
it2i0k0 = np.PyUFunc_FromFuncAndData(ufunc_it2i0k0_loops, ufunc_it2i0k0_data, ufunc_it2i0k0_types, 2, 1, 2, 0, "it2i0k0", ufunc_it2i0k0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_it2j0y0_loops[2]
cdef void *ufunc_it2j0y0_ptr[4]
cdef void *ufunc_it2j0y0_data[2]
cdef char ufunc_it2j0y0_types[6]
cdef char *ufunc_it2j0y0_doc = (
    "it2j0y0(x, out=None)\n"
    "\n"
    "Integrals related to Bessel functions of the first kind of order 0.\n"
    "\n"
    "Computes the integrals\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\int_0^x \\frac{1 - J_0(t)}{t} dt \\\\\n"
    "    \\int_x^\\infty \\frac{Y_0(t)}{t} dt.\n"
    "\n"
    "For more on :math:`J_0` and :math:`Y_0` see `j0` and `y0`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Values at which to evaluate the integrals.\n"
    "out : tuple of ndarrays, optional\n"
    "    Optional output arrays for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ij0 : scalar or ndarray\n"
    "    The integral for `j0`\n"
    "iy0 : scalar or ndarray\n"
    "    The integral for `y0`\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] S. Zhang and J.M. Jin, \"Computation of Special Functions\",\n"
    "       Wiley 1996\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the functions at one point.\n"
    "\n"
    ">>> from scipy.special import it2j0y0\n"
    ">>> int_j, int_y = it2j0y0(1.)\n"
    ">>> int_j, int_y\n"
    "(0.12116524699506871, 0.39527290169929336)\n"
    "\n"
    "Evaluate the functions at several points.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> points = np.array([0.5, 1.5, 3.])\n"
    ">>> int_j, int_y = it2j0y0(points)\n"
    ">>> int_j, int_y\n"
    "(array([0.03100699, 0.26227724, 0.85614669]),\n"
    " array([ 0.26968854,  0.29769696, -0.02987272]))\n"
    "\n"
    "Plot the functions from 0 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0., 10., 1000)\n"
    ">>> int_j, int_y = it2j0y0(x)\n"
    ">>> ax.plot(x, int_j, label=r\"$\\int_0^x \\frac{1-J_0(t)}{t}\\,dt$\")\n"
    ">>> ax.plot(x, int_y, label=r\"$\\int_x^{\\infty} \\frac{Y_0(t)}{t}\\,dt$\")\n"
    ">>> ax.legend()\n"
    ">>> ax.set_ylim(-2.5, 2.5)\n"
    ">>> plt.show()")
ufunc_it2j0y0_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_it2j0y0_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_it2j0y0_types[0] = <char>NPY_FLOAT
ufunc_it2j0y0_types[1] = <char>NPY_FLOAT
ufunc_it2j0y0_types[2] = <char>NPY_FLOAT
ufunc_it2j0y0_types[3] = <char>NPY_DOUBLE
ufunc_it2j0y0_types[4] = <char>NPY_DOUBLE
ufunc_it2j0y0_types[5] = <char>NPY_DOUBLE
ufunc_it2j0y0_ptr[2*0] = <void*>_func_it2j0y0_wrap
ufunc_it2j0y0_ptr[2*0+1] = <void*>(<char*>"it2j0y0")
ufunc_it2j0y0_ptr[2*1] = <void*>_func_it2j0y0_wrap
ufunc_it2j0y0_ptr[2*1+1] = <void*>(<char*>"it2j0y0")
ufunc_it2j0y0_data[0] = &ufunc_it2j0y0_ptr[2*0]
ufunc_it2j0y0_data[1] = &ufunc_it2j0y0_ptr[2*1]
it2j0y0 = np.PyUFunc_FromFuncAndData(ufunc_it2j0y0_loops, ufunc_it2j0y0_data, ufunc_it2j0y0_types, 2, 1, 2, 0, "it2j0y0", ufunc_it2j0y0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_it2struve0_loops[2]
cdef void *ufunc_it2struve0_ptr[4]
cdef void *ufunc_it2struve0_data[2]
cdef char ufunc_it2struve0_types[4]
cdef char *ufunc_it2struve0_doc = (
    "it2struve0(x, out=None)\n"
    "\n"
    "Integral related to the Struve function of order 0.\n"
    "\n"
    "Returns the integral,\n"
    "\n"
    ".. math::\n"
    "    \\int_x^\\infty \\frac{H_0(t)}{t}\\,dt\n"
    "\n"
    "where :math:`H_0` is the Struve function of order 0.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Lower limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : scalar or ndarray\n"
    "    The value of the integral.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "struve\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for a Fortran routine created by Shanjie Zhang and Jianming\n"
    "Jin [1]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n"
    "       Functions\", John Wiley and Sons, 1996.\n"
    "       https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the function at one point.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import it2struve0\n"
    ">>> it2struve0(1.)\n"
    "0.9571973506383524\n"
    "\n"
    "Evaluate the function at several points by supplying\n"
    "an array for `x`.\n"
    "\n"
    ">>> points = np.array([1., 2., 3.5])\n"
    ">>> it2struve0(points)\n"
    "array([0.95719735, 0.46909296, 0.10366042])\n"
    "\n"
    "Plot the function from -10 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-10., 10., 1000)\n"
    ">>> it2struve0_values = it2struve0(x)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(x, it2struve0_values)\n"
    ">>> ax.set_xlabel(r'$x$')\n"
    ">>> ax.set_ylabel(r'$\\int_x^{\\infty}\\frac{H_0(t)}{t}\\,dt$')\n"
    ">>> plt.show()")
ufunc_it2struve0_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_it2struve0_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_it2struve0_types[0] = <char>NPY_FLOAT
ufunc_it2struve0_types[1] = <char>NPY_FLOAT
ufunc_it2struve0_types[2] = <char>NPY_DOUBLE
ufunc_it2struve0_types[3] = <char>NPY_DOUBLE
ufunc_it2struve0_ptr[2*0] = <void*>_func_it2struve0_wrap
ufunc_it2struve0_ptr[2*0+1] = <void*>(<char*>"it2struve0")
ufunc_it2struve0_ptr[2*1] = <void*>_func_it2struve0_wrap
ufunc_it2struve0_ptr[2*1+1] = <void*>(<char*>"it2struve0")
ufunc_it2struve0_data[0] = &ufunc_it2struve0_ptr[2*0]
ufunc_it2struve0_data[1] = &ufunc_it2struve0_ptr[2*1]
it2struve0 = np.PyUFunc_FromFuncAndData(ufunc_it2struve0_loops, ufunc_it2struve0_data, ufunc_it2struve0_types, 2, 1, 1, 0, "it2struve0", ufunc_it2struve0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_itairy_loops[2]
cdef void *ufunc_itairy_ptr[4]
cdef void *ufunc_itairy_data[2]
cdef char ufunc_itairy_types[10]
cdef char *ufunc_itairy_doc = (
    "itairy(x, out=None)\n"
    "\n"
    "Integrals of Airy functions\n"
    "\n"
    "Calculates the integrals of Airy functions from 0 to `x`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "\n"
    "x : array_like\n"
    "    Upper limit of integration (float).\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Apt : scalar or ndarray\n"
    "    Integral of Ai(t) from 0 to x.\n"
    "Bpt : scalar or ndarray\n"
    "    Integral of Bi(t) from 0 to x.\n"
    "Ant : scalar or ndarray\n"
    "    Integral of Ai(-t) from 0 to x.\n"
    "Bnt : scalar or ndarray\n"
    "    Integral of Bi(-t) from 0 to x.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    "Wrapper for a Fortran routine created by Shanjie Zhang and Jianming\n"
    "Jin [1]_.\n"
    "\n"
    "References\n"
    "----------\n"
    "\n"
    ".. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n"
    "       Functions\", John Wiley and Sons, 1996.\n"
    "       https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the functions at ``x=1.``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import itairy\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> apt, bpt, ant, bnt = itairy(1.)\n"
    ">>> apt, bpt, ant, bnt\n"
    "(0.23631734191710949,\n"
    " 0.8727691167380077,\n"
    " 0.46567398346706845,\n"
    " 0.3730050096342943)\n"
    "\n"
    "Compute the functions at several points by providing a NumPy array for `x`.\n"
    "\n"
    ">>> x = np.array([1., 1.5, 2.5, 5])\n"
    ">>> apt, bpt, ant, bnt = itairy(x)\n"
    ">>> apt, bpt, ant, bnt\n"
    "(array([0.23631734, 0.28678675, 0.324638  , 0.33328759]),\n"
    " array([  0.87276912,   1.62470809,   5.20906691, 321.47831857]),\n"
    " array([0.46567398, 0.72232876, 0.93187776, 0.7178822 ]),\n"
    " array([ 0.37300501,  0.35038814, -0.02812939,  0.15873094]))\n"
    "\n"
    "Plot the functions from -10 to 10.\n"
    "\n"
    ">>> x = np.linspace(-10, 10, 500)\n"
    ">>> apt, bpt, ant, bnt = itairy(x)\n"
    ">>> fig, ax = plt.subplots(figsize=(6, 5))\n"
    ">>> ax.plot(x, apt, label=\"$\\int_0^x\\, Ai(t)\\, dt$\")\n"
    ">>> ax.plot(x, bpt, ls=\"dashed\", label=\"$\\int_0^x\\, Bi(t)\\, dt$\")\n"
    ">>> ax.plot(x, ant, ls=\"dashdot\", label=\"$\\int_0^x\\, Ai(-t)\\, dt$\")\n"
    ">>> ax.plot(x, bnt, ls=\"dotted\", label=\"$\\int_0^x\\, Bi(-t)\\, dt$\")\n"
    ">>> ax.set_ylim(-2, 1.5)\n"
    ">>> ax.legend(loc=\"lower right\")\n"
    ">>> plt.show()")
ufunc_itairy_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_f_ffff
ufunc_itairy_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_d_dddd
ufunc_itairy_types[0] = <char>NPY_FLOAT
ufunc_itairy_types[1] = <char>NPY_FLOAT
ufunc_itairy_types[2] = <char>NPY_FLOAT
ufunc_itairy_types[3] = <char>NPY_FLOAT
ufunc_itairy_types[4] = <char>NPY_FLOAT
ufunc_itairy_types[5] = <char>NPY_DOUBLE
ufunc_itairy_types[6] = <char>NPY_DOUBLE
ufunc_itairy_types[7] = <char>NPY_DOUBLE
ufunc_itairy_types[8] = <char>NPY_DOUBLE
ufunc_itairy_types[9] = <char>NPY_DOUBLE
ufunc_itairy_ptr[2*0] = <void*>_func_itairy_wrap
ufunc_itairy_ptr[2*0+1] = <void*>(<char*>"itairy")
ufunc_itairy_ptr[2*1] = <void*>_func_itairy_wrap
ufunc_itairy_ptr[2*1+1] = <void*>(<char*>"itairy")
ufunc_itairy_data[0] = &ufunc_itairy_ptr[2*0]
ufunc_itairy_data[1] = &ufunc_itairy_ptr[2*1]
itairy = np.PyUFunc_FromFuncAndData(ufunc_itairy_loops, ufunc_itairy_data, ufunc_itairy_types, 2, 1, 4, 0, "itairy", ufunc_itairy_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_iti0k0_loops[2]
cdef void *ufunc_iti0k0_ptr[4]
cdef void *ufunc_iti0k0_data[2]
cdef char ufunc_iti0k0_types[6]
cdef char *ufunc_iti0k0_doc = (
    "iti0k0(x, out=None)\n"
    "\n"
    "Integrals of modified Bessel functions of order 0.\n"
    "\n"
    "Computes the integrals\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\int_0^x I_0(t) dt \\\\\n"
    "    \\int_0^x K_0(t) dt.\n"
    "\n"
    "For more on :math:`I_0` and :math:`K_0` see `i0` and `k0`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Values at which to evaluate the integrals.\n"
    "out : tuple of ndarrays, optional\n"
    "    Optional output arrays for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ii0 : scalar or ndarray\n"
    "    The integral for `i0`\n"
    "ik0 : scalar or ndarray\n"
    "    The integral for `k0`\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] S. Zhang and J.M. Jin, \"Computation of Special Functions\",\n"
    "       Wiley 1996\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the functions at one point.\n"
    "\n"
    ">>> from scipy.special import iti0k0\n"
    ">>> int_i, int_k = iti0k0(1.)\n"
    ">>> int_i, int_k\n"
    "(1.0865210970235892, 1.2425098486237771)\n"
    "\n"
    "Evaluate the functions at several points.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> points = np.array([0., 1.5, 3.])\n"
    ">>> int_i, int_k = iti0k0(points)\n"
    ">>> int_i, int_k\n"
    "(array([0.        , 1.80606937, 6.16096149]),\n"
    " array([0.        , 1.39458246, 1.53994809]))\n"
    "\n"
    "Plot the functions from 0 to 5.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0., 5., 1000)\n"
    ">>> int_i, int_k = iti0k0(x)\n"
    ">>> ax.plot(x, int_i, label=\"$\\int_0^x I_0(t)\\,dt$\")\n"
    ">>> ax.plot(x, int_k, label=\"$\\int_0^x K_0(t)\\,dt$\")\n"
    ">>> ax.legend()\n"
    ">>> plt.show()")
ufunc_iti0k0_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_iti0k0_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_iti0k0_types[0] = <char>NPY_FLOAT
ufunc_iti0k0_types[1] = <char>NPY_FLOAT
ufunc_iti0k0_types[2] = <char>NPY_FLOAT
ufunc_iti0k0_types[3] = <char>NPY_DOUBLE
ufunc_iti0k0_types[4] = <char>NPY_DOUBLE
ufunc_iti0k0_types[5] = <char>NPY_DOUBLE
ufunc_iti0k0_ptr[2*0] = <void*>_func_it1i0k0_wrap
ufunc_iti0k0_ptr[2*0+1] = <void*>(<char*>"iti0k0")
ufunc_iti0k0_ptr[2*1] = <void*>_func_it1i0k0_wrap
ufunc_iti0k0_ptr[2*1+1] = <void*>(<char*>"iti0k0")
ufunc_iti0k0_data[0] = &ufunc_iti0k0_ptr[2*0]
ufunc_iti0k0_data[1] = &ufunc_iti0k0_ptr[2*1]
iti0k0 = np.PyUFunc_FromFuncAndData(ufunc_iti0k0_loops, ufunc_iti0k0_data, ufunc_iti0k0_types, 2, 1, 2, 0, "iti0k0", ufunc_iti0k0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_itj0y0_loops[2]
cdef void *ufunc_itj0y0_ptr[4]
cdef void *ufunc_itj0y0_data[2]
cdef char ufunc_itj0y0_types[6]
cdef char *ufunc_itj0y0_doc = (
    "itj0y0(x, out=None)\n"
    "\n"
    "Integrals of Bessel functions of the first kind of order 0.\n"
    "\n"
    "Computes the integrals\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\int_0^x J_0(t) dt \\\\\n"
    "    \\int_0^x Y_0(t) dt.\n"
    "\n"
    "For more on :math:`J_0` and :math:`Y_0` see `j0` and `y0`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Values at which to evaluate the integrals.\n"
    "out : tuple of ndarrays, optional\n"
    "    Optional output arrays for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ij0 : scalar or ndarray\n"
    "    The integral of `j0`\n"
    "iy0 : scalar or ndarray\n"
    "    The integral of `y0`\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] S. Zhang and J.M. Jin, \"Computation of Special Functions\",\n"
    "       Wiley 1996\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the functions at one point.\n"
    "\n"
    ">>> from scipy.special import itj0y0\n"
    ">>> int_j, int_y = itj0y0(1.)\n"
    ">>> int_j, int_y\n"
    "(0.9197304100897596, -0.637069376607422)\n"
    "\n"
    "Evaluate the functions at several points.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> points = np.array([0., 1.5, 3.])\n"
    ">>> int_j, int_y = itj0y0(points)\n"
    ">>> int_j, int_y\n"
    "(array([0.        , 1.24144951, 1.38756725]),\n"
    " array([ 0.        , -0.51175903,  0.19765826]))\n"
    "\n"
    "Plot the functions from 0 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0., 10., 1000)\n"
    ">>> int_j, int_y = itj0y0(x)\n"
    ">>> ax.plot(x, int_j, label=\"$\\int_0^x J_0(t)\\,dt$\")\n"
    ">>> ax.plot(x, int_y, label=\"$\\int_0^x Y_0(t)\\,dt$\")\n"
    ">>> ax.legend()\n"
    ">>> plt.show()")
ufunc_itj0y0_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_itj0y0_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_itj0y0_types[0] = <char>NPY_FLOAT
ufunc_itj0y0_types[1] = <char>NPY_FLOAT
ufunc_itj0y0_types[2] = <char>NPY_FLOAT
ufunc_itj0y0_types[3] = <char>NPY_DOUBLE
ufunc_itj0y0_types[4] = <char>NPY_DOUBLE
ufunc_itj0y0_types[5] = <char>NPY_DOUBLE
ufunc_itj0y0_ptr[2*0] = <void*>_func_it1j0y0_wrap
ufunc_itj0y0_ptr[2*0+1] = <void*>(<char*>"itj0y0")
ufunc_itj0y0_ptr[2*1] = <void*>_func_it1j0y0_wrap
ufunc_itj0y0_ptr[2*1+1] = <void*>(<char*>"itj0y0")
ufunc_itj0y0_data[0] = &ufunc_itj0y0_ptr[2*0]
ufunc_itj0y0_data[1] = &ufunc_itj0y0_ptr[2*1]
itj0y0 = np.PyUFunc_FromFuncAndData(ufunc_itj0y0_loops, ufunc_itj0y0_data, ufunc_itj0y0_types, 2, 1, 2, 0, "itj0y0", ufunc_itj0y0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_itmodstruve0_loops[2]
cdef void *ufunc_itmodstruve0_ptr[4]
cdef void *ufunc_itmodstruve0_data[2]
cdef char ufunc_itmodstruve0_types[4]
cdef char *ufunc_itmodstruve0_doc = (
    "itmodstruve0(x, out=None)\n"
    "\n"
    "Integral of the modified Struve function of order 0.\n"
    "\n"
    ".. math::\n"
    "    I = \\int_0^x L_0(t)\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper limit of integration (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : scalar or ndarray\n"
    "    The integral of :math:`L_0` from 0 to `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "modstruve: Modified Struve function which is integrated by this function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for a Fortran routine created by Shanjie Zhang and Jianming\n"
    "Jin [1]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n"
    "       Functions\", John Wiley and Sons, 1996.\n"
    "       https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the function at one point.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import itmodstruve0\n"
    ">>> itmodstruve0(1.)\n"
    "0.3364726286440384\n"
    "\n"
    "Evaluate the function at several points by supplying\n"
    "an array for `x`.\n"
    "\n"
    ">>> points = np.array([1., 2., 3.5])\n"
    ">>> itmodstruve0(points)\n"
    "array([0.33647263, 1.588285  , 7.60382578])\n"
    "\n"
    "Plot the function from -10 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-10., 10., 1000)\n"
    ">>> itmodstruve0_values = itmodstruve0(x)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(x, itmodstruve0_values)\n"
    ">>> ax.set_xlabel(r'$x$')\n"
    ">>> ax.set_ylabel(r'$\\int_0^xL_0(t)\\,dt$')\n"
    ">>> plt.show()")
ufunc_itmodstruve0_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_itmodstruve0_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_itmodstruve0_types[0] = <char>NPY_FLOAT
ufunc_itmodstruve0_types[1] = <char>NPY_FLOAT
ufunc_itmodstruve0_types[2] = <char>NPY_DOUBLE
ufunc_itmodstruve0_types[3] = <char>NPY_DOUBLE
ufunc_itmodstruve0_ptr[2*0] = <void*>_func_itmodstruve0_wrap
ufunc_itmodstruve0_ptr[2*0+1] = <void*>(<char*>"itmodstruve0")
ufunc_itmodstruve0_ptr[2*1] = <void*>_func_itmodstruve0_wrap
ufunc_itmodstruve0_ptr[2*1+1] = <void*>(<char*>"itmodstruve0")
ufunc_itmodstruve0_data[0] = &ufunc_itmodstruve0_ptr[2*0]
ufunc_itmodstruve0_data[1] = &ufunc_itmodstruve0_ptr[2*1]
itmodstruve0 = np.PyUFunc_FromFuncAndData(ufunc_itmodstruve0_loops, ufunc_itmodstruve0_data, ufunc_itmodstruve0_types, 2, 1, 1, 0, "itmodstruve0", ufunc_itmodstruve0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_itstruve0_loops[2]
cdef void *ufunc_itstruve0_ptr[4]
cdef void *ufunc_itstruve0_data[2]
cdef char ufunc_itstruve0_types[4]
cdef char *ufunc_itstruve0_doc = (
    "itstruve0(x, out=None)\n"
    "\n"
    "Integral of the Struve function of order 0.\n"
    "\n"
    ".. math::\n"
    "    I = \\int_0^x H_0(t)\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper limit of integration (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : scalar or ndarray\n"
    "    The integral of :math:`H_0` from 0 to `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "struve: Function which is integrated by this function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for a Fortran routine created by Shanjie Zhang and Jianming\n"
    "Jin [1]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n"
    "       Functions\", John Wiley and Sons, 1996.\n"
    "       https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the function at one point.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import itstruve0\n"
    ">>> itstruve0(1.)\n"
    "0.30109042670805547\n"
    "\n"
    "Evaluate the function at several points by supplying\n"
    "an array for `x`.\n"
    "\n"
    ">>> points = np.array([1., 2., 3.5])\n"
    ">>> itstruve0(points)\n"
    "array([0.30109043, 1.01870116, 1.96804581])\n"
    "\n"
    "Plot the function from -20 to 20.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-20., 20., 1000)\n"
    ">>> istruve0_values = itstruve0(x)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(x, istruve0_values)\n"
    ">>> ax.set_xlabel(r'$x$')\n"
    ">>> ax.set_ylabel(r'$\\int_0^{x}H_0(t)\\,dt$')\n"
    ">>> plt.show()")
ufunc_itstruve0_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_itstruve0_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_itstruve0_types[0] = <char>NPY_FLOAT
ufunc_itstruve0_types[1] = <char>NPY_FLOAT
ufunc_itstruve0_types[2] = <char>NPY_DOUBLE
ufunc_itstruve0_types[3] = <char>NPY_DOUBLE
ufunc_itstruve0_ptr[2*0] = <void*>_func_itstruve0_wrap
ufunc_itstruve0_ptr[2*0+1] = <void*>(<char*>"itstruve0")
ufunc_itstruve0_ptr[2*1] = <void*>_func_itstruve0_wrap
ufunc_itstruve0_ptr[2*1+1] = <void*>(<char*>"itstruve0")
ufunc_itstruve0_data[0] = &ufunc_itstruve0_ptr[2*0]
ufunc_itstruve0_data[1] = &ufunc_itstruve0_ptr[2*1]
itstruve0 = np.PyUFunc_FromFuncAndData(ufunc_itstruve0_loops, ufunc_itstruve0_data, ufunc_itstruve0_types, 2, 1, 1, 0, "itstruve0", ufunc_itstruve0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_iv_loops[4]
cdef void *ufunc_iv_ptr[8]
cdef void *ufunc_iv_data[4]
cdef char ufunc_iv_types[12]
cdef char *ufunc_iv_doc = (
    "iv(v, z, out=None)\n"
    "\n"
    "Modified Bessel function of the first kind of real order.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order. If `z` is of real type and negative, `v` must be integer\n"
    "    valued.\n"
    "z : array_like of float or complex\n"
    "    Argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the modified Bessel function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ive : This function with leading exponential behavior stripped off.\n"
    "i0 : Faster version of this function for order 0.\n"
    "i1 : Faster version of this function for order 1.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For real `z` and :math:`v \\in [-50, 50]`, the evaluation is carried out\n"
    "using Temme's method [1]_.  For larger orders, uniform asymptotic\n"
    "expansions are applied.\n"
    "\n"
    "For complex `z` and positive `v`, the AMOS [2]_ `zbesi` routine is\n"
    "called. It uses a power series for small `z`, the asymptotic expansion\n"
    "for large `abs(z)`, the Miller algorithm normalized by the Wronskian\n"
    "and a Neumann series for intermediate magnitudes, and the uniform\n"
    "asymptotic expansions for :math:`I_v(z)` and :math:`J_v(z)` for large\n"
    "orders. Backward recurrence is used to generate sequences or reduce\n"
    "orders when necessary.\n"
    "\n"
    "The calculations above are done in the right half plane and continued\n"
    "into the left half plane by the formula,\n"
    "\n"
    ".. math:: I_v(z \\exp(\\pm\\imath\\pi)) = \\exp(\\pm\\pi v) I_v(z)\n"
    "\n"
    "(valid when the real part of `z` is positive).  For negative `v`, the\n"
    "formula\n"
    "\n"
    ".. math:: I_{-v}(z) = I_v(z) + \\frac{2}{\\pi} \\sin(\\pi v) K_v(z)\n"
    "\n"
    "is used, where :math:`K_v(z)` is the modified Bessel function of the\n"
    "second kind, evaluated using the AMOS routine `zbesk`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Temme, Journal of Computational Physics, vol 21, 343 (1976)\n"
    ".. [2] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the function of order 0 at one point.\n"
    "\n"
    ">>> from scipy.special import iv\n"
    ">>> iv(0, 1.)\n"
    "1.2660658777520084\n"
    "\n"
    "Evaluate the function at one point for different orders.\n"
    "\n"
    ">>> iv(0, 1.), iv(1, 1.), iv(1.5, 1.)\n"
    "(1.2660658777520084, 0.565159103992485, 0.2935253263474798)\n"
    "\n"
    "The evaluation for different orders can be carried out in one call by\n"
    "providing a list or NumPy array as argument for the `v` parameter:\n"
    "\n"
    ">>> iv([0, 1, 1.5], 1.)\n"
    "array([1.26606588, 0.5651591 , 0.29352533])\n"
    "\n"
    "Evaluate the function at several points for order 0 by providing an\n"
    "array for `z`.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> points = np.array([-2., 0., 3.])\n"
    ">>> iv(0, points)\n"
    "array([2.2795853 , 1.        , 4.88079259])\n"
    "\n"
    "If `z` is an array, the order parameter `v` must be broadcastable to\n"
    "the correct shape if different orders shall be computed in one call.\n"
    "To calculate the orders 0 and 1 for an 1D array:\n"
    "\n"
    ">>> orders = np.array([[0], [1]])\n"
    ">>> orders.shape\n"
    "(2, 1)\n"
    "\n"
    ">>> iv(orders, points)\n"
    "array([[ 2.2795853 ,  1.        ,  4.88079259],\n"
    "       [-1.59063685,  0.        ,  3.95337022]])\n"
    "\n"
    "Plot the functions of order 0 to 3 from -5 to 5.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-5., 5., 1000)\n"
    ">>> for i in range(4):\n"
    "...     ax.plot(x, iv(i, x), label=f'$I_{i!r}$')\n"
    ">>> ax.legend()\n"
    ">>> plt.show()")
ufunc_iv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_iv_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_iv_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_iv_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_iv_types[0] = <char>NPY_FLOAT
ufunc_iv_types[1] = <char>NPY_FLOAT
ufunc_iv_types[2] = <char>NPY_FLOAT
ufunc_iv_types[3] = <char>NPY_FLOAT
ufunc_iv_types[4] = <char>NPY_CFLOAT
ufunc_iv_types[5] = <char>NPY_CFLOAT
ufunc_iv_types[6] = <char>NPY_DOUBLE
ufunc_iv_types[7] = <char>NPY_DOUBLE
ufunc_iv_types[8] = <char>NPY_DOUBLE
ufunc_iv_types[9] = <char>NPY_DOUBLE
ufunc_iv_types[10] = <char>NPY_CDOUBLE
ufunc_iv_types[11] = <char>NPY_CDOUBLE
ufunc_iv_ptr[2*0] = <void*>_func_iv
ufunc_iv_ptr[2*0+1] = <void*>(<char*>"iv")
ufunc_iv_ptr[2*1] = <void*>_func_cbesi_wrap
ufunc_iv_ptr[2*1+1] = <void*>(<char*>"iv")
ufunc_iv_ptr[2*2] = <void*>_func_iv
ufunc_iv_ptr[2*2+1] = <void*>(<char*>"iv")
ufunc_iv_ptr[2*3] = <void*>_func_cbesi_wrap
ufunc_iv_ptr[2*3+1] = <void*>(<char*>"iv")
ufunc_iv_data[0] = &ufunc_iv_ptr[2*0]
ufunc_iv_data[1] = &ufunc_iv_ptr[2*1]
ufunc_iv_data[2] = &ufunc_iv_ptr[2*2]
ufunc_iv_data[3] = &ufunc_iv_ptr[2*3]
iv = np.PyUFunc_FromFuncAndData(ufunc_iv_loops, ufunc_iv_data, ufunc_iv_types, 4, 2, 1, 0, "iv", ufunc_iv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ive_loops[4]
cdef void *ufunc_ive_ptr[8]
cdef void *ufunc_ive_data[4]
cdef char ufunc_ive_types[12]
cdef char *ufunc_ive_doc = (
    "ive(v, z, out=None)\n"
    "\n"
    "Exponentially scaled modified Bessel function of the first kind.\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    ive(v, z) = iv(v, z) * exp(-abs(z.real))\n"
    "\n"
    "For imaginary numbers without a real part, returns the unscaled\n"
    "Bessel function of the first kind `iv`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like of float\n"
    "    Order.\n"
    "z : array_like of float or complex\n"
    "    Argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the exponentially scaled modified Bessel function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "iv: Modified Bessel function of the first kind\n"
    "i0e: Faster implementation of this function for order 0\n"
    "i1e: Faster implementation of this function for order 1\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For positive `v`, the AMOS [1]_ `zbesi` routine is called. It uses a\n"
    "power series for small `z`, the asymptotic expansion for large\n"
    "`abs(z)`, the Miller algorithm normalized by the Wronskian and a\n"
    "Neumann series for intermediate magnitudes, and the uniform asymptotic\n"
    "expansions for :math:`I_v(z)` and :math:`J_v(z)` for large orders.\n"
    "Backward recurrence is used to generate sequences or reduce orders when\n"
    "necessary.\n"
    "\n"
    "The calculations above are done in the right half plane and continued\n"
    "into the left half plane by the formula,\n"
    "\n"
    ".. math:: I_v(z \\exp(\\pm\\imath\\pi)) = \\exp(\\pm\\pi v) I_v(z)\n"
    "\n"
    "(valid when the real part of `z` is positive).  For negative `v`, the\n"
    "formula\n"
    "\n"
    ".. math:: I_{-v}(z) = I_v(z) + \\frac{2}{\\pi} \\sin(\\pi v) K_v(z)\n"
    "\n"
    "is used, where :math:`K_v(z)` is the modified Bessel function of the\n"
    "second kind, evaluated using the AMOS routine `zbesk`.\n"
    "\n"
    "`ive` is useful for large arguments `z`: for these, `iv` easily overflows,\n"
    "while `ive` does not due to the exponential scaling.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "In the following example `iv` returns infinity whereas `ive` still returns\n"
    "a finite number.\n"
    "\n"
    ">>> from scipy.special import iv, ive\n"
    ">>> import numpy as np\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> iv(3, 1000.), ive(3, 1000.)\n"
    "(inf, 0.01256056218254712)\n"
    "\n"
    "Evaluate the function at one point for different orders by\n"
    "providing a list or NumPy array as argument for the `v` parameter:\n"
    "\n"
    ">>> ive([0, 1, 1.5], 1.)\n"
    "array([0.46575961, 0.20791042, 0.10798193])\n"
    "\n"
    "Evaluate the function at several points for order 0 by providing an\n"
    "array for `z`.\n"
    "\n"
    ">>> points = np.array([-2., 0., 3.])\n"
    ">>> ive(0, points)\n"
    "array([0.30850832, 1.        , 0.24300035])\n"
    "\n"
    "Evaluate the function at several points for different orders by\n"
    "providing arrays for both `v` for `z`. Both arrays have to be\n"
    "broadcastable to the correct shape. To calculate the orders 0, 1\n"
    "and 2 for a 1D array of points:\n"
    "\n"
    ">>> ive([[0], [1], [2]], points)\n"
    "array([[ 0.30850832,  1.        ,  0.24300035],\n"
    "       [-0.21526929,  0.        ,  0.19682671],\n"
    "       [ 0.09323903,  0.        ,  0.11178255]])\n"
    "\n"
    "Plot the functions of order 0 to 3 from -5 to 5.\n"
    "\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-5., 5., 1000)\n"
    ">>> for i in range(4):\n"
    "...     ax.plot(x, ive(i, x), label=f'$I_{i!r}(z)\\cdot e^{{-|z|}}$')\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(r\"$z$\")\n"
    ">>> plt.show()")
ufunc_ive_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_ive_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_ive_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_ive_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_ive_types[0] = <char>NPY_FLOAT
ufunc_ive_types[1] = <char>NPY_FLOAT
ufunc_ive_types[2] = <char>NPY_FLOAT
ufunc_ive_types[3] = <char>NPY_FLOAT
ufunc_ive_types[4] = <char>NPY_CFLOAT
ufunc_ive_types[5] = <char>NPY_CFLOAT
ufunc_ive_types[6] = <char>NPY_DOUBLE
ufunc_ive_types[7] = <char>NPY_DOUBLE
ufunc_ive_types[8] = <char>NPY_DOUBLE
ufunc_ive_types[9] = <char>NPY_DOUBLE
ufunc_ive_types[10] = <char>NPY_CDOUBLE
ufunc_ive_types[11] = <char>NPY_CDOUBLE
ufunc_ive_ptr[2*0] = <void*>_func_cbesi_wrap_e_real
ufunc_ive_ptr[2*0+1] = <void*>(<char*>"ive")
ufunc_ive_ptr[2*1] = <void*>_func_cbesi_wrap_e
ufunc_ive_ptr[2*1+1] = <void*>(<char*>"ive")
ufunc_ive_ptr[2*2] = <void*>_func_cbesi_wrap_e_real
ufunc_ive_ptr[2*2+1] = <void*>(<char*>"ive")
ufunc_ive_ptr[2*3] = <void*>_func_cbesi_wrap_e
ufunc_ive_ptr[2*3+1] = <void*>(<char*>"ive")
ufunc_ive_data[0] = &ufunc_ive_ptr[2*0]
ufunc_ive_data[1] = &ufunc_ive_ptr[2*1]
ufunc_ive_data[2] = &ufunc_ive_ptr[2*2]
ufunc_ive_data[3] = &ufunc_ive_ptr[2*3]
ive = np.PyUFunc_FromFuncAndData(ufunc_ive_loops, ufunc_ive_data, ufunc_ive_types, 4, 2, 1, 0, "ive", ufunc_ive_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_j0_loops[2]
cdef void *ufunc_j0_ptr[4]
cdef void *ufunc_j0_data[2]
cdef char ufunc_j0_types[4]
cdef char *ufunc_j0_doc = (
    "j0(x, out=None)\n"
    "\n"
    "Bessel function of the first kind of order 0.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "J : scalar or ndarray\n"
    "    Value of the Bessel function of the first kind of order 0 at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "jv : Bessel function of real order and complex argument.\n"
    "spherical_jn : spherical Bessel functions.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The domain is divided into the intervals [0, 5] and (5, infinity). In the\n"
    "first interval the following rational approximation is used:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    J_0(x) \\approx (w - r_1^2)(w - r_2^2) \\frac{P_3(w)}{Q_8(w)},\n"
    "\n"
    "where :math:`w = x^2` and :math:`r_1`, :math:`r_2` are the zeros of\n"
    ":math:`J_0`, and :math:`P_3` and :math:`Q_8` are polynomials of degrees 3\n"
    "and 8, respectively.\n"
    "\n"
    "In the second interval, the Hankel asymptotic expansion is employed with\n"
    "two rational functions of degree 6/6 and 7/7.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `j0`.\n"
    "It should not be confused with the spherical Bessel functions (see\n"
    "`spherical_jn`).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function at one point:\n"
    "\n"
    ">>> from scipy.special import j0\n"
    ">>> j0(1.)\n"
    "0.7651976865579665\n"
    "\n"
    "Calculate the function at several points:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> j0(np.array([-2., 0., 4.]))\n"
    "array([ 0.22389078,  1.        , -0.39714981])\n"
    "\n"
    "Plot the function from -20 to 20.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-20., 20., 1000)\n"
    ">>> y = j0(x)\n"
    ">>> ax.plot(x, y)\n"
    ">>> plt.show()")
ufunc_j0_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_j0_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_j0_types[0] = <char>NPY_FLOAT
ufunc_j0_types[1] = <char>NPY_FLOAT
ufunc_j0_types[2] = <char>NPY_DOUBLE
ufunc_j0_types[3] = <char>NPY_DOUBLE
ufunc_j0_ptr[2*0] = <void*>_func_j0
ufunc_j0_ptr[2*0+1] = <void*>(<char*>"j0")
ufunc_j0_ptr[2*1] = <void*>_func_j0
ufunc_j0_ptr[2*1+1] = <void*>(<char*>"j0")
ufunc_j0_data[0] = &ufunc_j0_ptr[2*0]
ufunc_j0_data[1] = &ufunc_j0_ptr[2*1]
j0 = np.PyUFunc_FromFuncAndData(ufunc_j0_loops, ufunc_j0_data, ufunc_j0_types, 2, 1, 1, 0, "j0", ufunc_j0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_j1_loops[2]
cdef void *ufunc_j1_ptr[4]
cdef void *ufunc_j1_data[2]
cdef char ufunc_j1_types[4]
cdef char *ufunc_j1_doc = (
    "j1(x, out=None)\n"
    "\n"
    "Bessel function of the first kind of order 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "J : scalar or ndarray\n"
    "    Value of the Bessel function of the first kind of order 1 at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "jv: Bessel function of the first kind\n"
    "spherical_jn: spherical Bessel functions.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The domain is divided into the intervals [0, 8] and (8, infinity). In the\n"
    "first interval a 24 term Chebyshev expansion is used. In the second, the\n"
    "asymptotic trigonometric representation is employed using two rational\n"
    "functions of degree 5/5.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `j1`.\n"
    "It should not be confused with the spherical Bessel functions (see\n"
    "`spherical_jn`).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function at one point:\n"
    "\n"
    ">>> from scipy.special import j1\n"
    ">>> j1(1.)\n"
    "0.44005058574493355\n"
    "\n"
    "Calculate the function at several points:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> j1(np.array([-2., 0., 4.]))\n"
    "array([-0.57672481,  0.        , -0.06604333])\n"
    "\n"
    "Plot the function from -20 to 20.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-20., 20., 1000)\n"
    ">>> y = j1(x)\n"
    ">>> ax.plot(x, y)\n"
    ">>> plt.show()")
ufunc_j1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_j1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_j1_types[0] = <char>NPY_FLOAT
ufunc_j1_types[1] = <char>NPY_FLOAT
ufunc_j1_types[2] = <char>NPY_DOUBLE
ufunc_j1_types[3] = <char>NPY_DOUBLE
ufunc_j1_ptr[2*0] = <void*>_func_j1
ufunc_j1_ptr[2*0+1] = <void*>(<char*>"j1")
ufunc_j1_ptr[2*1] = <void*>_func_j1
ufunc_j1_ptr[2*1+1] = <void*>(<char*>"j1")
ufunc_j1_data[0] = &ufunc_j1_ptr[2*0]
ufunc_j1_data[1] = &ufunc_j1_ptr[2*1]
j1 = np.PyUFunc_FromFuncAndData(ufunc_j1_loops, ufunc_j1_data, ufunc_j1_types, 2, 1, 1, 0, "j1", ufunc_j1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_jv_loops[4]
cdef void *ufunc_jv_ptr[8]
cdef void *ufunc_jv_data[4]
cdef char ufunc_jv_types[12]
cdef char *ufunc_jv_doc = (
    "jv(v, z, out=None)\n"
    "\n"
    "Bessel function of the first kind of real order and complex argument.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "J : scalar or ndarray\n"
    "    Value of the Bessel function, :math:`J_v(z)`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "jve : :math:`J_v` with leading exponential behavior stripped off.\n"
    "spherical_jn : spherical Bessel functions.\n"
    "j0 : faster version of this function for order 0.\n"
    "j1 : faster version of this function for order 1.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For positive `v` values, the computation is carried out using the AMOS\n"
    "[1]_ `zbesj` routine, which exploits the connection to the modified\n"
    "Bessel function :math:`I_v`,\n"
    "\n"
    ".. math::\n"
    "    J_v(z) = \\exp(v\\pi\\imath/2) I_v(-\\imath z)\\qquad (\\Im z > 0)\n"
    "\n"
    "    J_v(z) = \\exp(-v\\pi\\imath/2) I_v(\\imath z)\\qquad (\\Im z < 0)\n"
    "\n"
    "For negative `v` values the formula,\n"
    "\n"
    ".. math:: J_{-v}(z) = J_v(z) \\cos(\\pi v) - Y_v(z) \\sin(\\pi v)\n"
    "\n"
    "is used, where :math:`Y_v(z)` is the Bessel function of the second\n"
    "kind, computed using the AMOS routine `zbesy`.  Note that the second\n"
    "term is exactly zero for integer `v`; to improve accuracy the second\n"
    "term is explicitly omitted for `v` values such that `v = floor(v)`.\n"
    "\n"
    "Not to be confused with the spherical Bessel functions (see `spherical_jn`).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the function of order 0 at one point.\n"
    "\n"
    ">>> from scipy.special import jv\n"
    ">>> jv(0, 1.)\n"
    "0.7651976865579666\n"
    "\n"
    "Evaluate the function at one point for different orders.\n"
    "\n"
    ">>> jv(0, 1.), jv(1, 1.), jv(1.5, 1.)\n"
    "(0.7651976865579666, 0.44005058574493355, 0.24029783912342725)\n"
    "\n"
    "The evaluation for different orders can be carried out in one call by\n"
    "providing a list or NumPy array as argument for the `v` parameter:\n"
    "\n"
    ">>> jv([0, 1, 1.5], 1.)\n"
    "array([0.76519769, 0.44005059, 0.24029784])\n"
    "\n"
    "Evaluate the function at several points for order 0 by providing an\n"
    "array for `z`.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> points = np.array([-2., 0., 3.])\n"
    ">>> jv(0, points)\n"
    "array([ 0.22389078,  1.        , -0.26005195])\n"
    "\n"
    "If `z` is an array, the order parameter `v` must be broadcastable to\n"
    "the correct shape if different orders shall be computed in one call.\n"
    "To calculate the orders 0 and 1 for an 1D array:\n"
    "\n"
    ">>> orders = np.array([[0], [1]])\n"
    ">>> orders.shape\n"
    "(2, 1)\n"
    "\n"
    ">>> jv(orders, points)\n"
    "array([[ 0.22389078,  1.        , -0.26005195],\n"
    "       [-0.57672481,  0.        ,  0.33905896]])\n"
    "\n"
    "Plot the functions of order 0 to 3 from -10 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-10., 10., 1000)\n"
    ">>> for i in range(4):\n"
    "...     ax.plot(x, jv(i, x), label=f'$J_{i!r}$')\n"
    ">>> ax.legend()\n"
    ">>> plt.show()")
ufunc_jv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_jv_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_jv_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_jv_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_jv_types[0] = <char>NPY_FLOAT
ufunc_jv_types[1] = <char>NPY_FLOAT
ufunc_jv_types[2] = <char>NPY_FLOAT
ufunc_jv_types[3] = <char>NPY_FLOAT
ufunc_jv_types[4] = <char>NPY_CFLOAT
ufunc_jv_types[5] = <char>NPY_CFLOAT
ufunc_jv_types[6] = <char>NPY_DOUBLE
ufunc_jv_types[7] = <char>NPY_DOUBLE
ufunc_jv_types[8] = <char>NPY_DOUBLE
ufunc_jv_types[9] = <char>NPY_DOUBLE
ufunc_jv_types[10] = <char>NPY_CDOUBLE
ufunc_jv_types[11] = <char>NPY_CDOUBLE
ufunc_jv_ptr[2*0] = <void*>_func_cbesj_wrap_real
ufunc_jv_ptr[2*0+1] = <void*>(<char*>"jv")
ufunc_jv_ptr[2*1] = <void*>_func_cbesj_wrap
ufunc_jv_ptr[2*1+1] = <void*>(<char*>"jv")
ufunc_jv_ptr[2*2] = <void*>_func_cbesj_wrap_real
ufunc_jv_ptr[2*2+1] = <void*>(<char*>"jv")
ufunc_jv_ptr[2*3] = <void*>_func_cbesj_wrap
ufunc_jv_ptr[2*3+1] = <void*>(<char*>"jv")
ufunc_jv_data[0] = &ufunc_jv_ptr[2*0]
ufunc_jv_data[1] = &ufunc_jv_ptr[2*1]
ufunc_jv_data[2] = &ufunc_jv_ptr[2*2]
ufunc_jv_data[3] = &ufunc_jv_ptr[2*3]
jv = np.PyUFunc_FromFuncAndData(ufunc_jv_loops, ufunc_jv_data, ufunc_jv_types, 4, 2, 1, 0, "jv", ufunc_jv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_jve_loops[4]
cdef void *ufunc_jve_ptr[8]
cdef void *ufunc_jve_data[4]
cdef char ufunc_jve_types[12]
cdef char *ufunc_jve_doc = (
    "jve(v, z, out=None)\n"
    "\n"
    "Exponentially scaled Bessel function of the first kind of order `v`.\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    jve(v, z) = jv(v, z) * exp(-abs(z.imag))\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "J : scalar or ndarray\n"
    "    Value of the exponentially scaled Bessel function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "jv: Unscaled Bessel function of the first kind\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For positive `v` values, the computation is carried out using the AMOS\n"
    "[1]_ `zbesj` routine, which exploits the connection to the modified\n"
    "Bessel function :math:`I_v`,\n"
    "\n"
    ".. math::\n"
    "    J_v(z) = \\exp(v\\pi\\imath/2) I_v(-\\imath z)\\qquad (\\Im z > 0)\n"
    "\n"
    "    J_v(z) = \\exp(-v\\pi\\imath/2) I_v(\\imath z)\\qquad (\\Im z < 0)\n"
    "\n"
    "For negative `v` values the formula,\n"
    "\n"
    ".. math:: J_{-v}(z) = J_v(z) \\cos(\\pi v) - Y_v(z) \\sin(\\pi v)\n"
    "\n"
    "is used, where :math:`Y_v(z)` is the Bessel function of the second\n"
    "kind, computed using the AMOS routine `zbesy`.  Note that the second\n"
    "term is exactly zero for integer `v`; to improve accuracy the second\n"
    "term is explicitly omitted for `v` values such that `v = floor(v)`.\n"
    "\n"
    "Exponentially scaled Bessel functions are useful for large arguments `z`:\n"
    "for these, the unscaled Bessel functions can easily under-or overflow.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compare the output of `jv` and `jve` for large complex arguments for `z`\n"
    "by computing their values for order ``v=1`` at ``z=1000j``. We see that\n"
    "`jv` overflows but `jve` returns a finite number:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import jv, jve\n"
    ">>> v = 1\n"
    ">>> z = 1000j\n"
    ">>> jv(v, z), jve(v, z)\n"
    "((inf+infj), (7.721967686709077e-19+0.012610930256928629j))\n"
    "\n"
    "For real arguments for `z`, `jve` returns the same as `jv`.\n"
    "\n"
    ">>> v, z = 1, 1000\n"
    ">>> jv(v, z), jve(v, z)\n"
    "(0.004728311907089523, 0.004728311907089523)\n"
    "\n"
    "The function can be evaluated for several orders at the same time by\n"
    "providing a list or NumPy array for `v`:\n"
    "\n"
    ">>> jve([1, 3, 5], 1j)\n"
    "array([1.27304208e-17+2.07910415e-01j, -4.99352086e-19-8.15530777e-03j,\n"
    "       6.11480940e-21+9.98657141e-05j])\n"
    "\n"
    "In the same way, the function can be evaluated at several points in one\n"
    "call by providing a list or NumPy array for `z`:\n"
    "\n"
    ">>> jve(1, np.array([1j, 2j, 3j]))\n"
    "array([1.27308412e-17+0.20791042j, 1.31814423e-17+0.21526929j,\n"
    "       1.20521602e-17+0.19682671j])\n"
    "\n"
    "It is also possible to evaluate several orders at several points\n"
    "at the same time by providing arrays for `v` and `z` with\n"
    "compatible shapes for broadcasting. Compute `jve` for two different orders\n"
    "`v` and three points `z` resulting in a 2x3 array.\n"
    "\n"
    ">>> v = np.array([[1], [3]])\n"
    ">>> z = np.array([1j, 2j, 3j])\n"
    ">>> v.shape, z.shape\n"
    "((2, 1), (3,))\n"
    "\n"
    ">>> jve(v, z)\n"
    "array([[1.27304208e-17+0.20791042j,  1.31810070e-17+0.21526929j,\n"
    "        1.20517622e-17+0.19682671j],\n"
    "       [-4.99352086e-19-0.00815531j, -1.76289571e-18-0.02879122j,\n"
    "        -2.92578784e-18-0.04778332j]])")
ufunc_jve_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_jve_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_jve_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_jve_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_jve_types[0] = <char>NPY_FLOAT
ufunc_jve_types[1] = <char>NPY_FLOAT
ufunc_jve_types[2] = <char>NPY_FLOAT
ufunc_jve_types[3] = <char>NPY_FLOAT
ufunc_jve_types[4] = <char>NPY_CFLOAT
ufunc_jve_types[5] = <char>NPY_CFLOAT
ufunc_jve_types[6] = <char>NPY_DOUBLE
ufunc_jve_types[7] = <char>NPY_DOUBLE
ufunc_jve_types[8] = <char>NPY_DOUBLE
ufunc_jve_types[9] = <char>NPY_DOUBLE
ufunc_jve_types[10] = <char>NPY_CDOUBLE
ufunc_jve_types[11] = <char>NPY_CDOUBLE
ufunc_jve_ptr[2*0] = <void*>_func_cbesj_wrap_e_real
ufunc_jve_ptr[2*0+1] = <void*>(<char*>"jve")
ufunc_jve_ptr[2*1] = <void*>_func_cbesj_wrap_e
ufunc_jve_ptr[2*1+1] = <void*>(<char*>"jve")
ufunc_jve_ptr[2*2] = <void*>_func_cbesj_wrap_e_real
ufunc_jve_ptr[2*2+1] = <void*>(<char*>"jve")
ufunc_jve_ptr[2*3] = <void*>_func_cbesj_wrap_e
ufunc_jve_ptr[2*3+1] = <void*>(<char*>"jve")
ufunc_jve_data[0] = &ufunc_jve_ptr[2*0]
ufunc_jve_data[1] = &ufunc_jve_ptr[2*1]
ufunc_jve_data[2] = &ufunc_jve_ptr[2*2]
ufunc_jve_data[3] = &ufunc_jve_ptr[2*3]
jve = np.PyUFunc_FromFuncAndData(ufunc_jve_loops, ufunc_jve_data, ufunc_jve_types, 4, 2, 1, 0, "jve", ufunc_jve_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_k0_loops[2]
cdef void *ufunc_k0_ptr[4]
cdef void *ufunc_k0_data[2]
cdef char ufunc_k0_types[4]
cdef char *ufunc_k0_doc = (
    "k0(x, out=None)\n"
    "\n"
    "Modified Bessel function of the second kind of order 0, :math:`K_0`.\n"
    "\n"
    "This function is also sometimes referred to as the modified Bessel\n"
    "function of the third kind of order 0.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "K : scalar or ndarray\n"
    "    Value of the modified Bessel function :math:`K_0` at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kv: Modified Bessel function of the second kind of any order\n"
    "k0e: Exponentially scaled modified Bessel function of the second kind\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 2] and (2, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `k0`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function at one point:\n"
    "\n"
    ">>> from scipy.special import k0\n"
    ">>> k0(1.)\n"
    "0.42102443824070823\n"
    "\n"
    "Calculate the function at several points:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> k0(np.array([0.5, 2., 3.]))\n"
    "array([0.92441907, 0.11389387, 0.0347395 ])\n"
    "\n"
    "Plot the function from 0 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0., 10., 1000)\n"
    ">>> y = k0(x)\n"
    ">>> ax.plot(x, y)\n"
    ">>> plt.show()")
ufunc_k0_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_k0_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_k0_types[0] = <char>NPY_FLOAT
ufunc_k0_types[1] = <char>NPY_FLOAT
ufunc_k0_types[2] = <char>NPY_DOUBLE
ufunc_k0_types[3] = <char>NPY_DOUBLE
ufunc_k0_ptr[2*0] = <void*>_func_k0
ufunc_k0_ptr[2*0+1] = <void*>(<char*>"k0")
ufunc_k0_ptr[2*1] = <void*>_func_k0
ufunc_k0_ptr[2*1+1] = <void*>(<char*>"k0")
ufunc_k0_data[0] = &ufunc_k0_ptr[2*0]
ufunc_k0_data[1] = &ufunc_k0_ptr[2*1]
k0 = np.PyUFunc_FromFuncAndData(ufunc_k0_loops, ufunc_k0_data, ufunc_k0_types, 2, 1, 1, 0, "k0", ufunc_k0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_k0e_loops[2]
cdef void *ufunc_k0e_ptr[4]
cdef void *ufunc_k0e_data[2]
cdef char ufunc_k0e_types[4]
cdef char *ufunc_k0e_doc = (
    "k0e(x, out=None)\n"
    "\n"
    "Exponentially scaled modified Bessel function K of order 0\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    k0e(x) = exp(x) * k0(x).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "K : scalar or ndarray\n"
    "    Value of the exponentially scaled modified Bessel function K of order\n"
    "    0 at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kv: Modified Bessel function of the second kind of any order\n"
    "k0: Modified Bessel function of the second kind\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 2] and (2, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `k0e`. `k0e` is\n"
    "useful for large arguments: for these, `k0` easily underflows.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "In the following example `k0` returns 0 whereas `k0e` still returns a\n"
    "useful finite number:\n"
    "\n"
    ">>> from scipy.special import k0, k0e\n"
    ">>> k0(1000.), k0e(1000)\n"
    "(0., 0.03962832160075422)\n"
    "\n"
    "Calculate the function at several points by providing a NumPy array or\n"
    "list for `x`:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> k0e(np.array([0.5, 2., 3.]))\n"
    "array([1.52410939, 0.84156822, 0.6977616 ])\n"
    "\n"
    "Plot the function from 0 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0., 10., 1000)\n"
    ">>> y = k0e(x)\n"
    ">>> ax.plot(x, y)\n"
    ">>> plt.show()")
ufunc_k0e_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_k0e_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_k0e_types[0] = <char>NPY_FLOAT
ufunc_k0e_types[1] = <char>NPY_FLOAT
ufunc_k0e_types[2] = <char>NPY_DOUBLE
ufunc_k0e_types[3] = <char>NPY_DOUBLE
ufunc_k0e_ptr[2*0] = <void*>_func_k0e
ufunc_k0e_ptr[2*0+1] = <void*>(<char*>"k0e")
ufunc_k0e_ptr[2*1] = <void*>_func_k0e
ufunc_k0e_ptr[2*1+1] = <void*>(<char*>"k0e")
ufunc_k0e_data[0] = &ufunc_k0e_ptr[2*0]
ufunc_k0e_data[1] = &ufunc_k0e_ptr[2*1]
k0e = np.PyUFunc_FromFuncAndData(ufunc_k0e_loops, ufunc_k0e_data, ufunc_k0e_types, 2, 1, 1, 0, "k0e", ufunc_k0e_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_k1_loops[2]
cdef void *ufunc_k1_ptr[4]
cdef void *ufunc_k1_data[2]
cdef char ufunc_k1_types[4]
cdef char *ufunc_k1_doc = (
    "k1(x, out=None)\n"
    "\n"
    "Modified Bessel function of the second kind of order 1, :math:`K_1(x)`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "K : scalar or ndarray\n"
    "    Value of the modified Bessel function K of order 1 at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kv: Modified Bessel function of the second kind of any order\n"
    "k1e: Exponentially scaled modified Bessel function K of order 1\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 2] and (2, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `k1`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function at one point:\n"
    "\n"
    ">>> from scipy.special import k1\n"
    ">>> k1(1.)\n"
    "0.6019072301972346\n"
    "\n"
    "Calculate the function at several points:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> k1(np.array([0.5, 2., 3.]))\n"
    "array([1.65644112, 0.13986588, 0.04015643])\n"
    "\n"
    "Plot the function from 0 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0., 10., 1000)\n"
    ">>> y = k1(x)\n"
    ">>> ax.plot(x, y)\n"
    ">>> plt.show()")
ufunc_k1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_k1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_k1_types[0] = <char>NPY_FLOAT
ufunc_k1_types[1] = <char>NPY_FLOAT
ufunc_k1_types[2] = <char>NPY_DOUBLE
ufunc_k1_types[3] = <char>NPY_DOUBLE
ufunc_k1_ptr[2*0] = <void*>_func_k1
ufunc_k1_ptr[2*0+1] = <void*>(<char*>"k1")
ufunc_k1_ptr[2*1] = <void*>_func_k1
ufunc_k1_ptr[2*1+1] = <void*>(<char*>"k1")
ufunc_k1_data[0] = &ufunc_k1_ptr[2*0]
ufunc_k1_data[1] = &ufunc_k1_ptr[2*1]
k1 = np.PyUFunc_FromFuncAndData(ufunc_k1_loops, ufunc_k1_data, ufunc_k1_types, 2, 1, 1, 0, "k1", ufunc_k1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_k1e_loops[2]
cdef void *ufunc_k1e_ptr[4]
cdef void *ufunc_k1e_data[2]
cdef char ufunc_k1e_types[4]
cdef char *ufunc_k1e_doc = (
    "k1e(x, out=None)\n"
    "\n"
    "Exponentially scaled modified Bessel function K of order 1\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    k1e(x) = exp(x) * k1(x)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "K : scalar or ndarray\n"
    "    Value of the exponentially scaled modified Bessel function K of order\n"
    "    1 at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kv: Modified Bessel function of the second kind of any order\n"
    "k1: Modified Bessel function of the second kind of order 1\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 2] and (2, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `k1e`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "In the following example `k1` returns 0 whereas `k1e` still returns a\n"
    "useful floating point number.\n"
    "\n"
    ">>> from scipy.special import k1, k1e\n"
    ">>> k1(1000.), k1e(1000.)\n"
    "(0., 0.03964813081296021)\n"
    "\n"
    "Calculate the function at several points by providing a NumPy array or\n"
    "list for `x`:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> k1e(np.array([0.5, 2., 3.]))\n"
    "array([2.73100971, 1.03347685, 0.80656348])\n"
    "\n"
    "Plot the function from 0 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0., 10., 1000)\n"
    ">>> y = k1e(x)\n"
    ">>> ax.plot(x, y)\n"
    ">>> plt.show()")
ufunc_k1e_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_k1e_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_k1e_types[0] = <char>NPY_FLOAT
ufunc_k1e_types[1] = <char>NPY_FLOAT
ufunc_k1e_types[2] = <char>NPY_DOUBLE
ufunc_k1e_types[3] = <char>NPY_DOUBLE
ufunc_k1e_ptr[2*0] = <void*>_func_k1e
ufunc_k1e_ptr[2*0+1] = <void*>(<char*>"k1e")
ufunc_k1e_ptr[2*1] = <void*>_func_k1e
ufunc_k1e_ptr[2*1+1] = <void*>(<char*>"k1e")
ufunc_k1e_data[0] = &ufunc_k1e_ptr[2*0]
ufunc_k1e_data[1] = &ufunc_k1e_ptr[2*1]
k1e = np.PyUFunc_FromFuncAndData(ufunc_k1e_loops, ufunc_k1e_data, ufunc_k1e_types, 2, 1, 1, 0, "k1e", ufunc_k1e_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kei_loops[2]
cdef void *ufunc_kei_ptr[4]
cdef void *ufunc_kei_data[2]
cdef char ufunc_kei_types[4]
cdef char *ufunc_kei_doc = (
    "kei(x, out=None)\n"
    "\n"
    "Kelvin function kei.\n"
    "\n"
    "Defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\mathrm{kei}(x) = \\Im[K_0(x e^{\\pi i / 4})]\n"
    "\n"
    "where :math:`K_0` is the modified Bessel function of the second\n"
    "kind (see `kv`). See [dlmf]_ for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the Kelvin function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ker : the corresponding real part\n"
    "keip : the derivative of kei\n"
    "kv : modified Bessel function of the second kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST, Digital Library of Mathematical Functions,\n"
    "    https://dlmf.nist.gov/10.61\n"
    "\n"
    "Examples\n"
    "--------\n"
    "It can be expressed using the modified Bessel function of the\n"
    "second kind.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    ">>> x = np.array([1.0, 2.0, 3.0, 4.0])\n"
    ">>> sc.kv(0, x * np.exp(np.pi * 1j / 4)).imag\n"
    "array([-0.49499464, -0.20240007, -0.05112188,  0.0021984 ])\n"
    ">>> sc.kei(x)\n"
    "array([-0.49499464, -0.20240007, -0.05112188,  0.0021984 ])")
ufunc_kei_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_kei_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_kei_types[0] = <char>NPY_FLOAT
ufunc_kei_types[1] = <char>NPY_FLOAT
ufunc_kei_types[2] = <char>NPY_DOUBLE
ufunc_kei_types[3] = <char>NPY_DOUBLE
ufunc_kei_ptr[2*0] = <void*>_func_kei_wrap
ufunc_kei_ptr[2*0+1] = <void*>(<char*>"kei")
ufunc_kei_ptr[2*1] = <void*>_func_kei_wrap
ufunc_kei_ptr[2*1+1] = <void*>(<char*>"kei")
ufunc_kei_data[0] = &ufunc_kei_ptr[2*0]
ufunc_kei_data[1] = &ufunc_kei_ptr[2*1]
kei = np.PyUFunc_FromFuncAndData(ufunc_kei_loops, ufunc_kei_data, ufunc_kei_types, 2, 1, 1, 0, "kei", ufunc_kei_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_keip_loops[2]
cdef void *ufunc_keip_ptr[4]
cdef void *ufunc_keip_data[2]
cdef char ufunc_keip_types[4]
cdef char *ufunc_keip_doc = (
    "keip(x, out=None)\n"
    "\n"
    "Derivative of the Kelvin function kei.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The values of the derivative of kei.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kei\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST, Digital Library of Mathematical Functions,\n"
    "    https://dlmf.nist.gov/10#PT5")
ufunc_keip_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_keip_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_keip_types[0] = <char>NPY_FLOAT
ufunc_keip_types[1] = <char>NPY_FLOAT
ufunc_keip_types[2] = <char>NPY_DOUBLE
ufunc_keip_types[3] = <char>NPY_DOUBLE
ufunc_keip_ptr[2*0] = <void*>_func_keip_wrap
ufunc_keip_ptr[2*0+1] = <void*>(<char*>"keip")
ufunc_keip_ptr[2*1] = <void*>_func_keip_wrap
ufunc_keip_ptr[2*1+1] = <void*>(<char*>"keip")
ufunc_keip_data[0] = &ufunc_keip_ptr[2*0]
ufunc_keip_data[1] = &ufunc_keip_ptr[2*1]
keip = np.PyUFunc_FromFuncAndData(ufunc_keip_loops, ufunc_keip_data, ufunc_keip_types, 2, 1, 1, 0, "keip", ufunc_keip_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kelvin_loops[2]
cdef void *ufunc_kelvin_ptr[4]
cdef void *ufunc_kelvin_data[2]
cdef char ufunc_kelvin_types[10]
cdef char *ufunc_kelvin_doc = (
    "kelvin(x, out=None)\n"
    "\n"
    "Kelvin functions as complex numbers\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Be, Ke, Bep, Kep : 4-tuple of scalar or ndarray\n"
    "    The tuple (Be, Ke, Bep, Kep) contains complex numbers\n"
    "    representing the real and imaginary Kelvin functions and their\n"
    "    derivatives evaluated at `x`.  For example, kelvin(x)[0].real =\n"
    "    ber x and kelvin(x)[0].imag = bei x with similar relationships\n"
    "    for ker and kei.")
ufunc_kelvin_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_DDDD_As_f_FFFF
ufunc_kelvin_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_DDDD_As_d_DDDD
ufunc_kelvin_types[0] = <char>NPY_FLOAT
ufunc_kelvin_types[1] = <char>NPY_CFLOAT
ufunc_kelvin_types[2] = <char>NPY_CFLOAT
ufunc_kelvin_types[3] = <char>NPY_CFLOAT
ufunc_kelvin_types[4] = <char>NPY_CFLOAT
ufunc_kelvin_types[5] = <char>NPY_DOUBLE
ufunc_kelvin_types[6] = <char>NPY_CDOUBLE
ufunc_kelvin_types[7] = <char>NPY_CDOUBLE
ufunc_kelvin_types[8] = <char>NPY_CDOUBLE
ufunc_kelvin_types[9] = <char>NPY_CDOUBLE
ufunc_kelvin_ptr[2*0] = <void*>_func_kelvin_wrap
ufunc_kelvin_ptr[2*0+1] = <void*>(<char*>"kelvin")
ufunc_kelvin_ptr[2*1] = <void*>_func_kelvin_wrap
ufunc_kelvin_ptr[2*1+1] = <void*>(<char*>"kelvin")
ufunc_kelvin_data[0] = &ufunc_kelvin_ptr[2*0]
ufunc_kelvin_data[1] = &ufunc_kelvin_ptr[2*1]
kelvin = np.PyUFunc_FromFuncAndData(ufunc_kelvin_loops, ufunc_kelvin_data, ufunc_kelvin_types, 2, 1, 4, 0, "kelvin", ufunc_kelvin_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ker_loops[2]
cdef void *ufunc_ker_ptr[4]
cdef void *ufunc_ker_data[2]
cdef char ufunc_ker_types[4]
cdef char *ufunc_ker_doc = (
    "ker(x, out=None)\n"
    "\n"
    "Kelvin function ker.\n"
    "\n"
    "Defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\mathrm{ker}(x) = \\Re[K_0(x e^{\\pi i / 4})]\n"
    "\n"
    "Where :math:`K_0` is the modified Bessel function of the second\n"
    "kind (see `kv`). See [dlmf]_ for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the Kelvin function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kei : the corresponding imaginary part\n"
    "kerp : the derivative of ker\n"
    "kv : modified Bessel function of the second kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST, Digital Library of Mathematical Functions,\n"
    "    https://dlmf.nist.gov/10.61\n"
    "\n"
    "Examples\n"
    "--------\n"
    "It can be expressed using the modified Bessel function of the\n"
    "second kind.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    ">>> x = np.array([1.0, 2.0, 3.0, 4.0])\n"
    ">>> sc.kv(0, x * np.exp(np.pi * 1j / 4)).real\n"
    "array([ 0.28670621, -0.04166451, -0.06702923, -0.03617885])\n"
    ">>> sc.ker(x)\n"
    "array([ 0.28670621, -0.04166451, -0.06702923, -0.03617885])")
ufunc_ker_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ker_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ker_types[0] = <char>NPY_FLOAT
ufunc_ker_types[1] = <char>NPY_FLOAT
ufunc_ker_types[2] = <char>NPY_DOUBLE
ufunc_ker_types[3] = <char>NPY_DOUBLE
ufunc_ker_ptr[2*0] = <void*>_func_ker_wrap
ufunc_ker_ptr[2*0+1] = <void*>(<char*>"ker")
ufunc_ker_ptr[2*1] = <void*>_func_ker_wrap
ufunc_ker_ptr[2*1+1] = <void*>(<char*>"ker")
ufunc_ker_data[0] = &ufunc_ker_ptr[2*0]
ufunc_ker_data[1] = &ufunc_ker_ptr[2*1]
ker = np.PyUFunc_FromFuncAndData(ufunc_ker_loops, ufunc_ker_data, ufunc_ker_types, 2, 1, 1, 0, "ker", ufunc_ker_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kerp_loops[2]
cdef void *ufunc_kerp_ptr[4]
cdef void *ufunc_kerp_data[2]
cdef char ufunc_kerp_types[4]
cdef char *ufunc_kerp_doc = (
    "kerp(x, out=None)\n"
    "\n"
    "Derivative of the Kelvin function ker.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the derivative of ker.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ker\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST, Digital Library of Mathematical Functions,\n"
    "    https://dlmf.nist.gov/10#PT5")
ufunc_kerp_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_kerp_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_kerp_types[0] = <char>NPY_FLOAT
ufunc_kerp_types[1] = <char>NPY_FLOAT
ufunc_kerp_types[2] = <char>NPY_DOUBLE
ufunc_kerp_types[3] = <char>NPY_DOUBLE
ufunc_kerp_ptr[2*0] = <void*>_func_kerp_wrap
ufunc_kerp_ptr[2*0+1] = <void*>(<char*>"kerp")
ufunc_kerp_ptr[2*1] = <void*>_func_kerp_wrap
ufunc_kerp_ptr[2*1+1] = <void*>(<char*>"kerp")
ufunc_kerp_data[0] = &ufunc_kerp_ptr[2*0]
ufunc_kerp_data[1] = &ufunc_kerp_ptr[2*1]
kerp = np.PyUFunc_FromFuncAndData(ufunc_kerp_loops, ufunc_kerp_data, ufunc_kerp_types, 2, 1, 1, 0, "kerp", ufunc_kerp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kl_div_loops[2]
cdef void *ufunc_kl_div_ptr[4]
cdef void *ufunc_kl_div_data[2]
cdef char ufunc_kl_div_types[6]
cdef char *ufunc_kl_div_doc = (
    "kl_div(x, y, out=None)\n"
    "\n"
    "Elementwise function for computing Kullback-Leibler divergence.\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\mathrm{kl\\_div}(x, y) =\n"
    "      \\begin{cases}\n"
    "        x \\log(x / y) - x + y & x > 0, y > 0 \\\\\n"
    "        y & x = 0, y \\ge 0 \\\\\n"
    "        \\infty & \\text{otherwise}\n"
    "      \\end{cases}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y : array_like\n"
    "    Real arguments\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the Kullback-Liebler divergence.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "entr, rel_entr, scipy.stats.entropy\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 0.15.0\n"
    "\n"
    "This function is non-negative and is jointly convex in `x` and `y`.\n"
    "\n"
    "The origin of this function is in convex programming; see [1]_ for\n"
    "details. This is why the function contains the extra :math:`-x\n"
    "+ y` terms over what might be expected from the Kullback-Leibler\n"
    "divergence. For a version of the function without the extra terms,\n"
    "see `rel_entr`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*.\n"
    "       Cambridge University Press, 2004.\n"
    "       :doi:`https://doi.org/10.1017/CBO9780511804441`")
ufunc_kl_div_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_kl_div_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_kl_div_types[0] = <char>NPY_FLOAT
ufunc_kl_div_types[1] = <char>NPY_FLOAT
ufunc_kl_div_types[2] = <char>NPY_FLOAT
ufunc_kl_div_types[3] = <char>NPY_DOUBLE
ufunc_kl_div_types[4] = <char>NPY_DOUBLE
ufunc_kl_div_types[5] = <char>NPY_DOUBLE
ufunc_kl_div_ptr[2*0] = <void*>_func_kl_div
ufunc_kl_div_ptr[2*0+1] = <void*>(<char*>"kl_div")
ufunc_kl_div_ptr[2*1] = <void*>_func_kl_div
ufunc_kl_div_ptr[2*1+1] = <void*>(<char*>"kl_div")
ufunc_kl_div_data[0] = &ufunc_kl_div_ptr[2*0]
ufunc_kl_div_data[1] = &ufunc_kl_div_ptr[2*1]
kl_div = np.PyUFunc_FromFuncAndData(ufunc_kl_div_loops, ufunc_kl_div_data, ufunc_kl_div_types, 2, 2, 1, 0, "kl_div", ufunc_kl_div_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kn_loops[3]
cdef void *ufunc_kn_ptr[6]
cdef void *ufunc_kn_data[3]
cdef char ufunc_kn_types[9]
cdef char *ufunc_kn_doc = (
    "kn(n, x, out=None)\n"
    "\n"
    "Modified Bessel function of the second kind of integer order `n`\n"
    "\n"
    "Returns the modified Bessel function of the second kind for integer order\n"
    "`n` at real `z`.\n"
    "\n"
    "These are also sometimes called functions of the third kind, Basset\n"
    "functions, or Macdonald functions.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like of int\n"
    "    Order of Bessel functions (floats will truncate with a warning)\n"
    "x : array_like of float\n"
    "    Argument at which to evaluate the Bessel functions\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the Modified Bessel function of the second kind,\n"
    "    :math:`K_n(x)`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kv : Same function, but accepts real order and complex argument\n"
    "kvp : Derivative of this function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for AMOS [1]_ routine `zbesk`.  For a discussion of the\n"
    "algorithm used, see [2]_ and the references therein.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    ".. [2] Donald E. Amos, \"Algorithm 644: A portable package for Bessel\n"
    "       functions of a complex argument and nonnegative order\", ACM\n"
    "       TOMS Vol. 12 Issue 3, Sept. 1986, p. 265\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Plot the function of several orders for real input:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import kn\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(0, 5, 1000)\n"
    ">>> for N in range(6):\n"
    "...     plt.plot(x, kn(N, x), label='$K_{}(x)$'.format(N))\n"
    ">>> plt.ylim(0, 10)\n"
    ">>> plt.legend()\n"
    ">>> plt.title(r'Modified Bessel function of the second kind $K_n(x)$')\n"
    ">>> plt.show()\n"
    "\n"
    "Calculate for a single value at multiple orders:\n"
    "\n"
    ">>> kn([4, 5, 6], 1)\n"
    "array([   44.23241585,   360.9605896 ,  3653.83831186])")
ufunc_kn_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_kn_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_kn_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_kn_types[0] = <char>NPY_LONG
ufunc_kn_types[1] = <char>NPY_DOUBLE
ufunc_kn_types[2] = <char>NPY_DOUBLE
ufunc_kn_types[3] = <char>NPY_FLOAT
ufunc_kn_types[4] = <char>NPY_FLOAT
ufunc_kn_types[5] = <char>NPY_FLOAT
ufunc_kn_types[6] = <char>NPY_DOUBLE
ufunc_kn_types[7] = <char>NPY_DOUBLE
ufunc_kn_types[8] = <char>NPY_DOUBLE
ufunc_kn_ptr[2*0] = <void*>_func_cbesk_wrap_real_int
ufunc_kn_ptr[2*0+1] = <void*>(<char*>"kn")
ufunc_kn_ptr[2*1] = <void*>_func_kn_unsafe
ufunc_kn_ptr[2*1+1] = <void*>(<char*>"kn")
ufunc_kn_ptr[2*2] = <void*>_func_kn_unsafe
ufunc_kn_ptr[2*2+1] = <void*>(<char*>"kn")
ufunc_kn_data[0] = &ufunc_kn_ptr[2*0]
ufunc_kn_data[1] = &ufunc_kn_ptr[2*1]
ufunc_kn_data[2] = &ufunc_kn_ptr[2*2]
kn = np.PyUFunc_FromFuncAndData(ufunc_kn_loops, ufunc_kn_data, ufunc_kn_types, 3, 2, 1, 0, "kn", ufunc_kn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kolmogi_loops[2]
cdef void *ufunc_kolmogi_ptr[4]
cdef void *ufunc_kolmogi_data[2]
cdef char ufunc_kolmogi_types[4]
cdef char *ufunc_kolmogi_doc = (
    "kolmogi(p, out=None)\n"
    "\n"
    "Inverse Survival Function of Kolmogorov distribution\n"
    "\n"
    "It is the inverse function to `kolmogorov`.\n"
    "Returns y such that ``kolmogorov(y) == p``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : float array_like\n"
    "    Probability\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The value(s) of kolmogi(p)\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kolmogorov : The Survival Function for the distribution\n"
    "scipy.stats.kstwobign : Provides the functionality as a continuous distribution\n"
    "smirnov, smirnovi : Functions for the one-sided distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "`kolmogorov` is used by `stats.kstest` in the application of the\n"
    "Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this\n"
    "function is exposed in `scpy.special`, but the recommended way to achieve\n"
    "the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n"
    "`stats.kstwobign` distribution.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import kolmogi\n"
    ">>> kolmogi([0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0])\n"
    "array([        inf,  1.22384787,  1.01918472,  0.82757356,  0.67644769,\n"
    "        0.57117327,  0.        ])")
ufunc_kolmogi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_kolmogi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_kolmogi_types[0] = <char>NPY_FLOAT
ufunc_kolmogi_types[1] = <char>NPY_FLOAT
ufunc_kolmogi_types[2] = <char>NPY_DOUBLE
ufunc_kolmogi_types[3] = <char>NPY_DOUBLE
ufunc_kolmogi_ptr[2*0] = <void*>_func_kolmogi
ufunc_kolmogi_ptr[2*0+1] = <void*>(<char*>"kolmogi")
ufunc_kolmogi_ptr[2*1] = <void*>_func_kolmogi
ufunc_kolmogi_ptr[2*1+1] = <void*>(<char*>"kolmogi")
ufunc_kolmogi_data[0] = &ufunc_kolmogi_ptr[2*0]
ufunc_kolmogi_data[1] = &ufunc_kolmogi_ptr[2*1]
kolmogi = np.PyUFunc_FromFuncAndData(ufunc_kolmogi_loops, ufunc_kolmogi_data, ufunc_kolmogi_types, 2, 1, 1, 0, "kolmogi", ufunc_kolmogi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kolmogorov_loops[2]
cdef void *ufunc_kolmogorov_ptr[4]
cdef void *ufunc_kolmogorov_data[2]
cdef char ufunc_kolmogorov_types[4]
cdef char *ufunc_kolmogorov_doc = (
    "kolmogorov(y, out=None)\n"
    "\n"
    "Complementary cumulative distribution (Survival Function) function of\n"
    "Kolmogorov distribution.\n"
    "\n"
    "Returns the complementary cumulative distribution function of\n"
    "Kolmogorov's limiting distribution (``D_n*\\sqrt(n)`` as n goes to infinity)\n"
    "of a two-sided test for equality between an empirical and a theoretical\n"
    "distribution. It is equal to the (limit as n->infinity of the)\n"
    "probability that ``sqrt(n) * max absolute deviation > y``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : float array_like\n"
    "  Absolute deviation between the Empirical CDF (ECDF) and the target CDF,\n"
    "  multiplied by sqrt(n).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The value(s) of kolmogorov(y)\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kolmogi : The Inverse Survival Function for the distribution\n"
    "scipy.stats.kstwobign : Provides the functionality as a continuous distribution\n"
    "smirnov, smirnovi : Functions for the one-sided distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "`kolmogorov` is used by `stats.kstest` in the application of the\n"
    "Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this\n"
    "function is exposed in `scpy.special`, but the recommended way to achieve\n"
    "the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n"
    "`stats.kstwobign` distribution.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Show the probability of a gap at least as big as 0, 0.5 and 1.0.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import kolmogorov\n"
    ">>> from scipy.stats import kstwobign\n"
    ">>> kolmogorov([0, 0.5, 1.0])\n"
    "array([ 1.        ,  0.96394524,  0.26999967])\n"
    "\n"
    "Compare a sample of size 1000 drawn from a Laplace(0, 1) distribution against\n"
    "the target distribution, a Normal(0, 1) distribution.\n"
    "\n"
    ">>> from scipy.stats import norm, laplace\n"
    ">>> rng = np.random.default_rng()\n"
    ">>> n = 1000\n"
    ">>> lap01 = laplace(0, 1)\n"
    ">>> x = np.sort(lap01.rvs(n, random_state=rng))\n"
    ">>> np.mean(x), np.std(x)\n"
    "(-0.05841730131499543, 1.3968109101997568)\n"
    "\n"
    "Construct the Empirical CDF and the K-S statistic Dn.\n"
    "\n"
    ">>> target = norm(0,1)  # Normal mean 0, stddev 1\n"
    ">>> cdfs = target.cdf(x)\n"
    ">>> ecdfs = np.arange(n+1, dtype=float)/n\n"
    ">>> gaps = np.column_stack([cdfs - ecdfs[:n], ecdfs[1:] - cdfs])\n"
    ">>> Dn = np.max(gaps)\n"
    ">>> Kn = np.sqrt(n) * Dn\n"
    ">>> print('Dn=%f, sqrt(n)*Dn=%f' % (Dn, Kn))\n"
    "Dn=0.043363, sqrt(n)*Dn=1.371265\n"
    ">>> print(chr(10).join(['For a sample of size n drawn from a N(0, 1) distribution:',\n"
    "...   ' the approximate Kolmogorov probability that sqrt(n)*Dn>=%f is %f' %\n"
    "...    (Kn, kolmogorov(Kn)),\n"
    "...   ' the approximate Kolmogorov probability that sqrt(n)*Dn<=%f is %f' %\n"
    "...    (Kn, kstwobign.cdf(Kn))]))\n"
    "For a sample of size n drawn from a N(0, 1) distribution:\n"
    " the approximate Kolmogorov probability that sqrt(n)*Dn>=1.371265 is 0.046533\n"
    " the approximate Kolmogorov probability that sqrt(n)*Dn<=1.371265 is 0.953467\n"
    "\n"
    "Plot the Empirical CDF against the target N(0, 1) CDF.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> plt.step(np.concatenate([[-3], x]), ecdfs, where='post', label='Empirical CDF')\n"
    ">>> x3 = np.linspace(-3, 3, 100)\n"
    ">>> plt.plot(x3, target.cdf(x3), label='CDF for N(0, 1)')\n"
    ">>> plt.ylim([0, 1]); plt.grid(True); plt.legend();\n"
    ">>> # Add vertical lines marking Dn+ and Dn-\n"
    ">>> iminus, iplus = np.argmax(gaps, axis=0)\n"
    ">>> plt.vlines([x[iminus]], ecdfs[iminus], cdfs[iminus],\n"
    "...            color='r', linestyle='dashed', lw=4)\n"
    ">>> plt.vlines([x[iplus]], cdfs[iplus], ecdfs[iplus+1],\n"
    "...            color='r', linestyle='dashed', lw=4)\n"
    ">>> plt.show()")
ufunc_kolmogorov_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_kolmogorov_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_kolmogorov_types[0] = <char>NPY_FLOAT
ufunc_kolmogorov_types[1] = <char>NPY_FLOAT
ufunc_kolmogorov_types[2] = <char>NPY_DOUBLE
ufunc_kolmogorov_types[3] = <char>NPY_DOUBLE
ufunc_kolmogorov_ptr[2*0] = <void*>_func_kolmogorov
ufunc_kolmogorov_ptr[2*0+1] = <void*>(<char*>"kolmogorov")
ufunc_kolmogorov_ptr[2*1] = <void*>_func_kolmogorov
ufunc_kolmogorov_ptr[2*1+1] = <void*>(<char*>"kolmogorov")
ufunc_kolmogorov_data[0] = &ufunc_kolmogorov_ptr[2*0]
ufunc_kolmogorov_data[1] = &ufunc_kolmogorov_ptr[2*1]
kolmogorov = np.PyUFunc_FromFuncAndData(ufunc_kolmogorov_loops, ufunc_kolmogorov_data, ufunc_kolmogorov_types, 2, 1, 1, 0, "kolmogorov", ufunc_kolmogorov_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kv_loops[4]
cdef void *ufunc_kv_ptr[8]
cdef void *ufunc_kv_data[4]
cdef char ufunc_kv_types[12]
cdef char *ufunc_kv_doc = (
    "kv(v, z, out=None)\n"
    "\n"
    "Modified Bessel function of the second kind of real order `v`\n"
    "\n"
    "Returns the modified Bessel function of the second kind for real order\n"
    "`v` at complex `z`.\n"
    "\n"
    "These are also sometimes called functions of the third kind, Basset\n"
    "functions, or Macdonald functions.  They are defined as those solutions\n"
    "of the modified Bessel equation for which,\n"
    "\n"
    ".. math::\n"
    "    K_v(x) \\sim \\sqrt{\\pi/(2x)} \\exp(-x)\n"
    "\n"
    "as :math:`x \\to \\infty` [3]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like of float\n"
    "    Order of Bessel functions\n"
    "z : array_like of complex\n"
    "    Argument at which to evaluate the Bessel functions\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The results. Note that input must be of complex type to get complex\n"
    "    output, e.g. ``kv(3, -2+0j)`` instead of ``kv(3, -2)``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kve : This function with leading exponential behavior stripped off.\n"
    "kvp : Derivative of this function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for AMOS [1]_ routine `zbesk`.  For a discussion of the\n"
    "algorithm used, see [2]_ and the references therein.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    ".. [2] Donald E. Amos, \"Algorithm 644: A portable package for Bessel\n"
    "       functions of a complex argument and nonnegative order\", ACM\n"
    "       TOMS Vol. 12 Issue 3, Sept. 1986, p. 265\n"
    ".. [3] NIST Digital Library of Mathematical Functions,\n"
    "       Eq. 10.25.E3. https://dlmf.nist.gov/10.25.E3\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Plot the function of several orders for real input:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import kv\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(0, 5, 1000)\n"
    ">>> for N in np.linspace(0, 6, 5):\n"
    "...     plt.plot(x, kv(N, x), label='$K_{{{}}}(x)$'.format(N))\n"
    ">>> plt.ylim(0, 10)\n"
    ">>> plt.legend()\n"
    ">>> plt.title(r'Modified Bessel function of the second kind $K_\\nu(x)$')\n"
    ">>> plt.show()\n"
    "\n"
    "Calculate for a single value at multiple orders:\n"
    "\n"
    ">>> kv([4, 4.5, 5], 1+2j)\n"
    "array([ 0.1992+2.3892j,  2.3493+3.6j   ,  7.2827+3.8104j])")
ufunc_kv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_kv_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_kv_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_kv_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_kv_types[0] = <char>NPY_FLOAT
ufunc_kv_types[1] = <char>NPY_FLOAT
ufunc_kv_types[2] = <char>NPY_FLOAT
ufunc_kv_types[3] = <char>NPY_FLOAT
ufunc_kv_types[4] = <char>NPY_CFLOAT
ufunc_kv_types[5] = <char>NPY_CFLOAT
ufunc_kv_types[6] = <char>NPY_DOUBLE
ufunc_kv_types[7] = <char>NPY_DOUBLE
ufunc_kv_types[8] = <char>NPY_DOUBLE
ufunc_kv_types[9] = <char>NPY_DOUBLE
ufunc_kv_types[10] = <char>NPY_CDOUBLE
ufunc_kv_types[11] = <char>NPY_CDOUBLE
ufunc_kv_ptr[2*0] = <void*>_func_cbesk_wrap_real
ufunc_kv_ptr[2*0+1] = <void*>(<char*>"kv")
ufunc_kv_ptr[2*1] = <void*>_func_cbesk_wrap
ufunc_kv_ptr[2*1+1] = <void*>(<char*>"kv")
ufunc_kv_ptr[2*2] = <void*>_func_cbesk_wrap_real
ufunc_kv_ptr[2*2+1] = <void*>(<char*>"kv")
ufunc_kv_ptr[2*3] = <void*>_func_cbesk_wrap
ufunc_kv_ptr[2*3+1] = <void*>(<char*>"kv")
ufunc_kv_data[0] = &ufunc_kv_ptr[2*0]
ufunc_kv_data[1] = &ufunc_kv_ptr[2*1]
ufunc_kv_data[2] = &ufunc_kv_ptr[2*2]
ufunc_kv_data[3] = &ufunc_kv_ptr[2*3]
kv = np.PyUFunc_FromFuncAndData(ufunc_kv_loops, ufunc_kv_data, ufunc_kv_types, 4, 2, 1, 0, "kv", ufunc_kv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kve_loops[4]
cdef void *ufunc_kve_ptr[8]
cdef void *ufunc_kve_data[4]
cdef char ufunc_kve_types[12]
cdef char *ufunc_kve_doc = (
    "kve(v, z, out=None)\n"
    "\n"
    "Exponentially scaled modified Bessel function of the second kind.\n"
    "\n"
    "Returns the exponentially scaled, modified Bessel function of the\n"
    "second kind (sometimes called the third kind) for real order `v` at\n"
    "complex `z`::\n"
    "\n"
    "    kve(v, z) = kv(v, z) * exp(z)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like of float\n"
    "    Order of Bessel functions\n"
    "z : array_like of complex\n"
    "    Argument at which to evaluate the Bessel functions\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The exponentially scaled modified Bessel function of the second kind.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kv : This function without exponential scaling.\n"
    "k0e : Faster version of this function for order 0.\n"
    "k1e : Faster version of this function for order 1.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for AMOS [1]_ routine `zbesk`.  For a discussion of the\n"
    "algorithm used, see [2]_ and the references therein.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    ".. [2] Donald E. Amos, \"Algorithm 644: A portable package for Bessel\n"
    "       functions of a complex argument and nonnegative order\", ACM\n"
    "       TOMS Vol. 12 Issue 3, Sept. 1986, p. 265\n"
    "\n"
    "Examples\n"
    "--------\n"
    "In the following example `kv` returns 0 whereas `kve` still returns\n"
    "a useful finite number.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import kv, kve\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> kv(3, 1000.), kve(3, 1000.)\n"
    "(0.0, 0.03980696128440973)\n"
    "\n"
    "Evaluate the function at one point for different orders by\n"
    "providing a list or NumPy array as argument for the `v` parameter:\n"
    "\n"
    ">>> kve([0, 1, 1.5], 1.)\n"
    "array([1.14446308, 1.63615349, 2.50662827])\n"
    "\n"
    "Evaluate the function at several points for order 0 by providing an\n"
    "array for `z`.\n"
    "\n"
    ">>> points = np.array([1., 3., 10.])\n"
    ">>> kve(0, points)\n"
    "array([1.14446308, 0.6977616 , 0.39163193])\n"
    "\n"
    "Evaluate the function at several points for different orders by\n"
    "providing arrays for both `v` for `z`. Both arrays have to be\n"
    "broadcastable to the correct shape. To calculate the orders 0, 1\n"
    "and 2 for a 1D array of points:\n"
    "\n"
    ">>> kve([[0], [1], [2]], points)\n"
    "array([[1.14446308, 0.6977616 , 0.39163193],\n"
    "       [1.63615349, 0.80656348, 0.41076657],\n"
    "       [4.41677005, 1.23547058, 0.47378525]])\n"
    "\n"
    "Plot the functions of order 0 to 3 from 0 to 5.\n"
    "\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0., 5., 1000)\n"
    ">>> for i in range(4):\n"
    "...     ax.plot(x, kve(i, x), label=f'$K_{i!r}(z)\\cdot e^z$')\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(r\"$z$\")\n"
    ">>> ax.set_ylim(0, 4)\n"
    ">>> ax.set_xlim(0, 5)\n"
    ">>> plt.show()")
ufunc_kve_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_kve_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_kve_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_kve_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_kve_types[0] = <char>NPY_FLOAT
ufunc_kve_types[1] = <char>NPY_FLOAT
ufunc_kve_types[2] = <char>NPY_FLOAT
ufunc_kve_types[3] = <char>NPY_FLOAT
ufunc_kve_types[4] = <char>NPY_CFLOAT
ufunc_kve_types[5] = <char>NPY_CFLOAT
ufunc_kve_types[6] = <char>NPY_DOUBLE
ufunc_kve_types[7] = <char>NPY_DOUBLE
ufunc_kve_types[8] = <char>NPY_DOUBLE
ufunc_kve_types[9] = <char>NPY_DOUBLE
ufunc_kve_types[10] = <char>NPY_CDOUBLE
ufunc_kve_types[11] = <char>NPY_CDOUBLE
ufunc_kve_ptr[2*0] = <void*>_func_cbesk_wrap_e_real
ufunc_kve_ptr[2*0+1] = <void*>(<char*>"kve")
ufunc_kve_ptr[2*1] = <void*>_func_cbesk_wrap_e
ufunc_kve_ptr[2*1+1] = <void*>(<char*>"kve")
ufunc_kve_ptr[2*2] = <void*>_func_cbesk_wrap_e_real
ufunc_kve_ptr[2*2+1] = <void*>(<char*>"kve")
ufunc_kve_ptr[2*3] = <void*>_func_cbesk_wrap_e
ufunc_kve_ptr[2*3+1] = <void*>(<char*>"kve")
ufunc_kve_data[0] = &ufunc_kve_ptr[2*0]
ufunc_kve_data[1] = &ufunc_kve_ptr[2*1]
ufunc_kve_data[2] = &ufunc_kve_ptr[2*2]
ufunc_kve_data[3] = &ufunc_kve_ptr[2*3]
kve = np.PyUFunc_FromFuncAndData(ufunc_kve_loops, ufunc_kve_data, ufunc_kve_types, 4, 2, 1, 0, "kve", ufunc_kve_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_log1p_loops[4]
cdef void *ufunc_log1p_ptr[8]
cdef void *ufunc_log1p_data[4]
cdef char ufunc_log1p_types[8]
cdef char *ufunc_log1p_doc = (
    "log1p(x, out=None)\n"
    "\n"
    "Calculates log(1 + x) for use when `x` is near zero.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real or complex valued input.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of ``log(1 + x)``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "expm1, cosm1\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is more accurate than using ``log(1 + x)`` directly for ``x``\n"
    "near 0. Note that in the below example ``1 + 1e-17 == 1`` to\n"
    "double precision.\n"
    "\n"
    ">>> sc.log1p(1e-17)\n"
    "1e-17\n"
    ">>> np.log(1 + 1e-17)\n"
    "0.0")
ufunc_log1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_log1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_log1p_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_log1p_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_log1p_types[0] = <char>NPY_FLOAT
ufunc_log1p_types[1] = <char>NPY_FLOAT
ufunc_log1p_types[2] = <char>NPY_DOUBLE
ufunc_log1p_types[3] = <char>NPY_DOUBLE
ufunc_log1p_types[4] = <char>NPY_CFLOAT
ufunc_log1p_types[5] = <char>NPY_CFLOAT
ufunc_log1p_types[6] = <char>NPY_CDOUBLE
ufunc_log1p_types[7] = <char>NPY_CDOUBLE
ufunc_log1p_ptr[2*0] = <void*>_func_log1p
ufunc_log1p_ptr[2*0+1] = <void*>(<char*>"log1p")
ufunc_log1p_ptr[2*1] = <void*>_func_log1p
ufunc_log1p_ptr[2*1+1] = <void*>(<char*>"log1p")
ufunc_log1p_ptr[2*2] = <void*>_func_clog1p
ufunc_log1p_ptr[2*2+1] = <void*>(<char*>"log1p")
ufunc_log1p_ptr[2*3] = <void*>_func_clog1p
ufunc_log1p_ptr[2*3+1] = <void*>(<char*>"log1p")
ufunc_log1p_data[0] = &ufunc_log1p_ptr[2*0]
ufunc_log1p_data[1] = &ufunc_log1p_ptr[2*1]
ufunc_log1p_data[2] = &ufunc_log1p_ptr[2*2]
ufunc_log1p_data[3] = &ufunc_log1p_ptr[2*3]
log1p = np.PyUFunc_FromFuncAndData(ufunc_log1p_loops, ufunc_log1p_data, ufunc_log1p_types, 4, 1, 1, 0, "log1p", ufunc_log1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_log_expit_loops[3]
cdef void *ufunc_log_expit_ptr[6]
cdef void *ufunc_log_expit_data[3]
cdef char ufunc_log_expit_types[6]
cdef char *ufunc_log_expit_doc = (
    "log_expit(x, out=None)\n"
    "\n"
    "Logarithm of the logistic sigmoid function.\n"
    "\n"
    "The SciPy implementation of the logistic sigmoid function is\n"
    "`scipy.special.expit`, so this function is called ``log_expit``.\n"
    "\n"
    "The function is mathematically equivalent to ``log(expit(x))``, but\n"
    "is formulated to avoid loss of precision for inputs with large\n"
    "(positive or negative) magnitude.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    The values to apply ``log_expit`` to element-wise.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : scalar or ndarray\n"
    "    The computed values, an ndarray of the same shape as ``x``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "expit\n"
    "\n"
    "Notes\n"
    "-----\n"
    "As a ufunc, ``log_expit`` takes a number of optional keyword arguments.\n"
    "For more information see\n"
    "`ufuncs <https://docs.scipy.org/doc/numpy/reference/ufuncs.html>`_\n"
    "\n"
    ".. versionadded:: 1.8.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import log_expit, expit\n"
    "\n"
    ">>> log_expit([-3.0, 0.25, 2.5, 5.0])\n"
    "array([-3.04858735, -0.57593942, -0.07888973, -0.00671535])\n"
    "\n"
    "Large negative values:\n"
    "\n"
    ">>> log_expit([-100, -500, -1000])\n"
    "array([ -100.,  -500., -1000.])\n"
    "\n"
    "Note that ``expit(-1000)`` returns 0, so the naive implementation\n"
    "``log(expit(-1000))`` return ``-inf``.\n"
    "\n"
    "Large positive values:\n"
    "\n"
    ">>> log_expit([29, 120, 400])\n"
    "array([-2.54366565e-013, -7.66764807e-053, -1.91516960e-174])\n"
    "\n"
    "Compare that to the naive implementation:\n"
    "\n"
    ">>> np.log(expit([29, 120, 400]))\n"
    "array([-2.54463117e-13,  0.00000000e+00,  0.00000000e+00])\n"
    "\n"
    "The first value is accurate to only 3 digits, and the larger inputs\n"
    "lose all precision and return 0.")
ufunc_log_expit_loops[0] = <np.PyUFuncGenericFunction>loop_f_f__As_f_f
ufunc_log_expit_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_log_expit_loops[2] = <np.PyUFuncGenericFunction>loop_g_g__As_g_g
ufunc_log_expit_types[0] = <char>NPY_FLOAT
ufunc_log_expit_types[1] = <char>NPY_FLOAT
ufunc_log_expit_types[2] = <char>NPY_DOUBLE
ufunc_log_expit_types[3] = <char>NPY_DOUBLE
ufunc_log_expit_types[4] = <char>NPY_LONGDOUBLE
ufunc_log_expit_types[5] = <char>NPY_LONGDOUBLE
ufunc_log_expit_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_log_expitf
ufunc_log_expit_ptr[2*0+1] = <void*>(<char*>"log_expit")
ufunc_log_expit_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_log_expit
ufunc_log_expit_ptr[2*1+1] = <void*>(<char*>"log_expit")
ufunc_log_expit_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_log_expitl
ufunc_log_expit_ptr[2*2+1] = <void*>(<char*>"log_expit")
ufunc_log_expit_data[0] = &ufunc_log_expit_ptr[2*0]
ufunc_log_expit_data[1] = &ufunc_log_expit_ptr[2*1]
ufunc_log_expit_data[2] = &ufunc_log_expit_ptr[2*2]
log_expit = np.PyUFunc_FromFuncAndData(ufunc_log_expit_loops, ufunc_log_expit_data, ufunc_log_expit_types, 3, 1, 1, 0, "log_expit", ufunc_log_expit_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_log_ndtr_loops[4]
cdef void *ufunc_log_ndtr_ptr[8]
cdef void *ufunc_log_ndtr_data[4]
cdef char ufunc_log_ndtr_types[8]
cdef char *ufunc_log_ndtr_doc = (
    "log_ndtr(x, out=None)\n"
    "\n"
    "Logarithm of Gaussian cumulative distribution function.\n"
    "\n"
    "Returns the log of the area under the standard Gaussian probability\n"
    "density function, integrated from minus infinity to `x`::\n"
    "\n"
    "    log(1/sqrt(2*pi) * integral(exp(-t**2 / 2), t=-inf..x))\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like, real or complex\n"
    "    Argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The value of the log of the normal CDF evaluated at `x`\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf\n"
    "erfc\n"
    "scipy.stats.norm\n"
    "ndtr\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import log_ndtr, ndtr\n"
    "\n"
    "The benefit of ``log_ndtr(x)`` over the naive implementation\n"
    "``np.log(ndtr(x))`` is most evident with moderate to large positive\n"
    "values of ``x``:\n"
    "\n"
    ">>> x = np.array([6, 7, 9, 12, 15, 25])\n"
    ">>> log_ndtr(x)\n"
    "array([-9.86587646e-010, -1.27981254e-012, -1.12858841e-019,\n"
    "       -1.77648211e-033, -3.67096620e-051, -3.05669671e-138])\n"
    "\n"
    "The results of the naive calculation for the moderate ``x`` values\n"
    "have only 5 or 6 correct significant digits. For values of ``x``\n"
    "greater than approximately 8.3, the naive expression returns 0:\n"
    "\n"
    ">>> np.log(ndtr(x))\n"
    "array([-9.86587701e-10, -1.27986510e-12,  0.00000000e+00,\n"
    "        0.00000000e+00,  0.00000000e+00,  0.00000000e+00])")
ufunc_log_ndtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_log_ndtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_log_ndtr_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_log_ndtr_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_log_ndtr_types[0] = <char>NPY_FLOAT
ufunc_log_ndtr_types[1] = <char>NPY_FLOAT
ufunc_log_ndtr_types[2] = <char>NPY_DOUBLE
ufunc_log_ndtr_types[3] = <char>NPY_DOUBLE
ufunc_log_ndtr_types[4] = <char>NPY_CFLOAT
ufunc_log_ndtr_types[5] = <char>NPY_CFLOAT
ufunc_log_ndtr_types[6] = <char>NPY_CDOUBLE
ufunc_log_ndtr_types[7] = <char>NPY_CDOUBLE
ufunc_log_ndtr_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr
ufunc_log_ndtr_ptr[2*0+1] = <void*>(<char*>"log_ndtr")
ufunc_log_ndtr_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr
ufunc_log_ndtr_ptr[2*1+1] = <void*>(<char*>"log_ndtr")
ufunc_log_ndtr_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr_complex
ufunc_log_ndtr_ptr[2*2+1] = <void*>(<char*>"log_ndtr")
ufunc_log_ndtr_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr_complex
ufunc_log_ndtr_ptr[2*3+1] = <void*>(<char*>"log_ndtr")
ufunc_log_ndtr_data[0] = &ufunc_log_ndtr_ptr[2*0]
ufunc_log_ndtr_data[1] = &ufunc_log_ndtr_ptr[2*1]
ufunc_log_ndtr_data[2] = &ufunc_log_ndtr_ptr[2*2]
ufunc_log_ndtr_data[3] = &ufunc_log_ndtr_ptr[2*3]
log_ndtr = np.PyUFunc_FromFuncAndData(ufunc_log_ndtr_loops, ufunc_log_ndtr_data, ufunc_log_ndtr_types, 4, 1, 1, 0, "log_ndtr", ufunc_log_ndtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_loggamma_loops[4]
cdef void *ufunc_loggamma_ptr[8]
cdef void *ufunc_loggamma_data[4]
cdef char ufunc_loggamma_types[8]
cdef char *ufunc_loggamma_doc = (
    "loggamma(z, out=None)\n"
    "\n"
    "Principal branch of the logarithm of the gamma function.\n"
    "\n"
    "Defined to be :math:`\\log(\\Gamma(x))` for :math:`x > 0` and\n"
    "extended to the complex plane by analytic continuation. The\n"
    "function has a single branch cut on the negative real axis.\n"
    "\n"
    ".. versionadded:: 0.18.0\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Values in the complex plane at which to compute ``loggamma``\n"
    "out : ndarray, optional\n"
    "    Output array for computed values of ``loggamma``\n"
    "\n"
    "Returns\n"
    "-------\n"
    "loggamma : scalar or ndarray\n"
    "    Values of ``loggamma`` at z.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gammaln : logarithm of the absolute value of the gamma function\n"
    "gammasgn : sign of the gamma function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "It is not generally true that :math:`\\log\\Gamma(z) =\n"
    "\\log(\\Gamma(z))`, though the real parts of the functions do\n"
    "agree. The benefit of not defining `loggamma` as\n"
    ":math:`\\log(\\Gamma(z))` is that the latter function has a\n"
    "complicated branch cut structure whereas `loggamma` is analytic\n"
    "except for on the negative real axis.\n"
    "\n"
    "The identities\n"
    "\n"
    ".. math::\n"
    "  \\exp(\\log\\Gamma(z)) &= \\Gamma(z) \\\\\n"
    "  \\log\\Gamma(z + 1) &= \\log(z) + \\log\\Gamma(z)\n"
    "\n"
    "make `loggamma` useful for working in complex logspace.\n"
    "\n"
    "On the real line `loggamma` is related to `gammaln` via\n"
    "``exp(loggamma(x + 0j)) = gammasgn(x)*exp(gammaln(x))``, up to\n"
    "rounding error.\n"
    "\n"
    "The implementation here is based on [hare1997]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [hare1997] D.E.G. Hare,\n"
    "  *Computing the Principal Branch of log-Gamma*,\n"
    "  Journal of Algorithms, Volume 25, Issue 2, November 1997, pages 221-236.")
ufunc_loggamma_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_loggamma_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_loggamma_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_loggamma_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_loggamma_types[0] = <char>NPY_FLOAT
ufunc_loggamma_types[1] = <char>NPY_FLOAT
ufunc_loggamma_types[2] = <char>NPY_DOUBLE
ufunc_loggamma_types[3] = <char>NPY_DOUBLE
ufunc_loggamma_types[4] = <char>NPY_CFLOAT
ufunc_loggamma_types[5] = <char>NPY_CFLOAT
ufunc_loggamma_types[6] = <char>NPY_CDOUBLE
ufunc_loggamma_types[7] = <char>NPY_CDOUBLE
ufunc_loggamma_ptr[2*0] = <void*>_func_loggamma_real
ufunc_loggamma_ptr[2*0+1] = <void*>(<char*>"loggamma")
ufunc_loggamma_ptr[2*1] = <void*>_func_loggamma_real
ufunc_loggamma_ptr[2*1+1] = <void*>(<char*>"loggamma")
ufunc_loggamma_ptr[2*2] = <void*>_func_loggamma
ufunc_loggamma_ptr[2*2+1] = <void*>(<char*>"loggamma")
ufunc_loggamma_ptr[2*3] = <void*>_func_loggamma
ufunc_loggamma_ptr[2*3+1] = <void*>(<char*>"loggamma")
ufunc_loggamma_data[0] = &ufunc_loggamma_ptr[2*0]
ufunc_loggamma_data[1] = &ufunc_loggamma_ptr[2*1]
ufunc_loggamma_data[2] = &ufunc_loggamma_ptr[2*2]
ufunc_loggamma_data[3] = &ufunc_loggamma_ptr[2*3]
loggamma = np.PyUFunc_FromFuncAndData(ufunc_loggamma_loops, ufunc_loggamma_data, ufunc_loggamma_types, 4, 1, 1, 0, "loggamma", ufunc_loggamma_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_logit_loops[3]
cdef void *ufunc_logit_ptr[6]
cdef void *ufunc_logit_data[3]
cdef char ufunc_logit_types[6]
cdef char *ufunc_logit_doc = (
    "logit(x, out=None)\n"
    "\n"
    "Logit ufunc for ndarrays.\n"
    "\n"
    "The logit function is defined as logit(p) = log(p/(1-p)).\n"
    "Note that logit(0) = -inf, logit(1) = inf, and logit(p)\n"
    "for p<0 or p>1 yields nan.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : ndarray\n"
    "    The ndarray to apply logit to element-wise.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    An ndarray of the same shape as x. Its entries\n"
    "    are logit of the corresponding entry of x.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "expit\n"
    "\n"
    "Notes\n"
    "-----\n"
    "As a ufunc logit takes a number of optional\n"
    "keyword arguments. For more information\n"
    "see `ufuncs <https://docs.scipy.org/doc/numpy/reference/ufuncs.html>`_\n"
    "\n"
    ".. versionadded:: 0.10.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import logit, expit\n"
    "\n"
    ">>> logit([0, 0.25, 0.5, 0.75, 1])\n"
    "array([       -inf, -1.09861229,  0.        ,  1.09861229,         inf])\n"
    "\n"
    "`expit` is the inverse of `logit`:\n"
    "\n"
    ">>> expit(logit([0.1, 0.75, 0.999]))\n"
    "array([ 0.1  ,  0.75 ,  0.999])\n"
    "\n"
    "Plot logit(x) for x in [0, 1]:\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(0, 1, 501)\n"
    ">>> y = logit(x)\n"
    ">>> plt.plot(x, y)\n"
    ">>> plt.grid()\n"
    ">>> plt.ylim(-6, 6)\n"
    ">>> plt.xlabel('x')\n"
    ">>> plt.title('logit(x)')\n"
    ">>> plt.show()")
ufunc_logit_loops[0] = <np.PyUFuncGenericFunction>loop_f_f__As_f_f
ufunc_logit_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_logit_loops[2] = <np.PyUFuncGenericFunction>loop_g_g__As_g_g
ufunc_logit_types[0] = <char>NPY_FLOAT
ufunc_logit_types[1] = <char>NPY_FLOAT
ufunc_logit_types[2] = <char>NPY_DOUBLE
ufunc_logit_types[3] = <char>NPY_DOUBLE
ufunc_logit_types[4] = <char>NPY_LONGDOUBLE
ufunc_logit_types[5] = <char>NPY_LONGDOUBLE
ufunc_logit_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_logitf
ufunc_logit_ptr[2*0+1] = <void*>(<char*>"logit")
ufunc_logit_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_logit
ufunc_logit_ptr[2*1+1] = <void*>(<char*>"logit")
ufunc_logit_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_logitl
ufunc_logit_ptr[2*2+1] = <void*>(<char*>"logit")
ufunc_logit_data[0] = &ufunc_logit_ptr[2*0]
ufunc_logit_data[1] = &ufunc_logit_ptr[2*1]
ufunc_logit_data[2] = &ufunc_logit_ptr[2*2]
logit = np.PyUFunc_FromFuncAndData(ufunc_logit_loops, ufunc_logit_data, ufunc_logit_types, 3, 1, 1, 0, "logit", ufunc_logit_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_lpmv_loops[2]
cdef void *ufunc_lpmv_ptr[4]
cdef void *ufunc_lpmv_data[2]
cdef char ufunc_lpmv_types[8]
cdef char *ufunc_lpmv_doc = (
    "lpmv(m, v, x, out=None)\n"
    "\n"
    "Associated Legendre function of integer order and real degree.\n"
    "\n"
    "Defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_v^m = (-1)^m (1 - x^2)^{m/2} \\frac{d^m}{dx^m} P_v(x)\n"
    "\n"
    "where\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_v = \\sum_{k = 0}^\\infty \\frac{(-v)_k (v + 1)_k}{(k!)^2}\n"
    "            \\left(\\frac{1 - x}{2}\\right)^k\n"
    "\n"
    "is the Legendre function of the first kind. Here :math:`(\\cdot)_k`\n"
    "is the Pochhammer symbol; see `poch`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Order (int or float). If passed a float not equal to an\n"
    "    integer the function returns NaN.\n"
    "v : array_like\n"
    "    Degree (float).\n"
    "x : array_like\n"
    "    Argument (float). Must have ``|x| <= 1``.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "pmv : scalar or ndarray\n"
    "    Value of the associated Legendre function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "lpmn : Compute the associated Legendre function for all orders\n"
    "       ``0, ..., m`` and degrees ``0, ..., n``.\n"
    "clpmn : Compute the associated Legendre function at complex\n"
    "        arguments.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Note that this implementation includes the Condon-Shortley phase.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Zhang, Jin, \"Computation of Special Functions\", John Wiley\n"
    "       and Sons, Inc, 1996.")
ufunc_lpmv_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_lpmv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_lpmv_types[0] = <char>NPY_FLOAT
ufunc_lpmv_types[1] = <char>NPY_FLOAT
ufunc_lpmv_types[2] = <char>NPY_FLOAT
ufunc_lpmv_types[3] = <char>NPY_FLOAT
ufunc_lpmv_types[4] = <char>NPY_DOUBLE
ufunc_lpmv_types[5] = <char>NPY_DOUBLE
ufunc_lpmv_types[6] = <char>NPY_DOUBLE
ufunc_lpmv_types[7] = <char>NPY_DOUBLE
ufunc_lpmv_ptr[2*0] = <void*>_func_pmv_wrap
ufunc_lpmv_ptr[2*0+1] = <void*>(<char*>"lpmv")
ufunc_lpmv_ptr[2*1] = <void*>_func_pmv_wrap
ufunc_lpmv_ptr[2*1+1] = <void*>(<char*>"lpmv")
ufunc_lpmv_data[0] = &ufunc_lpmv_ptr[2*0]
ufunc_lpmv_data[1] = &ufunc_lpmv_ptr[2*1]
lpmv = np.PyUFunc_FromFuncAndData(ufunc_lpmv_loops, ufunc_lpmv_data, ufunc_lpmv_types, 2, 3, 1, 0, "lpmv", ufunc_lpmv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_a_loops[2]
cdef void *ufunc_mathieu_a_ptr[4]
cdef void *ufunc_mathieu_a_data[2]
cdef char ufunc_mathieu_a_types[6]
cdef char *ufunc_mathieu_a_doc = (
    "mathieu_a(m, q, out=None)\n"
    "\n"
    "Characteristic value of even Mathieu functions\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Order of the function\n"
    "q : array_like\n"
    "    Parameter of the function\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Characteristic value for the even solution, ``ce_m(z, q)``, of\n"
    "    Mathieu's equation.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "mathieu_b, mathieu_cem, mathieu_sem")
ufunc_mathieu_a_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_mathieu_a_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_mathieu_a_types[0] = <char>NPY_FLOAT
ufunc_mathieu_a_types[1] = <char>NPY_FLOAT
ufunc_mathieu_a_types[2] = <char>NPY_FLOAT
ufunc_mathieu_a_types[3] = <char>NPY_DOUBLE
ufunc_mathieu_a_types[4] = <char>NPY_DOUBLE
ufunc_mathieu_a_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_a_ptr[2*0] = <void*>_func_cem_cva_wrap
ufunc_mathieu_a_ptr[2*0+1] = <void*>(<char*>"mathieu_a")
ufunc_mathieu_a_ptr[2*1] = <void*>_func_cem_cva_wrap
ufunc_mathieu_a_ptr[2*1+1] = <void*>(<char*>"mathieu_a")
ufunc_mathieu_a_data[0] = &ufunc_mathieu_a_ptr[2*0]
ufunc_mathieu_a_data[1] = &ufunc_mathieu_a_ptr[2*1]
mathieu_a = np.PyUFunc_FromFuncAndData(ufunc_mathieu_a_loops, ufunc_mathieu_a_data, ufunc_mathieu_a_types, 2, 2, 1, 0, "mathieu_a", ufunc_mathieu_a_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_b_loops[2]
cdef void *ufunc_mathieu_b_ptr[4]
cdef void *ufunc_mathieu_b_data[2]
cdef char ufunc_mathieu_b_types[6]
cdef char *ufunc_mathieu_b_doc = (
    "mathieu_b(m, q, out=None)\n"
    "\n"
    "Characteristic value of odd Mathieu functions\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Order of the function\n"
    "q : array_like\n"
    "    Parameter of the function\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Characteristic value for the odd solution, ``se_m(z, q)``, of Mathieu's\n"
    "    equation.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "mathieu_a, mathieu_cem, mathieu_sem")
ufunc_mathieu_b_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_mathieu_b_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_mathieu_b_types[0] = <char>NPY_FLOAT
ufunc_mathieu_b_types[1] = <char>NPY_FLOAT
ufunc_mathieu_b_types[2] = <char>NPY_FLOAT
ufunc_mathieu_b_types[3] = <char>NPY_DOUBLE
ufunc_mathieu_b_types[4] = <char>NPY_DOUBLE
ufunc_mathieu_b_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_b_ptr[2*0] = <void*>_func_sem_cva_wrap
ufunc_mathieu_b_ptr[2*0+1] = <void*>(<char*>"mathieu_b")
ufunc_mathieu_b_ptr[2*1] = <void*>_func_sem_cva_wrap
ufunc_mathieu_b_ptr[2*1+1] = <void*>(<char*>"mathieu_b")
ufunc_mathieu_b_data[0] = &ufunc_mathieu_b_ptr[2*0]
ufunc_mathieu_b_data[1] = &ufunc_mathieu_b_ptr[2*1]
mathieu_b = np.PyUFunc_FromFuncAndData(ufunc_mathieu_b_loops, ufunc_mathieu_b_data, ufunc_mathieu_b_types, 2, 2, 1, 0, "mathieu_b", ufunc_mathieu_b_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_cem_loops[2]
cdef void *ufunc_mathieu_cem_ptr[4]
cdef void *ufunc_mathieu_cem_data[2]
cdef char ufunc_mathieu_cem_types[10]
cdef char *ufunc_mathieu_cem_doc = (
    "mathieu_cem(m, q, x, out=None)\n"
    "\n"
    "Even Mathieu function and its derivative\n"
    "\n"
    "Returns the even Mathieu function, ``ce_m(x, q)``, of order `m` and\n"
    "parameter `q` evaluated at `x` (given in degrees).  Also returns the\n"
    "derivative with respect to `x` of ce_m(x, q)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Order of the function\n"
    "q : array_like\n"
    "    Parameter of the function\n"
    "x : array_like\n"
    "    Argument of the function, *given in degrees, not radians*\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Value of the function\n"
    "yp : scalar or ndarray\n"
    "    Value of the derivative vs x\n"
    "\n"
    "See Also\n"
    "--------\n"
    "mathieu_a, mathieu_b, mathieu_sem")
ufunc_mathieu_cem_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_fff_ff
ufunc_mathieu_cem_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_ddd_dd
ufunc_mathieu_cem_types[0] = <char>NPY_FLOAT
ufunc_mathieu_cem_types[1] = <char>NPY_FLOAT
ufunc_mathieu_cem_types[2] = <char>NPY_FLOAT
ufunc_mathieu_cem_types[3] = <char>NPY_FLOAT
ufunc_mathieu_cem_types[4] = <char>NPY_FLOAT
ufunc_mathieu_cem_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_cem_types[6] = <char>NPY_DOUBLE
ufunc_mathieu_cem_types[7] = <char>NPY_DOUBLE
ufunc_mathieu_cem_types[8] = <char>NPY_DOUBLE
ufunc_mathieu_cem_types[9] = <char>NPY_DOUBLE
ufunc_mathieu_cem_ptr[2*0] = <void*>_func_cem_wrap
ufunc_mathieu_cem_ptr[2*0+1] = <void*>(<char*>"mathieu_cem")
ufunc_mathieu_cem_ptr[2*1] = <void*>_func_cem_wrap
ufunc_mathieu_cem_ptr[2*1+1] = <void*>(<char*>"mathieu_cem")
ufunc_mathieu_cem_data[0] = &ufunc_mathieu_cem_ptr[2*0]
ufunc_mathieu_cem_data[1] = &ufunc_mathieu_cem_ptr[2*1]
mathieu_cem = np.PyUFunc_FromFuncAndData(ufunc_mathieu_cem_loops, ufunc_mathieu_cem_data, ufunc_mathieu_cem_types, 2, 3, 2, 0, "mathieu_cem", ufunc_mathieu_cem_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_modcem1_loops[2]
cdef void *ufunc_mathieu_modcem1_ptr[4]
cdef void *ufunc_mathieu_modcem1_data[2]
cdef char ufunc_mathieu_modcem1_types[10]
cdef char *ufunc_mathieu_modcem1_doc = (
    "mathieu_modcem1(m, q, x, out=None)\n"
    "\n"
    "Even modified Mathieu function of the first kind and its derivative\n"
    "\n"
    "Evaluates the even modified Mathieu function of the first kind,\n"
    "``Mc1m(x, q)``, and its derivative at `x` for order `m` and parameter\n"
    "`q`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Order of the function\n"
    "q : array_like\n"
    "    Parameter of the function\n"
    "x : array_like\n"
    "    Argument of the function, *given in degrees, not radians*\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Value of the function\n"
    "yp : scalar or ndarray\n"
    "    Value of the derivative vs x\n"
    "\n"
    "See Also\n"
    "--------\n"
    "mathieu_modsem1")
ufunc_mathieu_modcem1_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_fff_ff
ufunc_mathieu_modcem1_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_ddd_dd
ufunc_mathieu_modcem1_types[0] = <char>NPY_FLOAT
ufunc_mathieu_modcem1_types[1] = <char>NPY_FLOAT
ufunc_mathieu_modcem1_types[2] = <char>NPY_FLOAT
ufunc_mathieu_modcem1_types[3] = <char>NPY_FLOAT
ufunc_mathieu_modcem1_types[4] = <char>NPY_FLOAT
ufunc_mathieu_modcem1_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_modcem1_types[6] = <char>NPY_DOUBLE
ufunc_mathieu_modcem1_types[7] = <char>NPY_DOUBLE
ufunc_mathieu_modcem1_types[8] = <char>NPY_DOUBLE
ufunc_mathieu_modcem1_types[9] = <char>NPY_DOUBLE
ufunc_mathieu_modcem1_ptr[2*0] = <void*>_func_mcm1_wrap
ufunc_mathieu_modcem1_ptr[2*0+1] = <void*>(<char*>"mathieu_modcem1")
ufunc_mathieu_modcem1_ptr[2*1] = <void*>_func_mcm1_wrap
ufunc_mathieu_modcem1_ptr[2*1+1] = <void*>(<char*>"mathieu_modcem1")
ufunc_mathieu_modcem1_data[0] = &ufunc_mathieu_modcem1_ptr[2*0]
ufunc_mathieu_modcem1_data[1] = &ufunc_mathieu_modcem1_ptr[2*1]
mathieu_modcem1 = np.PyUFunc_FromFuncAndData(ufunc_mathieu_modcem1_loops, ufunc_mathieu_modcem1_data, ufunc_mathieu_modcem1_types, 2, 3, 2, 0, "mathieu_modcem1", ufunc_mathieu_modcem1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_modcem2_loops[2]
cdef void *ufunc_mathieu_modcem2_ptr[4]
cdef void *ufunc_mathieu_modcem2_data[2]
cdef char ufunc_mathieu_modcem2_types[10]
cdef char *ufunc_mathieu_modcem2_doc = (
    "mathieu_modcem2(m, q, x, out=None)\n"
    "\n"
    "Even modified Mathieu function of the second kind and its derivative\n"
    "\n"
    "Evaluates the even modified Mathieu function of the second kind,\n"
    "Mc2m(x, q), and its derivative at `x` (given in degrees) for order `m`\n"
    "and parameter `q`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Order of the function\n"
    "q : array_like\n"
    "    Parameter of the function\n"
    "x : array_like\n"
    "    Argument of the function, *given in degrees, not radians*\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Value of the function\n"
    "yp : scalar or ndarray\n"
    "    Value of the derivative vs x\n"
    "\n"
    "See Also\n"
    "--------\n"
    "mathieu_modsem2")
ufunc_mathieu_modcem2_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_fff_ff
ufunc_mathieu_modcem2_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_ddd_dd
ufunc_mathieu_modcem2_types[0] = <char>NPY_FLOAT
ufunc_mathieu_modcem2_types[1] = <char>NPY_FLOAT
ufunc_mathieu_modcem2_types[2] = <char>NPY_FLOAT
ufunc_mathieu_modcem2_types[3] = <char>NPY_FLOAT
ufunc_mathieu_modcem2_types[4] = <char>NPY_FLOAT
ufunc_mathieu_modcem2_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_modcem2_types[6] = <char>NPY_DOUBLE
ufunc_mathieu_modcem2_types[7] = <char>NPY_DOUBLE
ufunc_mathieu_modcem2_types[8] = <char>NPY_DOUBLE
ufunc_mathieu_modcem2_types[9] = <char>NPY_DOUBLE
ufunc_mathieu_modcem2_ptr[2*0] = <void*>_func_mcm2_wrap
ufunc_mathieu_modcem2_ptr[2*0+1] = <void*>(<char*>"mathieu_modcem2")
ufunc_mathieu_modcem2_ptr[2*1] = <void*>_func_mcm2_wrap
ufunc_mathieu_modcem2_ptr[2*1+1] = <void*>(<char*>"mathieu_modcem2")
ufunc_mathieu_modcem2_data[0] = &ufunc_mathieu_modcem2_ptr[2*0]
ufunc_mathieu_modcem2_data[1] = &ufunc_mathieu_modcem2_ptr[2*1]
mathieu_modcem2 = np.PyUFunc_FromFuncAndData(ufunc_mathieu_modcem2_loops, ufunc_mathieu_modcem2_data, ufunc_mathieu_modcem2_types, 2, 3, 2, 0, "mathieu_modcem2", ufunc_mathieu_modcem2_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_modsem1_loops[2]
cdef void *ufunc_mathieu_modsem1_ptr[4]
cdef void *ufunc_mathieu_modsem1_data[2]
cdef char ufunc_mathieu_modsem1_types[10]
cdef char *ufunc_mathieu_modsem1_doc = (
    "mathieu_modsem1(m, q, x, out=None)\n"
    "\n"
    "Odd modified Mathieu function of the first kind and its derivative\n"
    "\n"
    "Evaluates the odd modified Mathieu function of the first kind,\n"
    "Ms1m(x, q), and its derivative at `x` (given in degrees) for order `m`\n"
    "and parameter `q`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Order of the function\n"
    "q : array_like\n"
    "    Parameter of the function\n"
    "x : array_like\n"
    "    Argument of the function, *given in degrees, not radians*\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Value of the function\n"
    "yp : scalar or ndarray\n"
    "    Value of the derivative vs x\n"
    "\n"
    "See Also\n"
    "--------\n"
    "mathieu_modcem1")
ufunc_mathieu_modsem1_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_fff_ff
ufunc_mathieu_modsem1_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_ddd_dd
ufunc_mathieu_modsem1_types[0] = <char>NPY_FLOAT
ufunc_mathieu_modsem1_types[1] = <char>NPY_FLOAT
ufunc_mathieu_modsem1_types[2] = <char>NPY_FLOAT
ufunc_mathieu_modsem1_types[3] = <char>NPY_FLOAT
ufunc_mathieu_modsem1_types[4] = <char>NPY_FLOAT
ufunc_mathieu_modsem1_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_modsem1_types[6] = <char>NPY_DOUBLE
ufunc_mathieu_modsem1_types[7] = <char>NPY_DOUBLE
ufunc_mathieu_modsem1_types[8] = <char>NPY_DOUBLE
ufunc_mathieu_modsem1_types[9] = <char>NPY_DOUBLE
ufunc_mathieu_modsem1_ptr[2*0] = <void*>_func_msm1_wrap
ufunc_mathieu_modsem1_ptr[2*0+1] = <void*>(<char*>"mathieu_modsem1")
ufunc_mathieu_modsem1_ptr[2*1] = <void*>_func_msm1_wrap
ufunc_mathieu_modsem1_ptr[2*1+1] = <void*>(<char*>"mathieu_modsem1")
ufunc_mathieu_modsem1_data[0] = &ufunc_mathieu_modsem1_ptr[2*0]
ufunc_mathieu_modsem1_data[1] = &ufunc_mathieu_modsem1_ptr[2*1]
mathieu_modsem1 = np.PyUFunc_FromFuncAndData(ufunc_mathieu_modsem1_loops, ufunc_mathieu_modsem1_data, ufunc_mathieu_modsem1_types, 2, 3, 2, 0, "mathieu_modsem1", ufunc_mathieu_modsem1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_modsem2_loops[2]
cdef void *ufunc_mathieu_modsem2_ptr[4]
cdef void *ufunc_mathieu_modsem2_data[2]
cdef char ufunc_mathieu_modsem2_types[10]
cdef char *ufunc_mathieu_modsem2_doc = (
    "mathieu_modsem2(m, q, x, out=None)\n"
    "\n"
    "Odd modified Mathieu function of the second kind and its derivative\n"
    "\n"
    "Evaluates the odd modified Mathieu function of the second kind,\n"
    "Ms2m(x, q), and its derivative at `x` (given in degrees) for order `m`\n"
    "and parameter q.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Order of the function\n"
    "q : array_like\n"
    "    Parameter of the function\n"
    "x : array_like\n"
    "    Argument of the function, *given in degrees, not radians*\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Value of the function\n"
    "yp : scalar or ndarray\n"
    "    Value of the derivative vs x\n"
    "\n"
    "See Also\n"
    "--------\n"
    "mathieu_modcem2")
ufunc_mathieu_modsem2_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_fff_ff
ufunc_mathieu_modsem2_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_ddd_dd
ufunc_mathieu_modsem2_types[0] = <char>NPY_FLOAT
ufunc_mathieu_modsem2_types[1] = <char>NPY_FLOAT
ufunc_mathieu_modsem2_types[2] = <char>NPY_FLOAT
ufunc_mathieu_modsem2_types[3] = <char>NPY_FLOAT
ufunc_mathieu_modsem2_types[4] = <char>NPY_FLOAT
ufunc_mathieu_modsem2_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_modsem2_types[6] = <char>NPY_DOUBLE
ufunc_mathieu_modsem2_types[7] = <char>NPY_DOUBLE
ufunc_mathieu_modsem2_types[8] = <char>NPY_DOUBLE
ufunc_mathieu_modsem2_types[9] = <char>NPY_DOUBLE
ufunc_mathieu_modsem2_ptr[2*0] = <void*>_func_msm2_wrap
ufunc_mathieu_modsem2_ptr[2*0+1] = <void*>(<char*>"mathieu_modsem2")
ufunc_mathieu_modsem2_ptr[2*1] = <void*>_func_msm2_wrap
ufunc_mathieu_modsem2_ptr[2*1+1] = <void*>(<char*>"mathieu_modsem2")
ufunc_mathieu_modsem2_data[0] = &ufunc_mathieu_modsem2_ptr[2*0]
ufunc_mathieu_modsem2_data[1] = &ufunc_mathieu_modsem2_ptr[2*1]
mathieu_modsem2 = np.PyUFunc_FromFuncAndData(ufunc_mathieu_modsem2_loops, ufunc_mathieu_modsem2_data, ufunc_mathieu_modsem2_types, 2, 3, 2, 0, "mathieu_modsem2", ufunc_mathieu_modsem2_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_sem_loops[2]
cdef void *ufunc_mathieu_sem_ptr[4]
cdef void *ufunc_mathieu_sem_data[2]
cdef char ufunc_mathieu_sem_types[10]
cdef char *ufunc_mathieu_sem_doc = (
    "mathieu_sem(m, q, x, out=None)\n"
    "\n"
    "Odd Mathieu function and its derivative\n"
    "\n"
    "Returns the odd Mathieu function, se_m(x, q), of order `m` and\n"
    "parameter `q` evaluated at `x` (given in degrees).  Also returns the\n"
    "derivative with respect to `x` of se_m(x, q).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Order of the function\n"
    "q : array_like\n"
    "    Parameter of the function\n"
    "x : array_like\n"
    "    Argument of the function, *given in degrees, not radians*.\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Value of the function\n"
    "yp : scalar or ndarray\n"
    "    Value of the derivative vs x\n"
    "\n"
    "See Also\n"
    "--------\n"
    "mathieu_a, mathieu_b, mathieu_cem")
ufunc_mathieu_sem_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_fff_ff
ufunc_mathieu_sem_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_ddd_dd
ufunc_mathieu_sem_types[0] = <char>NPY_FLOAT
ufunc_mathieu_sem_types[1] = <char>NPY_FLOAT
ufunc_mathieu_sem_types[2] = <char>NPY_FLOAT
ufunc_mathieu_sem_types[3] = <char>NPY_FLOAT
ufunc_mathieu_sem_types[4] = <char>NPY_FLOAT
ufunc_mathieu_sem_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_sem_types[6] = <char>NPY_DOUBLE
ufunc_mathieu_sem_types[7] = <char>NPY_DOUBLE
ufunc_mathieu_sem_types[8] = <char>NPY_DOUBLE
ufunc_mathieu_sem_types[9] = <char>NPY_DOUBLE
ufunc_mathieu_sem_ptr[2*0] = <void*>_func_sem_wrap
ufunc_mathieu_sem_ptr[2*0+1] = <void*>(<char*>"mathieu_sem")
ufunc_mathieu_sem_ptr[2*1] = <void*>_func_sem_wrap
ufunc_mathieu_sem_ptr[2*1+1] = <void*>(<char*>"mathieu_sem")
ufunc_mathieu_sem_data[0] = &ufunc_mathieu_sem_ptr[2*0]
ufunc_mathieu_sem_data[1] = &ufunc_mathieu_sem_ptr[2*1]
mathieu_sem = np.PyUFunc_FromFuncAndData(ufunc_mathieu_sem_loops, ufunc_mathieu_sem_data, ufunc_mathieu_sem_types, 2, 3, 2, 0, "mathieu_sem", ufunc_mathieu_sem_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_modfresnelm_loops[2]
cdef void *ufunc_modfresnelm_ptr[4]
cdef void *ufunc_modfresnelm_data[2]
cdef char ufunc_modfresnelm_types[6]
cdef char *ufunc_modfresnelm_doc = (
    "modfresnelm(x, out=None)\n"
    "\n"
    "Modified Fresnel negative integrals\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Function argument\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "fm : scalar or ndarray\n"
    "    Integral ``F_-(x)``: ``integral(exp(-1j*t*t), t=x..inf)``\n"
    "km : scalar or ndarray\n"
    "    Integral ``K_-(x)``: ``1/sqrt(pi)*exp(1j*(x*x+pi/4))*fp``\n"
    "\n"
    "See Also\n"
    "--------\n"
    "modfresnelp")
ufunc_modfresnelm_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_DD_As_f_FF
ufunc_modfresnelm_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_DD_As_d_DD
ufunc_modfresnelm_types[0] = <char>NPY_FLOAT
ufunc_modfresnelm_types[1] = <char>NPY_CFLOAT
ufunc_modfresnelm_types[2] = <char>NPY_CFLOAT
ufunc_modfresnelm_types[3] = <char>NPY_DOUBLE
ufunc_modfresnelm_types[4] = <char>NPY_CDOUBLE
ufunc_modfresnelm_types[5] = <char>NPY_CDOUBLE
ufunc_modfresnelm_ptr[2*0] = <void*>_func_modified_fresnel_minus_wrap
ufunc_modfresnelm_ptr[2*0+1] = <void*>(<char*>"modfresnelm")
ufunc_modfresnelm_ptr[2*1] = <void*>_func_modified_fresnel_minus_wrap
ufunc_modfresnelm_ptr[2*1+1] = <void*>(<char*>"modfresnelm")
ufunc_modfresnelm_data[0] = &ufunc_modfresnelm_ptr[2*0]
ufunc_modfresnelm_data[1] = &ufunc_modfresnelm_ptr[2*1]
modfresnelm = np.PyUFunc_FromFuncAndData(ufunc_modfresnelm_loops, ufunc_modfresnelm_data, ufunc_modfresnelm_types, 2, 1, 2, 0, "modfresnelm", ufunc_modfresnelm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_modfresnelp_loops[2]
cdef void *ufunc_modfresnelp_ptr[4]
cdef void *ufunc_modfresnelp_data[2]
cdef char ufunc_modfresnelp_types[6]
cdef char *ufunc_modfresnelp_doc = (
    "modfresnelp(x, out=None)\n"
    "\n"
    "Modified Fresnel positive integrals\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Function argument\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "fp : scalar or ndarray\n"
    "    Integral ``F_+(x)``: ``integral(exp(1j*t*t), t=x..inf)``\n"
    "kp : scalar or ndarray\n"
    "    Integral ``K_+(x)``: ``1/sqrt(pi)*exp(-1j*(x*x+pi/4))*fp``\n"
    "\n"
    "See Also\n"
    "--------\n"
    "modfresnelm")
ufunc_modfresnelp_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_DD_As_f_FF
ufunc_modfresnelp_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_DD_As_d_DD
ufunc_modfresnelp_types[0] = <char>NPY_FLOAT
ufunc_modfresnelp_types[1] = <char>NPY_CFLOAT
ufunc_modfresnelp_types[2] = <char>NPY_CFLOAT
ufunc_modfresnelp_types[3] = <char>NPY_DOUBLE
ufunc_modfresnelp_types[4] = <char>NPY_CDOUBLE
ufunc_modfresnelp_types[5] = <char>NPY_CDOUBLE
ufunc_modfresnelp_ptr[2*0] = <void*>_func_modified_fresnel_plus_wrap
ufunc_modfresnelp_ptr[2*0+1] = <void*>(<char*>"modfresnelp")
ufunc_modfresnelp_ptr[2*1] = <void*>_func_modified_fresnel_plus_wrap
ufunc_modfresnelp_ptr[2*1+1] = <void*>(<char*>"modfresnelp")
ufunc_modfresnelp_data[0] = &ufunc_modfresnelp_ptr[2*0]
ufunc_modfresnelp_data[1] = &ufunc_modfresnelp_ptr[2*1]
modfresnelp = np.PyUFunc_FromFuncAndData(ufunc_modfresnelp_loops, ufunc_modfresnelp_data, ufunc_modfresnelp_types, 2, 1, 2, 0, "modfresnelp", ufunc_modfresnelp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_modstruve_loops[2]
cdef void *ufunc_modstruve_ptr[4]
cdef void *ufunc_modstruve_data[2]
cdef char ufunc_modstruve_types[6]
cdef char *ufunc_modstruve_doc = (
    "modstruve(v, x, out=None)\n"
    "\n"
    "Modified Struve function.\n"
    "\n"
    "Return the value of the modified Struve function of order `v` at `x`.  The\n"
    "modified Struve function is defined as,\n"
    "\n"
    ".. math::\n"
    "    L_v(x) = -\\imath \\exp(-\\pi\\imath v/2) H_v(\\imath x),\n"
    "\n"
    "where :math:`H_v` is the Struve function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order of the modified Struve function (float).\n"
    "x : array_like\n"
    "    Argument of the Struve function (float; must be positive unless `v` is\n"
    "    an integer).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "L : scalar or ndarray\n"
    "    Value of the modified Struve function of order `v` at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "struve\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Three methods discussed in [1]_ are used to evaluate the function:\n"
    "\n"
    "- power series\n"
    "- expansion in Bessel functions (if :math:`|x| < |v| + 20`)\n"
    "- asymptotic large-x expansion (if :math:`x \\geq 0.7v + 12`)\n"
    "\n"
    "Rounding errors are estimated based on the largest terms in the sums, and\n"
    "the result associated with the smallest error is returned.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/11\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the modified Struve function of order 1 at 2.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import modstruve\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> modstruve(1, 2.)\n"
    "1.102759787367716\n"
    "\n"
    "Calculate the modified Struve function at 2 for orders 1, 2 and 3 by\n"
    "providing a list for the order parameter `v`.\n"
    "\n"
    ">>> modstruve([1, 2, 3], 2.)\n"
    "array([1.10275979, 0.41026079, 0.11247294])\n"
    "\n"
    "Calculate the modified Struve function of order 1 for several points\n"
    "by providing an array for `x`.\n"
    "\n"
    ">>> points = np.array([2., 5., 8.])\n"
    ">>> modstruve(1, points)\n"
    "array([  1.10275979,  23.72821578, 399.24709139])\n"
    "\n"
    "Compute the modified Struve function for several orders at several\n"
    "points by providing arrays for `v` and `z`. The arrays have to be\n"
    "broadcastable to the correct shapes.\n"
    "\n"
    ">>> orders = np.array([[1], [2], [3]])\n"
    ">>> points.shape, orders.shape\n"
    "((3,), (3, 1))\n"
    "\n"
    ">>> modstruve(orders, points)\n"
    "array([[1.10275979e+00, 2.37282158e+01, 3.99247091e+02],\n"
    "       [4.10260789e-01, 1.65535979e+01, 3.25973609e+02],\n"
    "       [1.12472937e-01, 9.42430454e+00, 2.33544042e+02]])\n"
    "\n"
    "Plot the modified Struve functions of order 0 to 3 from -5 to 5.\n"
    "\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-5., 5., 1000)\n"
    ">>> for i in range(4):\n"
    "...     ax.plot(x, modstruve(i, x), label=f'$L_{i!r}$')\n"
    ">>> ax.legend(ncol=2)\n"
    ">>> ax.set_xlim(-5, 5)\n"
    ">>> ax.set_title(r\"Modified Struve functions $L_{\\nu}$\")\n"
    ">>> plt.show()")
ufunc_modstruve_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_modstruve_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_modstruve_types[0] = <char>NPY_FLOAT
ufunc_modstruve_types[1] = <char>NPY_FLOAT
ufunc_modstruve_types[2] = <char>NPY_FLOAT
ufunc_modstruve_types[3] = <char>NPY_DOUBLE
ufunc_modstruve_types[4] = <char>NPY_DOUBLE
ufunc_modstruve_types[5] = <char>NPY_DOUBLE
ufunc_modstruve_ptr[2*0] = <void*>_func_struve_l
ufunc_modstruve_ptr[2*0+1] = <void*>(<char*>"modstruve")
ufunc_modstruve_ptr[2*1] = <void*>_func_struve_l
ufunc_modstruve_ptr[2*1+1] = <void*>(<char*>"modstruve")
ufunc_modstruve_data[0] = &ufunc_modstruve_ptr[2*0]
ufunc_modstruve_data[1] = &ufunc_modstruve_ptr[2*1]
modstruve = np.PyUFunc_FromFuncAndData(ufunc_modstruve_loops, ufunc_modstruve_data, ufunc_modstruve_types, 2, 2, 1, 0, "modstruve", ufunc_modstruve_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtr_loops[3]
cdef void *ufunc_nbdtr_ptr[6]
cdef void *ufunc_nbdtr_data[3]
cdef char ufunc_nbdtr_types[12]
cdef char *ufunc_nbdtr_doc = (
    "nbdtr(k, n, p, out=None)\n"
    "\n"
    "Negative binomial cumulative distribution function.\n"
    "\n"
    "Returns the sum of the terms 0 through `k` of the negative binomial\n"
    "distribution probability mass function,\n"
    "\n"
    ".. math::\n"
    "\n"
    "    F = \\sum_{j=0}^k {{n + j - 1}\\choose{j}} p^n (1 - p)^j.\n"
    "\n"
    "In a sequence of Bernoulli trials with individual success probabilities\n"
    "`p`, this is the probability that `k` or fewer failures precede the nth\n"
    "success.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    The maximum number of allowed failures (nonnegative int).\n"
    "n : array_like\n"
    "    The target number of successes (positive int).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "F : scalar or ndarray\n"
    "    The probability of `k` or fewer failures before `n` successes in a\n"
    "    sequence of events with individual success probability `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nbdtrc : Negative binomial survival function\n"
    "nbdtrik : Negative binomial quantile function\n"
    "scipy.stats.nbinom : Negative binomial distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "If floating point values are passed for `k` or `n`, they will be truncated\n"
    "to integers.\n"
    "\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{nbdtr}(k, n, p) = I_{p}(n, k + 1).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `nbdtr`.\n"
    "\n"
    "The negative binomial distribution is also available as\n"
    "`scipy.stats.nbinom`. Using `nbdtr` directly can improve performance\n"
    "compared to the ``cdf`` method of `scipy.stats.nbinom` (see last example).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the function for ``k=10`` and ``n=5`` at ``p=0.5``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import nbdtr\n"
    ">>> nbdtr(10, 5, 0.5)\n"
    "0.940765380859375\n"
    "\n"
    "Compute the function for ``n=10`` and ``p=0.5`` at several points by\n"
    "providing a NumPy array or list for `k`.\n"
    "\n"
    ">>> nbdtr([5, 10, 15], 10, 0.5)\n"
    "array([0.15087891, 0.58809853, 0.88523853])\n"
    "\n"
    "Plot the function for four different parameter sets.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> k = np.arange(130)\n"
    ">>> n_parameters = [20, 20, 20, 80]\n"
    ">>> p_parameters = [0.2, 0.5, 0.8, 0.5]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(p_parameters, n_parameters,\n"
    "...                            linestyles))\n"
    ">>> fig, ax = plt.subplots(figsize=(8, 8))\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     p, n, style = parameter_set\n"
    "...     nbdtr_vals = nbdtr(k, n, p)\n"
    "...     ax.plot(k, nbdtr_vals, label=rf\"$n={n},\\, p={p}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(\"$k$\")\n"
    ">>> ax.set_title(\"Negative binomial cumulative distribution function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The negative binomial distribution is also available as\n"
    "`scipy.stats.nbinom`. Using `nbdtr` directly can be much faster than\n"
    "calling the ``cdf`` method of `scipy.stats.nbinom`, especially for small\n"
    "arrays or individual values. To get the same results one must use the\n"
    "following parametrization: ``nbinom(n, p).cdf(k)=nbdtr(k, n, p)``.\n"
    "\n"
    ">>> from scipy.stats import nbinom\n"
    ">>> k, n, p = 5, 3, 0.5\n"
    ">>> nbdtr_res = nbdtr(k, n, p)  # this will often be faster than below\n"
    ">>> stats_res = nbinom(n, p).cdf(k)\n"
    ">>> stats_res, nbdtr_res  # test that results are equal\n"
    "(0.85546875, 0.85546875)\n"
    "\n"
    "`nbdtr` can evaluate different parameter sets by providing arrays with\n"
    "shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute\n"
    "the function for three different `k` at four locations `p`, resulting in\n"
    "a 3x4 array.\n"
    "\n"
    ">>> k = np.array([[5], [10], [15]])\n"
    ">>> p = np.array([0.3, 0.5, 0.7, 0.9])\n"
    ">>> k.shape, p.shape\n"
    "((3, 1), (4,))\n"
    "\n"
    ">>> nbdtr(k, 5, p)\n"
    "array([[0.15026833, 0.62304687, 0.95265101, 0.9998531 ],\n"
    "       [0.48450894, 0.94076538, 0.99932777, 0.99999999],\n"
    "       [0.76249222, 0.99409103, 0.99999445, 1.        ]])")
ufunc_nbdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_iid__As_lld_d
ufunc_nbdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtr_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtr_types[0] = <char>NPY_LONG
ufunc_nbdtr_types[1] = <char>NPY_LONG
ufunc_nbdtr_types[2] = <char>NPY_DOUBLE
ufunc_nbdtr_types[3] = <char>NPY_DOUBLE
ufunc_nbdtr_types[4] = <char>NPY_FLOAT
ufunc_nbdtr_types[5] = <char>NPY_FLOAT
ufunc_nbdtr_types[6] = <char>NPY_FLOAT
ufunc_nbdtr_types[7] = <char>NPY_FLOAT
ufunc_nbdtr_types[8] = <char>NPY_DOUBLE
ufunc_nbdtr_types[9] = <char>NPY_DOUBLE
ufunc_nbdtr_types[10] = <char>NPY_DOUBLE
ufunc_nbdtr_types[11] = <char>NPY_DOUBLE
ufunc_nbdtr_ptr[2*0] = <void*>_func_nbdtr
ufunc_nbdtr_ptr[2*0+1] = <void*>(<char*>"nbdtr")
ufunc_nbdtr_ptr[2*1] = <void*>_func_nbdtr_unsafe
ufunc_nbdtr_ptr[2*1+1] = <void*>(<char*>"nbdtr")
ufunc_nbdtr_ptr[2*2] = <void*>_func_nbdtr_unsafe
ufunc_nbdtr_ptr[2*2+1] = <void*>(<char*>"nbdtr")
ufunc_nbdtr_data[0] = &ufunc_nbdtr_ptr[2*0]
ufunc_nbdtr_data[1] = &ufunc_nbdtr_ptr[2*1]
ufunc_nbdtr_data[2] = &ufunc_nbdtr_ptr[2*2]
nbdtr = np.PyUFunc_FromFuncAndData(ufunc_nbdtr_loops, ufunc_nbdtr_data, ufunc_nbdtr_types, 3, 3, 1, 0, "nbdtr", ufunc_nbdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtrc_loops[3]
cdef void *ufunc_nbdtrc_ptr[6]
cdef void *ufunc_nbdtrc_data[3]
cdef char ufunc_nbdtrc_types[12]
cdef char *ufunc_nbdtrc_doc = (
    "nbdtrc(k, n, p, out=None)\n"
    "\n"
    "Negative binomial survival function.\n"
    "\n"
    "Returns the sum of the terms `k + 1` to infinity of the negative binomial\n"
    "distribution probability mass function,\n"
    "\n"
    ".. math::\n"
    "\n"
    "    F = \\sum_{j=k + 1}^\\infty {{n + j - 1}\\choose{j}} p^n (1 - p)^j.\n"
    "\n"
    "In a sequence of Bernoulli trials with individual success probabilities\n"
    "`p`, this is the probability that more than `k` failures precede the nth\n"
    "success.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    The maximum number of allowed failures (nonnegative int).\n"
    "n : array_like\n"
    "    The target number of successes (positive int).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "F : scalar or ndarray\n"
    "    The probability of `k + 1` or more failures before `n` successes in a\n"
    "    sequence of events with individual success probability `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nbdtr : Negative binomial cumulative distribution function\n"
    "nbdtrik : Negative binomial percentile function\n"
    "scipy.stats.nbinom : Negative binomial distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "If floating point values are passed for `k` or `n`, they will be truncated\n"
    "to integers.\n"
    "\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{nbdtrc}(k, n, p) = I_{1 - p}(k + 1, n).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `nbdtrc`.\n"
    "\n"
    "The negative binomial distribution is also available as\n"
    "`scipy.stats.nbinom`. Using `nbdtrc` directly can improve performance\n"
    "compared to the ``sf`` method of `scipy.stats.nbinom` (see last example).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the function for ``k=10`` and ``n=5`` at ``p=0.5``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import nbdtrc\n"
    ">>> nbdtrc(10, 5, 0.5)\n"
    "0.059234619140624986\n"
    "\n"
    "Compute the function for ``n=10`` and ``p=0.5`` at several points by\n"
    "providing a NumPy array or list for `k`.\n"
    "\n"
    ">>> nbdtrc([5, 10, 15], 10, 0.5)\n"
    "array([0.84912109, 0.41190147, 0.11476147])\n"
    "\n"
    "Plot the function for four different parameter sets.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> k = np.arange(130)\n"
    ">>> n_parameters = [20, 20, 20, 80]\n"
    ">>> p_parameters = [0.2, 0.5, 0.8, 0.5]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(p_parameters, n_parameters,\n"
    "...                            linestyles))\n"
    ">>> fig, ax = plt.subplots(figsize=(8, 8))\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     p, n, style = parameter_set\n"
    "...     nbdtrc_vals = nbdtrc(k, n, p)\n"
    "...     ax.plot(k, nbdtrc_vals, label=rf\"$n={n},\\, p={p}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(\"$k$\")\n"
    ">>> ax.set_title(\"Negative binomial distribution survival function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The negative binomial distribution is also available as\n"
    "`scipy.stats.nbinom`. Using `nbdtrc` directly can be much faster than\n"
    "calling the ``sf`` method of `scipy.stats.nbinom`, especially for small\n"
    "arrays or individual values. To get the same results one must use the\n"
    "following parametrization: ``nbinom(n, p).sf(k)=nbdtrc(k, n, p)``.\n"
    "\n"
    ">>> from scipy.stats import nbinom\n"
    ">>> k, n, p = 3, 5, 0.5\n"
    ">>> nbdtr_res = nbdtrc(k, n, p)  # this will often be faster than below\n"
    ">>> stats_res = nbinom(n, p).sf(k)\n"
    ">>> stats_res, nbdtr_res  # test that results are equal\n"
    "(0.6367187499999999, 0.6367187499999999)\n"
    "\n"
    "`nbdtrc` can evaluate different parameter sets by providing arrays with\n"
    "shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute\n"
    "the function for three different `k` at four locations `p`, resulting in\n"
    "a 3x4 array.\n"
    "\n"
    ">>> k = np.array([[5], [10], [15]])\n"
    ">>> p = np.array([0.3, 0.5, 0.7, 0.9])\n"
    ">>> k.shape, p.shape\n"
    "((3, 1), (4,))\n"
    "\n"
    ">>> nbdtrc(k, 5, p)\n"
    "array([[8.49731667e-01, 3.76953125e-01, 4.73489874e-02, 1.46902600e-04],\n"
    "       [5.15491059e-01, 5.92346191e-02, 6.72234070e-04, 9.29610100e-09],\n"
    "       [2.37507779e-01, 5.90896606e-03, 5.55025308e-06, 3.26346760e-13]])")
ufunc_nbdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_iid__As_lld_d
ufunc_nbdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtrc_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtrc_types[0] = <char>NPY_LONG
ufunc_nbdtrc_types[1] = <char>NPY_LONG
ufunc_nbdtrc_types[2] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[3] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[4] = <char>NPY_FLOAT
ufunc_nbdtrc_types[5] = <char>NPY_FLOAT
ufunc_nbdtrc_types[6] = <char>NPY_FLOAT
ufunc_nbdtrc_types[7] = <char>NPY_FLOAT
ufunc_nbdtrc_types[8] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[9] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[10] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[11] = <char>NPY_DOUBLE
ufunc_nbdtrc_ptr[2*0] = <void*>_func_nbdtrc
ufunc_nbdtrc_ptr[2*0+1] = <void*>(<char*>"nbdtrc")
ufunc_nbdtrc_ptr[2*1] = <void*>_func_nbdtrc_unsafe
ufunc_nbdtrc_ptr[2*1+1] = <void*>(<char*>"nbdtrc")
ufunc_nbdtrc_ptr[2*2] = <void*>_func_nbdtrc_unsafe
ufunc_nbdtrc_ptr[2*2+1] = <void*>(<char*>"nbdtrc")
ufunc_nbdtrc_data[0] = &ufunc_nbdtrc_ptr[2*0]
ufunc_nbdtrc_data[1] = &ufunc_nbdtrc_ptr[2*1]
ufunc_nbdtrc_data[2] = &ufunc_nbdtrc_ptr[2*2]
nbdtrc = np.PyUFunc_FromFuncAndData(ufunc_nbdtrc_loops, ufunc_nbdtrc_data, ufunc_nbdtrc_types, 3, 3, 1, 0, "nbdtrc", ufunc_nbdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtri_loops[3]
cdef void *ufunc_nbdtri_ptr[6]
cdef void *ufunc_nbdtri_data[3]
cdef char ufunc_nbdtri_types[12]
cdef char *ufunc_nbdtri_doc = (
    "nbdtri(k, n, y, out=None)\n"
    "\n"
    "Returns the inverse with respect to the parameter `p` of\n"
    "`y = nbdtr(k, n, p)`, the negative binomial cumulative distribution\n"
    "function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    The maximum number of allowed failures (nonnegative int).\n"
    "n : array_like\n"
    "    The target number of successes (positive int).\n"
    "y : array_like\n"
    "    The probability of `k` or fewer failures before `n` successes (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "p : scalar or ndarray\n"
    "    Probability of success in a single event (float) such that\n"
    "    `nbdtr(k, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nbdtr : Cumulative distribution function of the negative binomial.\n"
    "nbdtrc : Negative binomial survival function.\n"
    "scipy.stats.nbinom : negative binomial distribution.\n"
    "nbdtrik : Inverse with respect to `k` of `nbdtr(k, n, p)`.\n"
    "nbdtrin : Inverse with respect to `n` of `nbdtr(k, n, p)`.\n"
    "scipy.stats.nbinom : Negative binomial distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `nbdtri`.\n"
    "\n"
    "The negative binomial distribution is also available as\n"
    "`scipy.stats.nbinom`. Using `nbdtri` directly can improve performance\n"
    "compared to the ``ppf`` method of `scipy.stats.nbinom`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "`nbdtri` is the inverse of `nbdtr` with respect to `p`.\n"
    "Up to floating point errors the following holds:\n"
    "``nbdtri(k, n, nbdtr(k, n, p))=p``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import nbdtri, nbdtr\n"
    ">>> k, n, y = 5, 10, 0.2\n"
    ">>> cdf_val = nbdtr(k, n, y)\n"
    ">>> nbdtri(k, n, cdf_val)\n"
    "0.20000000000000004\n"
    "\n"
    "Compute the function for ``k=10`` and ``n=5`` at several points by\n"
    "providing a NumPy array or list for `y`.\n"
    "\n"
    ">>> y = np.array([0.1, 0.4, 0.8])\n"
    ">>> nbdtri(3, 5, y)\n"
    "array([0.34462319, 0.51653095, 0.69677416])\n"
    "\n"
    "Plot the function for three different parameter sets.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> n_parameters = [5, 20, 30, 30]\n"
    ">>> k_parameters = [20, 20, 60, 80]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(n_parameters, k_parameters, linestyles))\n"
    ">>> cdf_vals = np.linspace(0, 1, 1000)\n"
    ">>> fig, ax = plt.subplots(figsize=(8, 8))\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     n, k, style = parameter_set\n"
    "...     nbdtri_vals = nbdtri(k, n, cdf_vals)\n"
    "...     ax.plot(cdf_vals, nbdtri_vals, label=rf\"$k={k},\\ n={n}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_ylabel(\"$p$\")\n"
    ">>> ax.set_xlabel(\"$CDF$\")\n"
    ">>> title = \"nbdtri: inverse of negative binomial CDF with respect to $p$\"\n"
    ">>> ax.set_title(title)\n"
    ">>> plt.show()\n"
    "\n"
    "`nbdtri` can evaluate different parameter sets by providing arrays with\n"
    "shapes compatible for broadcasting for `k`, `n` and `p`. Here we compute\n"
    "the function for three different `k` at four locations `p`, resulting in\n"
    "a 3x4 array.\n"
    "\n"
    ">>> k = np.array([[5], [10], [15]])\n"
    ">>> y = np.array([0.3, 0.5, 0.7, 0.9])\n"
    ">>> k.shape, y.shape\n"
    "((3, 1), (4,))\n"
    "\n"
    ">>> nbdtri(k, 5, y)\n"
    "array([[0.37258157, 0.45169416, 0.53249956, 0.64578407],\n"
    "       [0.24588501, 0.30451981, 0.36778453, 0.46397088],\n"
    "       [0.18362101, 0.22966758, 0.28054743, 0.36066188]])")
ufunc_nbdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_iid__As_lld_d
ufunc_nbdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtri_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtri_types[0] = <char>NPY_LONG
ufunc_nbdtri_types[1] = <char>NPY_LONG
ufunc_nbdtri_types[2] = <char>NPY_DOUBLE
ufunc_nbdtri_types[3] = <char>NPY_DOUBLE
ufunc_nbdtri_types[4] = <char>NPY_FLOAT
ufunc_nbdtri_types[5] = <char>NPY_FLOAT
ufunc_nbdtri_types[6] = <char>NPY_FLOAT
ufunc_nbdtri_types[7] = <char>NPY_FLOAT
ufunc_nbdtri_types[8] = <char>NPY_DOUBLE
ufunc_nbdtri_types[9] = <char>NPY_DOUBLE
ufunc_nbdtri_types[10] = <char>NPY_DOUBLE
ufunc_nbdtri_types[11] = <char>NPY_DOUBLE
ufunc_nbdtri_ptr[2*0] = <void*>_func_nbdtri
ufunc_nbdtri_ptr[2*0+1] = <void*>(<char*>"nbdtri")
ufunc_nbdtri_ptr[2*1] = <void*>_func_nbdtri_unsafe
ufunc_nbdtri_ptr[2*1+1] = <void*>(<char*>"nbdtri")
ufunc_nbdtri_ptr[2*2] = <void*>_func_nbdtri_unsafe
ufunc_nbdtri_ptr[2*2+1] = <void*>(<char*>"nbdtri")
ufunc_nbdtri_data[0] = &ufunc_nbdtri_ptr[2*0]
ufunc_nbdtri_data[1] = &ufunc_nbdtri_ptr[2*1]
ufunc_nbdtri_data[2] = &ufunc_nbdtri_ptr[2*2]
nbdtri = np.PyUFunc_FromFuncAndData(ufunc_nbdtri_loops, ufunc_nbdtri_data, ufunc_nbdtri_types, 3, 3, 1, 0, "nbdtri", ufunc_nbdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtrik_loops[2]
cdef void *ufunc_nbdtrik_ptr[4]
cdef void *ufunc_nbdtrik_data[2]
cdef char ufunc_nbdtrik_types[8]
cdef char *ufunc_nbdtrik_doc = (
    "nbdtrik(y, n, p, out=None)\n"
    "\n"
    "Negative binomial percentile function.\n"
    "\n"
    "Returns the inverse with respect to the parameter `k` of\n"
    "`y = nbdtr(k, n, p)`, the negative binomial cumulative distribution\n"
    "function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like\n"
    "    The probability of `k` or fewer failures before `n` successes (float).\n"
    "n : array_like\n"
    "    The target number of successes (positive int).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "k : scalar or ndarray\n"
    "    The maximum number of allowed failures such that `nbdtr(k, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nbdtr : Cumulative distribution function of the negative binomial.\n"
    "nbdtrc : Survival function of the negative binomial.\n"
    "nbdtri : Inverse with respect to `p` of `nbdtr(k, n, p)`.\n"
    "nbdtrin : Inverse with respect to `n` of `nbdtr(k, n, p)`.\n"
    "scipy.stats.nbinom : Negative binomial distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfnbn`.\n"
    "\n"
    "Formula 26.5.26 of [2]_,\n"
    "\n"
    ".. math::\n"
    "    \\sum_{j=k + 1}^\\infty {{n + j - 1}\n"
    "    \\choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n),\n"
    "\n"
    "is used to reduce calculation of the cumulative distribution function to\n"
    "that of a regularized incomplete beta :math:`I`.\n"
    "\n"
    "Computation of `k` involves a search for a value that produces the desired\n"
    "value of `y`.  The search relies on the monotonicity of `y` with `k`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the negative binomial cumulative distribution function for an\n"
    "exemplary parameter set.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import nbdtr, nbdtrik\n"
    ">>> k, n, p = 5, 2, 0.5\n"
    ">>> cdf_value = nbdtr(k, n, p)\n"
    ">>> cdf_value\n"
    "0.9375\n"
    "\n"
    "Verify that `nbdtrik` recovers the original value for `k`.\n"
    "\n"
    ">>> nbdtrik(cdf_value, n, p)\n"
    "5.0\n"
    "\n"
    "Plot the function for different parameter sets.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> p_parameters = [0.2, 0.5, 0.7, 0.5]\n"
    ">>> n_parameters = [30, 30, 30, 80]\n"
    ">>> linestyles = ['solid', 'dashed', 'dotted', 'dashdot']\n"
    ">>> parameters_list = list(zip(p_parameters, n_parameters, linestyles))\n"
    ">>> cdf_vals = np.linspace(0, 1, 1000)\n"
    ">>> fig, ax = plt.subplots(figsize=(8, 8))\n"
    ">>> for parameter_set in parameters_list:\n"
    "...     p, n, style = parameter_set\n"
    "...     nbdtrik_vals = nbdtrik(cdf_vals, n, p)\n"
    "...     ax.plot(cdf_vals, nbdtrik_vals, label=rf\"$n={n},\\ p={p}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend()\n"
    ">>> ax.set_ylabel(\"$k$\")\n"
    ">>> ax.set_xlabel(\"$CDF$\")\n"
    ">>> ax.set_title(\"Negative binomial percentile function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The negative binomial distribution is also available as\n"
    "`scipy.stats.nbinom`. The percentile function  method ``ppf``\n"
    "returns the result of `nbdtrik` rounded up to integers:\n"
    "\n"
    ">>> from scipy.stats import nbinom\n"
    ">>> q, n, p = 0.6, 5, 0.5\n"
    ">>> nbinom.ppf(q, n, p), nbdtrik(q, n, p)\n"
    "(5.0, 4.800428460273882)")
ufunc_nbdtrik_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtrik_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtrik_types[0] = <char>NPY_FLOAT
ufunc_nbdtrik_types[1] = <char>NPY_FLOAT
ufunc_nbdtrik_types[2] = <char>NPY_FLOAT
ufunc_nbdtrik_types[3] = <char>NPY_FLOAT
ufunc_nbdtrik_types[4] = <char>NPY_DOUBLE
ufunc_nbdtrik_types[5] = <char>NPY_DOUBLE
ufunc_nbdtrik_types[6] = <char>NPY_DOUBLE
ufunc_nbdtrik_types[7] = <char>NPY_DOUBLE
ufunc_nbdtrik_ptr[2*0] = <void*>_func_cdfnbn2_wrap
ufunc_nbdtrik_ptr[2*0+1] = <void*>(<char*>"nbdtrik")
ufunc_nbdtrik_ptr[2*1] = <void*>_func_cdfnbn2_wrap
ufunc_nbdtrik_ptr[2*1+1] = <void*>(<char*>"nbdtrik")
ufunc_nbdtrik_data[0] = &ufunc_nbdtrik_ptr[2*0]
ufunc_nbdtrik_data[1] = &ufunc_nbdtrik_ptr[2*1]
nbdtrik = np.PyUFunc_FromFuncAndData(ufunc_nbdtrik_loops, ufunc_nbdtrik_data, ufunc_nbdtrik_types, 2, 3, 1, 0, "nbdtrik", ufunc_nbdtrik_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtrin_loops[2]
cdef void *ufunc_nbdtrin_ptr[4]
cdef void *ufunc_nbdtrin_data[2]
cdef char ufunc_nbdtrin_types[8]
cdef char *ufunc_nbdtrin_doc = (
    "nbdtrin(k, y, p, out=None)\n"
    "\n"
    "Inverse of `nbdtr` vs `n`.\n"
    "\n"
    "Returns the inverse with respect to the parameter `n` of\n"
    "`y = nbdtr(k, n, p)`, the negative binomial cumulative distribution\n"
    "function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    The maximum number of allowed failures (nonnegative int).\n"
    "y : array_like\n"
    "    The probability of `k` or fewer failures before `n` successes (float).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "n : scalar or ndarray\n"
    "    The number of successes `n` such that `nbdtr(k, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nbdtr : Cumulative distribution function of the negative binomial.\n"
    "nbdtri : Inverse with respect to `p` of `nbdtr(k, n, p)`.\n"
    "nbdtrik : Inverse with respect to `k` of `nbdtr(k, n, p)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfnbn`.\n"
    "\n"
    "Formula 26.5.26 of [2]_,\n"
    "\n"
    ".. math::\n"
    "    \\sum_{j=k + 1}^\\infty {{n + j - 1}\n"
    "    \\choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n),\n"
    "\n"
    "is used to reduce calculation of the cumulative distribution function to\n"
    "that of a regularized incomplete beta :math:`I`.\n"
    "\n"
    "Computation of `n` involves a search for a value that produces the desired\n"
    "value of `y`.  The search relies on the monotonicity of `y` with `n`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the negative binomial cumulative distribution function for an\n"
    "exemplary parameter set.\n"
    "\n"
    ">>> from scipy.special import nbdtr, nbdtrin\n"
    ">>> k, n, p = 5, 2, 0.5\n"
    ">>> cdf_value = nbdtr(k, n, p)\n"
    ">>> cdf_value\n"
    "0.9375\n"
    "\n"
    "Verify that `nbdtrin` recovers the original value for `n` up to floating\n"
    "point accuracy.\n"
    "\n"
    ">>> nbdtrin(k, cdf_value, p)\n"
    "1.999999999998137")
ufunc_nbdtrin_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtrin_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtrin_types[0] = <char>NPY_FLOAT
ufunc_nbdtrin_types[1] = <char>NPY_FLOAT
ufunc_nbdtrin_types[2] = <char>NPY_FLOAT
ufunc_nbdtrin_types[3] = <char>NPY_FLOAT
ufunc_nbdtrin_types[4] = <char>NPY_DOUBLE
ufunc_nbdtrin_types[5] = <char>NPY_DOUBLE
ufunc_nbdtrin_types[6] = <char>NPY_DOUBLE
ufunc_nbdtrin_types[7] = <char>NPY_DOUBLE
ufunc_nbdtrin_ptr[2*0] = <void*>_func_cdfnbn3_wrap
ufunc_nbdtrin_ptr[2*0+1] = <void*>(<char*>"nbdtrin")
ufunc_nbdtrin_ptr[2*1] = <void*>_func_cdfnbn3_wrap
ufunc_nbdtrin_ptr[2*1+1] = <void*>(<char*>"nbdtrin")
ufunc_nbdtrin_data[0] = &ufunc_nbdtrin_ptr[2*0]
ufunc_nbdtrin_data[1] = &ufunc_nbdtrin_ptr[2*1]
nbdtrin = np.PyUFunc_FromFuncAndData(ufunc_nbdtrin_loops, ufunc_nbdtrin_data, ufunc_nbdtrin_types, 2, 3, 1, 0, "nbdtrin", ufunc_nbdtrin_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtr_loops[2]
cdef void *ufunc_ncfdtr_ptr[4]
cdef void *ufunc_ncfdtr_data[2]
cdef char ufunc_ncfdtr_types[10]
cdef char *ufunc_ncfdtr_doc = (
    "ncfdtr(dfn, dfd, nc, f, out=None)\n"
    "\n"
    "Cumulative distribution function of the non-central F distribution.\n"
    "\n"
    "The non-central F describes the distribution of,\n"
    "\n"
    ".. math::\n"
    "    Z = \\frac{X/d_n}{Y/d_d}\n"
    "\n"
    "where :math:`X` and :math:`Y` are independently distributed, with\n"
    ":math:`X` distributed non-central :math:`\\chi^2` with noncentrality\n"
    "parameter `nc` and :math:`d_n` degrees of freedom, and :math:`Y`\n"
    "distributed :math:`\\chi^2` with :math:`d_d` degrees of freedom.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    Degrees of freedom of the numerator sum of squares.  Range (0, inf).\n"
    "dfd : array_like\n"
    "    Degrees of freedom of the denominator sum of squares.  Range (0, inf).\n"
    "nc : array_like\n"
    "    Noncentrality parameter.  Should be in range (0, 1e4).\n"
    "f : array_like\n"
    "    Quantiles, i.e. the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "cdf : scalar or ndarray\n"
    "    The calculated CDF.  If all inputs are scalar, the return will be a\n"
    "    float.  Otherwise it will be an array.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n"
    "ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n"
    "ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n"
    "ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdffnc`.\n"
    "\n"
    "The cumulative distribution function is computed using Formula 26.6.20 of\n"
    "[2]_:\n"
    "\n"
    ".. math::\n"
    "    F(d_n, d_d, n_c, f) = \\sum_{j=0}^\\infty e^{-n_c/2}\n"
    "    \\frac{(n_c/2)^j}{j!} I_{x}(\\frac{d_n}{2} + j, \\frac{d_d}{2}),\n"
    "\n"
    "where :math:`I` is the regularized incomplete beta function, and\n"
    ":math:`x = f d_n/(f d_n + d_d)`.\n"
    "\n"
    "The computation time required for this routine is proportional to the\n"
    "noncentrality parameter `nc`.  Very large values of this parameter can\n"
    "consume immense computer resources.  This is why the search range is\n"
    "bounded by 10,000.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> from scipy import stats\n"
    ">>> import matplotlib.pyplot as plt\n"
    "\n"
    "Plot the CDF of the non-central F distribution, for nc=0.  Compare with the\n"
    "F-distribution from scipy.stats:\n"
    "\n"
    ">>> x = np.linspace(-1, 8, num=500)\n"
    ">>> dfn = 3\n"
    ">>> dfd = 2\n"
    ">>> ncf_stats = stats.f.cdf(x, dfn, dfd)\n"
    ">>> ncf_special = special.ncfdtr(dfn, dfd, 0, x)\n"
    "\n"
    ">>> fig = plt.figure()\n"
    ">>> ax = fig.add_subplot(111)\n"
    ">>> ax.plot(x, ncf_stats, 'b-', lw=3)\n"
    ">>> ax.plot(x, ncf_special, 'r-')\n"
    ">>> plt.show()")
ufunc_ncfdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_ncfdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtr_types[0] = <char>NPY_FLOAT
ufunc_ncfdtr_types[1] = <char>NPY_FLOAT
ufunc_ncfdtr_types[2] = <char>NPY_FLOAT
ufunc_ncfdtr_types[3] = <char>NPY_FLOAT
ufunc_ncfdtr_types[4] = <char>NPY_FLOAT
ufunc_ncfdtr_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtr_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtr_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtr_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtr_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtr_ptr[2*0] = <void*>_func_cdffnc1_wrap
ufunc_ncfdtr_ptr[2*0+1] = <void*>(<char*>"ncfdtr")
ufunc_ncfdtr_ptr[2*1] = <void*>_func_cdffnc1_wrap
ufunc_ncfdtr_ptr[2*1+1] = <void*>(<char*>"ncfdtr")
ufunc_ncfdtr_data[0] = &ufunc_ncfdtr_ptr[2*0]
ufunc_ncfdtr_data[1] = &ufunc_ncfdtr_ptr[2*1]
ncfdtr = np.PyUFunc_FromFuncAndData(ufunc_ncfdtr_loops, ufunc_ncfdtr_data, ufunc_ncfdtr_types, 2, 4, 1, 0, "ncfdtr", ufunc_ncfdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtri_loops[2]
cdef void *ufunc_ncfdtri_ptr[4]
cdef void *ufunc_ncfdtri_data[2]
cdef char ufunc_ncfdtri_types[10]
cdef char *ufunc_ncfdtri_doc = (
    "ncfdtri(dfn, dfd, nc, p, out=None)\n"
    "\n"
    "Inverse with respect to `f` of the CDF of the non-central F distribution.\n"
    "\n"
    "See `ncfdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    Degrees of freedom of the numerator sum of squares.  Range (0, inf).\n"
    "dfd : array_like\n"
    "    Degrees of freedom of the denominator sum of squares.  Range (0, inf).\n"
    "nc : array_like\n"
    "    Noncentrality parameter.  Should be in range (0, 1e4).\n"
    "p : array_like\n"
    "    Value of the cumulative distribution function.  Must be in the\n"
    "    range [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "f : scalar or ndarray\n"
    "    Quantiles, i.e., the upper limit of integration.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ncfdtr : CDF of the non-central F distribution.\n"
    "ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n"
    "ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n"
    "ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import ncfdtr, ncfdtri\n"
    "\n"
    "Compute the CDF for several values of `f`:\n"
    "\n"
    ">>> f = [0.5, 1, 1.5]\n"
    ">>> p = ncfdtr(2, 3, 1.5, f)\n"
    ">>> p\n"
    "array([ 0.20782291,  0.36107392,  0.47345752])\n"
    "\n"
    "Compute the inverse.  We recover the values of `f`, as expected:\n"
    "\n"
    ">>> ncfdtri(2, 3, 1.5, p)\n"
    "array([ 0.5,  1. ,  1.5])")
ufunc_ncfdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_ncfdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtri_types[0] = <char>NPY_FLOAT
ufunc_ncfdtri_types[1] = <char>NPY_FLOAT
ufunc_ncfdtri_types[2] = <char>NPY_FLOAT
ufunc_ncfdtri_types[3] = <char>NPY_FLOAT
ufunc_ncfdtri_types[4] = <char>NPY_FLOAT
ufunc_ncfdtri_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtri_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtri_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtri_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtri_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtri_ptr[2*0] = <void*>_func_cdffnc2_wrap
ufunc_ncfdtri_ptr[2*0+1] = <void*>(<char*>"ncfdtri")
ufunc_ncfdtri_ptr[2*1] = <void*>_func_cdffnc2_wrap
ufunc_ncfdtri_ptr[2*1+1] = <void*>(<char*>"ncfdtri")
ufunc_ncfdtri_data[0] = &ufunc_ncfdtri_ptr[2*0]
ufunc_ncfdtri_data[1] = &ufunc_ncfdtri_ptr[2*1]
ncfdtri = np.PyUFunc_FromFuncAndData(ufunc_ncfdtri_loops, ufunc_ncfdtri_data, ufunc_ncfdtri_types, 2, 4, 1, 0, "ncfdtri", ufunc_ncfdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtridfd_loops[2]
cdef void *ufunc_ncfdtridfd_ptr[4]
cdef void *ufunc_ncfdtridfd_data[2]
cdef char ufunc_ncfdtridfd_types[10]
cdef char *ufunc_ncfdtridfd_doc = (
    "ncfdtridfd(dfn, p, nc, f, out=None)\n"
    "\n"
    "Calculate degrees of freedom (denominator) for the noncentral F-distribution.\n"
    "\n"
    "This is the inverse with respect to `dfd` of `ncfdtr`.\n"
    "See `ncfdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    Degrees of freedom of the numerator sum of squares.  Range (0, inf).\n"
    "p : array_like\n"
    "    Value of the cumulative distribution function.  Must be in the\n"
    "    range [0, 1].\n"
    "nc : array_like\n"
    "    Noncentrality parameter.  Should be in range (0, 1e4).\n"
    "f : array_like\n"
    "    Quantiles, i.e., the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "dfd : scalar or ndarray\n"
    "    Degrees of freedom of the denominator sum of squares.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ncfdtr : CDF of the non-central F distribution.\n"
    "ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n"
    "ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n"
    "ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The value of the cumulative noncentral F distribution is not necessarily\n"
    "monotone in either degrees of freedom. There thus may be two values that\n"
    "provide a given CDF value. This routine assumes monotonicity and will\n"
    "find an arbitrary one of the two values.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import ncfdtr, ncfdtridfd\n"
    "\n"
    "Compute the CDF for several values of `dfd`:\n"
    "\n"
    ">>> dfd = [1, 2, 3]\n"
    ">>> p = ncfdtr(2, dfd, 0.25, 15)\n"
    ">>> p\n"
    "array([ 0.8097138 ,  0.93020416,  0.96787852])\n"
    "\n"
    "Compute the inverse.  We recover the values of `dfd`, as expected:\n"
    "\n"
    ">>> ncfdtridfd(2, p, 0.25, 15)\n"
    "array([ 1.,  2.,  3.])")
ufunc_ncfdtridfd_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_ncfdtridfd_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtridfd_types[0] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[1] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[2] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[3] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[4] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_ptr[2*0] = <void*>_func_cdffnc4_wrap
ufunc_ncfdtridfd_ptr[2*0+1] = <void*>(<char*>"ncfdtridfd")
ufunc_ncfdtridfd_ptr[2*1] = <void*>_func_cdffnc4_wrap
ufunc_ncfdtridfd_ptr[2*1+1] = <void*>(<char*>"ncfdtridfd")
ufunc_ncfdtridfd_data[0] = &ufunc_ncfdtridfd_ptr[2*0]
ufunc_ncfdtridfd_data[1] = &ufunc_ncfdtridfd_ptr[2*1]
ncfdtridfd = np.PyUFunc_FromFuncAndData(ufunc_ncfdtridfd_loops, ufunc_ncfdtridfd_data, ufunc_ncfdtridfd_types, 2, 4, 1, 0, "ncfdtridfd", ufunc_ncfdtridfd_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtridfn_loops[2]
cdef void *ufunc_ncfdtridfn_ptr[4]
cdef void *ufunc_ncfdtridfn_data[2]
cdef char ufunc_ncfdtridfn_types[10]
cdef char *ufunc_ncfdtridfn_doc = (
    "ncfdtridfn(p, dfd, nc, f, out=None)\n"
    "\n"
    "Calculate degrees of freedom (numerator) for the noncentral F-distribution.\n"
    "\n"
    "This is the inverse with respect to `dfn` of `ncfdtr`.\n"
    "See `ncfdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Value of the cumulative distribution function. Must be in the\n"
    "    range [0, 1].\n"
    "dfd : array_like\n"
    "    Degrees of freedom of the denominator sum of squares. Range (0, inf).\n"
    "nc : array_like\n"
    "    Noncentrality parameter.  Should be in range (0, 1e4).\n"
    "f : float\n"
    "    Quantiles, i.e., the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "dfn : scalar or ndarray\n"
    "    Degrees of freedom of the numerator sum of squares.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ncfdtr : CDF of the non-central F distribution.\n"
    "ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n"
    "ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n"
    "ncfdtrinc : Inverse of `ncfdtr` with respect to `nc`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The value of the cumulative noncentral F distribution is not necessarily\n"
    "monotone in either degrees of freedom. There thus may be two values that\n"
    "provide a given CDF value. This routine assumes monotonicity and will\n"
    "find an arbitrary one of the two values.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import ncfdtr, ncfdtridfn\n"
    "\n"
    "Compute the CDF for several values of `dfn`:\n"
    "\n"
    ">>> dfn = [1, 2, 3]\n"
    ">>> p = ncfdtr(dfn, 2, 0.25, 15)\n"
    ">>> p\n"
    "array([ 0.92562363,  0.93020416,  0.93188394])\n"
    "\n"
    "Compute the inverse. We recover the values of `dfn`, as expected:\n"
    "\n"
    ">>> ncfdtridfn(p, 2, 0.25, 15)\n"
    "array([ 1.,  2.,  3.])")
ufunc_ncfdtridfn_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_ncfdtridfn_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtridfn_types[0] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[1] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[2] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[3] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[4] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_ptr[2*0] = <void*>_func_cdffnc3_wrap
ufunc_ncfdtridfn_ptr[2*0+1] = <void*>(<char*>"ncfdtridfn")
ufunc_ncfdtridfn_ptr[2*1] = <void*>_func_cdffnc3_wrap
ufunc_ncfdtridfn_ptr[2*1+1] = <void*>(<char*>"ncfdtridfn")
ufunc_ncfdtridfn_data[0] = &ufunc_ncfdtridfn_ptr[2*0]
ufunc_ncfdtridfn_data[1] = &ufunc_ncfdtridfn_ptr[2*1]
ncfdtridfn = np.PyUFunc_FromFuncAndData(ufunc_ncfdtridfn_loops, ufunc_ncfdtridfn_data, ufunc_ncfdtridfn_types, 2, 4, 1, 0, "ncfdtridfn", ufunc_ncfdtridfn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtrinc_loops[2]
cdef void *ufunc_ncfdtrinc_ptr[4]
cdef void *ufunc_ncfdtrinc_data[2]
cdef char ufunc_ncfdtrinc_types[10]
cdef char *ufunc_ncfdtrinc_doc = (
    "ncfdtrinc(dfn, dfd, p, f, out=None)\n"
    "\n"
    "Calculate non-centrality parameter for non-central F distribution.\n"
    "\n"
    "This is the inverse with respect to `nc` of `ncfdtr`.\n"
    "See `ncfdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    Degrees of freedom of the numerator sum of squares. Range (0, inf).\n"
    "dfd : array_like\n"
    "    Degrees of freedom of the denominator sum of squares. Range (0, inf).\n"
    "p : array_like\n"
    "    Value of the cumulative distribution function. Must be in the\n"
    "    range [0, 1].\n"
    "f : array_like\n"
    "    Quantiles, i.e., the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "nc : scalar or ndarray\n"
    "    Noncentrality parameter.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ncfdtr : CDF of the non-central F distribution.\n"
    "ncfdtri : Quantile function; inverse of `ncfdtr` with respect to `f`.\n"
    "ncfdtridfd : Inverse of `ncfdtr` with respect to `dfd`.\n"
    "ncfdtridfn : Inverse of `ncfdtr` with respect to `dfn`.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import ncfdtr, ncfdtrinc\n"
    "\n"
    "Compute the CDF for several values of `nc`:\n"
    "\n"
    ">>> nc = [0.5, 1.5, 2.0]\n"
    ">>> p = ncfdtr(2, 3, nc, 15)\n"
    ">>> p\n"
    "array([ 0.96309246,  0.94327955,  0.93304098])\n"
    "\n"
    "Compute the inverse. We recover the values of `nc`, as expected:\n"
    "\n"
    ">>> ncfdtrinc(2, 3, p, 15)\n"
    "array([ 0.5,  1.5,  2. ])")
ufunc_ncfdtrinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_ncfdtrinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtrinc_types[0] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[1] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[2] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[3] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[4] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_ptr[2*0] = <void*>_func_cdffnc5_wrap
ufunc_ncfdtrinc_ptr[2*0+1] = <void*>(<char*>"ncfdtrinc")
ufunc_ncfdtrinc_ptr[2*1] = <void*>_func_cdffnc5_wrap
ufunc_ncfdtrinc_ptr[2*1+1] = <void*>(<char*>"ncfdtrinc")
ufunc_ncfdtrinc_data[0] = &ufunc_ncfdtrinc_ptr[2*0]
ufunc_ncfdtrinc_data[1] = &ufunc_ncfdtrinc_ptr[2*1]
ncfdtrinc = np.PyUFunc_FromFuncAndData(ufunc_ncfdtrinc_loops, ufunc_ncfdtrinc_data, ufunc_ncfdtrinc_types, 2, 4, 1, 0, "ncfdtrinc", ufunc_ncfdtrinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nctdtr_loops[2]
cdef void *ufunc_nctdtr_ptr[4]
cdef void *ufunc_nctdtr_data[2]
cdef char ufunc_nctdtr_types[8]
cdef char *ufunc_nctdtr_doc = (
    "nctdtr(df, nc, t, out=None)\n"
    "\n"
    "Cumulative distribution function of the non-central `t` distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "df : array_like\n"
    "    Degrees of freedom of the distribution. Should be in range (0, inf).\n"
    "nc : array_like\n"
    "    Noncentrality parameter. Should be in range (-1e6, 1e6).\n"
    "t : array_like\n"
    "    Quantiles, i.e., the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "cdf : scalar or ndarray\n"
    "    The calculated CDF. If all inputs are scalar, the return will be a\n"
    "    float. Otherwise, it will be an array.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.\n"
    "nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.\n"
    "nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> from scipy import stats\n"
    ">>> import matplotlib.pyplot as plt\n"
    "\n"
    "Plot the CDF of the non-central t distribution, for nc=0. Compare with the\n"
    "t-distribution from scipy.stats:\n"
    "\n"
    ">>> x = np.linspace(-5, 5, num=500)\n"
    ">>> df = 3\n"
    ">>> nct_stats = stats.t.cdf(x, df)\n"
    ">>> nct_special = special.nctdtr(df, 0, x)\n"
    "\n"
    ">>> fig = plt.figure()\n"
    ">>> ax = fig.add_subplot(111)\n"
    ">>> ax.plot(x, nct_stats, 'b-', lw=3)\n"
    ">>> ax.plot(x, nct_special, 'r-')\n"
    ">>> plt.show()")
ufunc_nctdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nctdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nctdtr_types[0] = <char>NPY_FLOAT
ufunc_nctdtr_types[1] = <char>NPY_FLOAT
ufunc_nctdtr_types[2] = <char>NPY_FLOAT
ufunc_nctdtr_types[3] = <char>NPY_FLOAT
ufunc_nctdtr_types[4] = <char>NPY_DOUBLE
ufunc_nctdtr_types[5] = <char>NPY_DOUBLE
ufunc_nctdtr_types[6] = <char>NPY_DOUBLE
ufunc_nctdtr_types[7] = <char>NPY_DOUBLE
ufunc_nctdtr_ptr[2*0] = <void*>_func_cdftnc1_wrap
ufunc_nctdtr_ptr[2*0+1] = <void*>(<char*>"nctdtr")
ufunc_nctdtr_ptr[2*1] = <void*>_func_cdftnc1_wrap
ufunc_nctdtr_ptr[2*1+1] = <void*>(<char*>"nctdtr")
ufunc_nctdtr_data[0] = &ufunc_nctdtr_ptr[2*0]
ufunc_nctdtr_data[1] = &ufunc_nctdtr_ptr[2*1]
nctdtr = np.PyUFunc_FromFuncAndData(ufunc_nctdtr_loops, ufunc_nctdtr_data, ufunc_nctdtr_types, 2, 3, 1, 0, "nctdtr", ufunc_nctdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nctdtridf_loops[2]
cdef void *ufunc_nctdtridf_ptr[4]
cdef void *ufunc_nctdtridf_data[2]
cdef char ufunc_nctdtridf_types[8]
cdef char *ufunc_nctdtridf_doc = (
    "nctdtridf(p, nc, t, out=None)\n"
    "\n"
    "Calculate degrees of freedom for non-central t distribution.\n"
    "\n"
    "See `nctdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].\n"
    "nc : array_like\n"
    "    Noncentrality parameter. Should be in range (-1e6, 1e6).\n"
    "t : array_like\n"
    "    Quantiles, i.e., the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "cdf : scalar or ndarray\n"
    "    The calculated CDF. If all inputs are scalar, the return will be a\n"
    "    float. Otherwise, it will be an array.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nctdtr :  CDF of the non-central `t` distribution.\n"
    "nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.\n"
    "nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.")
ufunc_nctdtridf_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nctdtridf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nctdtridf_types[0] = <char>NPY_FLOAT
ufunc_nctdtridf_types[1] = <char>NPY_FLOAT
ufunc_nctdtridf_types[2] = <char>NPY_FLOAT
ufunc_nctdtridf_types[3] = <char>NPY_FLOAT
ufunc_nctdtridf_types[4] = <char>NPY_DOUBLE
ufunc_nctdtridf_types[5] = <char>NPY_DOUBLE
ufunc_nctdtridf_types[6] = <char>NPY_DOUBLE
ufunc_nctdtridf_types[7] = <char>NPY_DOUBLE
ufunc_nctdtridf_ptr[2*0] = <void*>_func_cdftnc3_wrap
ufunc_nctdtridf_ptr[2*0+1] = <void*>(<char*>"nctdtridf")
ufunc_nctdtridf_ptr[2*1] = <void*>_func_cdftnc3_wrap
ufunc_nctdtridf_ptr[2*1+1] = <void*>(<char*>"nctdtridf")
ufunc_nctdtridf_data[0] = &ufunc_nctdtridf_ptr[2*0]
ufunc_nctdtridf_data[1] = &ufunc_nctdtridf_ptr[2*1]
nctdtridf = np.PyUFunc_FromFuncAndData(ufunc_nctdtridf_loops, ufunc_nctdtridf_data, ufunc_nctdtridf_types, 2, 3, 1, 0, "nctdtridf", ufunc_nctdtridf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nctdtrinc_loops[2]
cdef void *ufunc_nctdtrinc_ptr[4]
cdef void *ufunc_nctdtrinc_data[2]
cdef char ufunc_nctdtrinc_types[8]
cdef char *ufunc_nctdtrinc_doc = (
    "nctdtrinc(df, p, t, out=None)\n"
    "\n"
    "Calculate non-centrality parameter for non-central t distribution.\n"
    "\n"
    "See `nctdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "df : array_like\n"
    "    Degrees of freedom of the distribution. Should be in range (0, inf).\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].\n"
    "t : array_like\n"
    "    Quantiles, i.e., the upper limit of integration.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "nc : scalar or ndarray\n"
    "    Noncentrality parameter\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nctdtr :  CDF of the non-central `t` distribution.\n"
    "nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.\n"
    "nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.")
ufunc_nctdtrinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nctdtrinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nctdtrinc_types[0] = <char>NPY_FLOAT
ufunc_nctdtrinc_types[1] = <char>NPY_FLOAT
ufunc_nctdtrinc_types[2] = <char>NPY_FLOAT
ufunc_nctdtrinc_types[3] = <char>NPY_FLOAT
ufunc_nctdtrinc_types[4] = <char>NPY_DOUBLE
ufunc_nctdtrinc_types[5] = <char>NPY_DOUBLE
ufunc_nctdtrinc_types[6] = <char>NPY_DOUBLE
ufunc_nctdtrinc_types[7] = <char>NPY_DOUBLE
ufunc_nctdtrinc_ptr[2*0] = <void*>_func_cdftnc4_wrap
ufunc_nctdtrinc_ptr[2*0+1] = <void*>(<char*>"nctdtrinc")
ufunc_nctdtrinc_ptr[2*1] = <void*>_func_cdftnc4_wrap
ufunc_nctdtrinc_ptr[2*1+1] = <void*>(<char*>"nctdtrinc")
ufunc_nctdtrinc_data[0] = &ufunc_nctdtrinc_ptr[2*0]
ufunc_nctdtrinc_data[1] = &ufunc_nctdtrinc_ptr[2*1]
nctdtrinc = np.PyUFunc_FromFuncAndData(ufunc_nctdtrinc_loops, ufunc_nctdtrinc_data, ufunc_nctdtrinc_types, 2, 3, 1, 0, "nctdtrinc", ufunc_nctdtrinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nctdtrit_loops[2]
cdef void *ufunc_nctdtrit_ptr[4]
cdef void *ufunc_nctdtrit_data[2]
cdef char ufunc_nctdtrit_types[8]
cdef char *ufunc_nctdtrit_doc = (
    "nctdtrit(df, nc, p, out=None)\n"
    "\n"
    "Inverse cumulative distribution function of the non-central t distribution.\n"
    "\n"
    "See `nctdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "df : array_like\n"
    "    Degrees of freedom of the distribution. Should be in range (0, inf).\n"
    "nc : array_like\n"
    "    Noncentrality parameter. Should be in range (-1e6, 1e6).\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "t : scalar or ndarray\n"
    "    Quantiles\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nctdtr :  CDF of the non-central `t` distribution.\n"
    "nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.\n"
    "nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.")
ufunc_nctdtrit_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nctdtrit_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nctdtrit_types[0] = <char>NPY_FLOAT
ufunc_nctdtrit_types[1] = <char>NPY_FLOAT
ufunc_nctdtrit_types[2] = <char>NPY_FLOAT
ufunc_nctdtrit_types[3] = <char>NPY_FLOAT
ufunc_nctdtrit_types[4] = <char>NPY_DOUBLE
ufunc_nctdtrit_types[5] = <char>NPY_DOUBLE
ufunc_nctdtrit_types[6] = <char>NPY_DOUBLE
ufunc_nctdtrit_types[7] = <char>NPY_DOUBLE
ufunc_nctdtrit_ptr[2*0] = <void*>_func_cdftnc2_wrap
ufunc_nctdtrit_ptr[2*0+1] = <void*>(<char*>"nctdtrit")
ufunc_nctdtrit_ptr[2*1] = <void*>_func_cdftnc2_wrap
ufunc_nctdtrit_ptr[2*1+1] = <void*>(<char*>"nctdtrit")
ufunc_nctdtrit_data[0] = &ufunc_nctdtrit_ptr[2*0]
ufunc_nctdtrit_data[1] = &ufunc_nctdtrit_ptr[2*1]
nctdtrit = np.PyUFunc_FromFuncAndData(ufunc_nctdtrit_loops, ufunc_nctdtrit_data, ufunc_nctdtrit_types, 2, 3, 1, 0, "nctdtrit", ufunc_nctdtrit_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ndtr_loops[4]
cdef void *ufunc_ndtr_ptr[8]
cdef void *ufunc_ndtr_data[4]
cdef char ufunc_ndtr_types[8]
cdef char *ufunc_ndtr_doc = (
    "ndtr(x, out=None)\n"
    "\n"
    "Cumulative distribution of the standard normal distribution.\n"
    "\n"
    "Returns the area under the standard Gaussian probability\n"
    "density function, integrated from minus infinity to `x`\n"
    "\n"
    ".. math::\n"
    "\n"
    "   \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^x \\exp(-t^2/2) dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like, real or complex\n"
    "    Argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The value of the normal CDF evaluated at `x`\n"
    "\n"
    "See Also\n"
    "--------\n"
    "log_ndtr : Logarithm of ndtr\n"
    "ndtri : Inverse of ndtr, standard normal percentile function\n"
    "erf : Error function\n"
    "erfc : 1 - erf\n"
    "scipy.stats.norm : Normal distribution\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate `ndtr` at one point.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import ndtr\n"
    ">>> ndtr(0.5)\n"
    "0.6914624612740131\n"
    "\n"
    "Evaluate the function at several points by providing a NumPy array\n"
    "or list for `x`.\n"
    "\n"
    ">>> ndtr([0, 0.5, 2])\n"
    "array([0.5       , 0.69146246, 0.97724987])\n"
    "\n"
    "Plot the function.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-5, 5, 100)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(x, ndtr(x))\n"
    ">>> ax.set_title(\"Standard normal cumulative distribution function $\\Phi$\")\n"
    ">>> plt.show()")
ufunc_ndtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ndtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ndtr_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_ndtr_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_ndtr_types[0] = <char>NPY_FLOAT
ufunc_ndtr_types[1] = <char>NPY_FLOAT
ufunc_ndtr_types[2] = <char>NPY_DOUBLE
ufunc_ndtr_types[3] = <char>NPY_DOUBLE
ufunc_ndtr_types[4] = <char>NPY_CFLOAT
ufunc_ndtr_types[5] = <char>NPY_CFLOAT
ufunc_ndtr_types[6] = <char>NPY_CDOUBLE
ufunc_ndtr_types[7] = <char>NPY_CDOUBLE
ufunc_ndtr_ptr[2*0] = <void*>_func_ndtr
ufunc_ndtr_ptr[2*0+1] = <void*>(<char*>"ndtr")
ufunc_ndtr_ptr[2*1] = <void*>_func_ndtr
ufunc_ndtr_ptr[2*1+1] = <void*>(<char*>"ndtr")
ufunc_ndtr_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_ndtr
ufunc_ndtr_ptr[2*2+1] = <void*>(<char*>"ndtr")
ufunc_ndtr_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_ndtr
ufunc_ndtr_ptr[2*3+1] = <void*>(<char*>"ndtr")
ufunc_ndtr_data[0] = &ufunc_ndtr_ptr[2*0]
ufunc_ndtr_data[1] = &ufunc_ndtr_ptr[2*1]
ufunc_ndtr_data[2] = &ufunc_ndtr_ptr[2*2]
ufunc_ndtr_data[3] = &ufunc_ndtr_ptr[2*3]
ndtr = np.PyUFunc_FromFuncAndData(ufunc_ndtr_loops, ufunc_ndtr_data, ufunc_ndtr_types, 4, 1, 1, 0, "ndtr", ufunc_ndtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ndtri_loops[2]
cdef void *ufunc_ndtri_ptr[4]
cdef void *ufunc_ndtri_data[2]
cdef char ufunc_ndtri_types[4]
cdef char *ufunc_ndtri_doc = (
    "ndtri(y, out=None)\n"
    "\n"
    "Inverse of `ndtr` vs x\n"
    "\n"
    "Returns the argument x for which the area under the standard normal\n"
    "probability density function (integrated from minus infinity to `x`)\n"
    "is equal to y.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Value of x such that ``ndtr(x) == p``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ndtr : Standard normal cumulative probability distribution\n"
    "ndtri_exp : Inverse of log_ndtr\n"
    "\n"
    "Examples\n"
    "--------\n"
    "`ndtri` is the percentile function of the standard normal distribution.\n"
    "This means it returns the inverse of the cumulative density `ndtr`. First,\n"
    "let us compute a cumulative density value.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import ndtri, ndtr\n"
    ">>> cdf_val = ndtr(2)\n"
    ">>> cdf_val\n"
    "0.9772498680518208\n"
    "\n"
    "Verify that `ndtri` yields the original value for `x` up to floating point\n"
    "errors.\n"
    "\n"
    ">>> ndtri(cdf_val)\n"
    "2.0000000000000004\n"
    "\n"
    "Plot the function. For that purpose, we provide a NumPy array as argument.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(0.01, 1, 200)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(x, ndtri(x))\n"
    ">>> ax.set_title(\"Standard normal percentile function\")\n"
    ">>> plt.show()")
ufunc_ndtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ndtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ndtri_types[0] = <char>NPY_FLOAT
ufunc_ndtri_types[1] = <char>NPY_FLOAT
ufunc_ndtri_types[2] = <char>NPY_DOUBLE
ufunc_ndtri_types[3] = <char>NPY_DOUBLE
ufunc_ndtri_ptr[2*0] = <void*>_func_ndtri
ufunc_ndtri_ptr[2*0+1] = <void*>(<char*>"ndtri")
ufunc_ndtri_ptr[2*1] = <void*>_func_ndtri
ufunc_ndtri_ptr[2*1+1] = <void*>(<char*>"ndtri")
ufunc_ndtri_data[0] = &ufunc_ndtri_ptr[2*0]
ufunc_ndtri_data[1] = &ufunc_ndtri_ptr[2*1]
ndtri = np.PyUFunc_FromFuncAndData(ufunc_ndtri_loops, ufunc_ndtri_data, ufunc_ndtri_types, 2, 1, 1, 0, "ndtri", ufunc_ndtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ndtri_exp_loops[2]
cdef void *ufunc_ndtri_exp_ptr[4]
cdef void *ufunc_ndtri_exp_data[2]
cdef char ufunc_ndtri_exp_types[4]
cdef char *ufunc_ndtri_exp_doc = (
    "ndtri_exp(y, out=None)\n"
    "\n"
    "Inverse of `log_ndtr` vs x. Allows for greater precision than\n"
    "`ndtri` composed with `numpy.exp` for very small values of y and for\n"
    "y close to 0.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like of float\n"
    "    Function argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Inverse of the log CDF of the standard normal distribution, evaluated\n"
    "    at y.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "log_ndtr : log of the standard normal cumulative distribution function\n"
    "ndtr : standard normal cumulative distribution function\n"
    "ndtri : standard normal percentile function\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "`ndtri_exp` agrees with the naive implementation when the latter does\n"
    "not suffer from underflow.\n"
    "\n"
    ">>> sc.ndtri_exp(-1)\n"
    "-0.33747496376420244\n"
    ">>> sc.ndtri(np.exp(-1))\n"
    "-0.33747496376420244\n"
    "\n"
    "For extreme values of y, the naive approach fails\n"
    "\n"
    ">>> sc.ndtri(np.exp(-800))\n"
    "-inf\n"
    ">>> sc.ndtri(np.exp(-1e-20))\n"
    "inf\n"
    "\n"
    "whereas `ndtri_exp` is still able to compute the result to high precision.\n"
    "\n"
    ">>> sc.ndtri_exp(-800)\n"
    "-39.88469483825668\n"
    ">>> sc.ndtri_exp(-1e-20)\n"
    "9.262340089798409")
ufunc_ndtri_exp_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ndtri_exp_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ndtri_exp_types[0] = <char>NPY_FLOAT
ufunc_ndtri_exp_types[1] = <char>NPY_FLOAT
ufunc_ndtri_exp_types[2] = <char>NPY_DOUBLE
ufunc_ndtri_exp_types[3] = <char>NPY_DOUBLE
ufunc_ndtri_exp_ptr[2*0] = <void*>_func_ndtri_exp
ufunc_ndtri_exp_ptr[2*0+1] = <void*>(<char*>"ndtri_exp")
ufunc_ndtri_exp_ptr[2*1] = <void*>_func_ndtri_exp
ufunc_ndtri_exp_ptr[2*1+1] = <void*>(<char*>"ndtri_exp")
ufunc_ndtri_exp_data[0] = &ufunc_ndtri_exp_ptr[2*0]
ufunc_ndtri_exp_data[1] = &ufunc_ndtri_exp_ptr[2*1]
ndtri_exp = np.PyUFunc_FromFuncAndData(ufunc_ndtri_exp_loops, ufunc_ndtri_exp_data, ufunc_ndtri_exp_types, 2, 1, 1, 0, "ndtri_exp", ufunc_ndtri_exp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nrdtrimn_loops[2]
cdef void *ufunc_nrdtrimn_ptr[4]
cdef void *ufunc_nrdtrimn_data[2]
cdef char ufunc_nrdtrimn_types[8]
cdef char *ufunc_nrdtrimn_doc = (
    "nrdtrimn(p, x, std, out=None)\n"
    "\n"
    "Calculate mean of normal distribution given other params.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].\n"
    "x : array_like\n"
    "    Quantiles, i.e. the upper limit of integration.\n"
    "std : array_like\n"
    "    Standard deviation.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "mn : scalar or ndarray\n"
    "    The mean of the normal distribution.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nrdtrimn, ndtr")
ufunc_nrdtrimn_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nrdtrimn_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nrdtrimn_types[0] = <char>NPY_FLOAT
ufunc_nrdtrimn_types[1] = <char>NPY_FLOAT
ufunc_nrdtrimn_types[2] = <char>NPY_FLOAT
ufunc_nrdtrimn_types[3] = <char>NPY_FLOAT
ufunc_nrdtrimn_types[4] = <char>NPY_DOUBLE
ufunc_nrdtrimn_types[5] = <char>NPY_DOUBLE
ufunc_nrdtrimn_types[6] = <char>NPY_DOUBLE
ufunc_nrdtrimn_types[7] = <char>NPY_DOUBLE
ufunc_nrdtrimn_ptr[2*0] = <void*>_func_cdfnor3_wrap
ufunc_nrdtrimn_ptr[2*0+1] = <void*>(<char*>"nrdtrimn")
ufunc_nrdtrimn_ptr[2*1] = <void*>_func_cdfnor3_wrap
ufunc_nrdtrimn_ptr[2*1+1] = <void*>(<char*>"nrdtrimn")
ufunc_nrdtrimn_data[0] = &ufunc_nrdtrimn_ptr[2*0]
ufunc_nrdtrimn_data[1] = &ufunc_nrdtrimn_ptr[2*1]
nrdtrimn = np.PyUFunc_FromFuncAndData(ufunc_nrdtrimn_loops, ufunc_nrdtrimn_data, ufunc_nrdtrimn_types, 2, 3, 1, 0, "nrdtrimn", ufunc_nrdtrimn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nrdtrisd_loops[2]
cdef void *ufunc_nrdtrisd_ptr[4]
cdef void *ufunc_nrdtrisd_data[2]
cdef char ufunc_nrdtrisd_types[8]
cdef char *ufunc_nrdtrisd_doc = (
    "nrdtrisd(p, x, mn, out=None)\n"
    "\n"
    "Calculate standard deviation of normal distribution given other params.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].\n"
    "x : array_like\n"
    "    Quantiles, i.e. the upper limit of integration.\n"
    "mn : scalar or ndarray\n"
    "    The mean of the normal distribution.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "std : scalar or ndarray\n"
    "    Standard deviation.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ndtr")
ufunc_nrdtrisd_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nrdtrisd_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nrdtrisd_types[0] = <char>NPY_FLOAT
ufunc_nrdtrisd_types[1] = <char>NPY_FLOAT
ufunc_nrdtrisd_types[2] = <char>NPY_FLOAT
ufunc_nrdtrisd_types[3] = <char>NPY_FLOAT
ufunc_nrdtrisd_types[4] = <char>NPY_DOUBLE
ufunc_nrdtrisd_types[5] = <char>NPY_DOUBLE
ufunc_nrdtrisd_types[6] = <char>NPY_DOUBLE
ufunc_nrdtrisd_types[7] = <char>NPY_DOUBLE
ufunc_nrdtrisd_ptr[2*0] = <void*>_func_cdfnor4_wrap
ufunc_nrdtrisd_ptr[2*0+1] = <void*>(<char*>"nrdtrisd")
ufunc_nrdtrisd_ptr[2*1] = <void*>_func_cdfnor4_wrap
ufunc_nrdtrisd_ptr[2*1+1] = <void*>(<char*>"nrdtrisd")
ufunc_nrdtrisd_data[0] = &ufunc_nrdtrisd_ptr[2*0]
ufunc_nrdtrisd_data[1] = &ufunc_nrdtrisd_ptr[2*1]
nrdtrisd = np.PyUFunc_FromFuncAndData(ufunc_nrdtrisd_loops, ufunc_nrdtrisd_data, ufunc_nrdtrisd_types, 2, 3, 1, 0, "nrdtrisd", ufunc_nrdtrisd_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_obl_ang1_loops[2]
cdef void *ufunc_obl_ang1_ptr[4]
cdef void *ufunc_obl_ang1_data[2]
cdef char ufunc_obl_ang1_types[12]
cdef char *ufunc_obl_ang1_doc = (
    "obl_ang1(m, n, c, x, out=None)\n"
    "\n"
    "Oblate spheroidal angular function of the first kind and its derivative\n"
    "\n"
    "Computes the oblate spheroidal angular function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Mode parameter m (nonnegative)\n"
    "n : array_like\n"
    "    Mode parameter n (>= m)\n"
    "c : array_like\n"
    "    Spheroidal parameter\n"
    "x : array_like\n"
    "    Parameter x (``|x| < 1.0``)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : scalar or ndarray\n"
    "    Value of the function\n"
    "sp : scalar or ndarray\n"
    "    Value of the derivative vs x\n"
    "\n"
    "See Also\n"
    "--------\n"
    "obl_ang1_cv")
ufunc_obl_ang1_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_obl_ang1_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_obl_ang1_types[0] = <char>NPY_FLOAT
ufunc_obl_ang1_types[1] = <char>NPY_FLOAT
ufunc_obl_ang1_types[2] = <char>NPY_FLOAT
ufunc_obl_ang1_types[3] = <char>NPY_FLOAT
ufunc_obl_ang1_types[4] = <char>NPY_FLOAT
ufunc_obl_ang1_types[5] = <char>NPY_FLOAT
ufunc_obl_ang1_types[6] = <char>NPY_DOUBLE
ufunc_obl_ang1_types[7] = <char>NPY_DOUBLE
ufunc_obl_ang1_types[8] = <char>NPY_DOUBLE
ufunc_obl_ang1_types[9] = <char>NPY_DOUBLE
ufunc_obl_ang1_types[10] = <char>NPY_DOUBLE
ufunc_obl_ang1_types[11] = <char>NPY_DOUBLE
ufunc_obl_ang1_ptr[2*0] = <void*>_func_oblate_aswfa_nocv_wrap
ufunc_obl_ang1_ptr[2*0+1] = <void*>(<char*>"obl_ang1")
ufunc_obl_ang1_ptr[2*1] = <void*>_func_oblate_aswfa_nocv_wrap
ufunc_obl_ang1_ptr[2*1+1] = <void*>(<char*>"obl_ang1")
ufunc_obl_ang1_data[0] = &ufunc_obl_ang1_ptr[2*0]
ufunc_obl_ang1_data[1] = &ufunc_obl_ang1_ptr[2*1]
obl_ang1 = np.PyUFunc_FromFuncAndData(ufunc_obl_ang1_loops, ufunc_obl_ang1_data, ufunc_obl_ang1_types, 2, 4, 2, 0, "obl_ang1", ufunc_obl_ang1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_obl_ang1_cv_loops[2]
cdef void *ufunc_obl_ang1_cv_ptr[4]
cdef void *ufunc_obl_ang1_cv_data[2]
cdef char ufunc_obl_ang1_cv_types[14]
cdef char *ufunc_obl_ang1_cv_doc = (
    "obl_ang1_cv(m, n, c, cv, x, out=None)\n"
    "\n"
    "Oblate spheroidal angular function obl_ang1 for precomputed characteristic value\n"
    "\n"
    "Computes the oblate spheroidal angular function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``. Requires\n"
    "pre-computed characteristic value.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Mode parameter m (nonnegative)\n"
    "n : array_like\n"
    "    Mode parameter n (>= m)\n"
    "c : array_like\n"
    "    Spheroidal parameter\n"
    "cv : array_like\n"
    "    Characteristic value\n"
    "x : array_like\n"
    "    Parameter x (``|x| < 1.0``)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : scalar or ndarray\n"
    "    Value of the function\n"
    "sp : scalar or ndarray\n"
    "    Value of the derivative vs x\n"
    "\n"
    "See Also\n"
    "--------\n"
    "obl_ang1")
ufunc_obl_ang1_cv_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_fffff_ff
ufunc_obl_ang1_cv_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_ddddd_dd
ufunc_obl_ang1_cv_types[0] = <char>NPY_FLOAT
ufunc_obl_ang1_cv_types[1] = <char>NPY_FLOAT
ufunc_obl_ang1_cv_types[2] = <char>NPY_FLOAT
ufunc_obl_ang1_cv_types[3] = <char>NPY_FLOAT
ufunc_obl_ang1_cv_types[4] = <char>NPY_FLOAT
ufunc_obl_ang1_cv_types[5] = <char>NPY_FLOAT
ufunc_obl_ang1_cv_types[6] = <char>NPY_FLOAT
ufunc_obl_ang1_cv_types[7] = <char>NPY_DOUBLE
ufunc_obl_ang1_cv_types[8] = <char>NPY_DOUBLE
ufunc_obl_ang1_cv_types[9] = <char>NPY_DOUBLE
ufunc_obl_ang1_cv_types[10] = <char>NPY_DOUBLE
ufunc_obl_ang1_cv_types[11] = <char>NPY_DOUBLE
ufunc_obl_ang1_cv_types[12] = <char>NPY_DOUBLE
ufunc_obl_ang1_cv_types[13] = <char>NPY_DOUBLE
ufunc_obl_ang1_cv_ptr[2*0] = <void*>_func_oblate_aswfa_wrap
ufunc_obl_ang1_cv_ptr[2*0+1] = <void*>(<char*>"obl_ang1_cv")
ufunc_obl_ang1_cv_ptr[2*1] = <void*>_func_oblate_aswfa_wrap
ufunc_obl_ang1_cv_ptr[2*1+1] = <void*>(<char*>"obl_ang1_cv")
ufunc_obl_ang1_cv_data[0] = &ufunc_obl_ang1_cv_ptr[2*0]
ufunc_obl_ang1_cv_data[1] = &ufunc_obl_ang1_cv_ptr[2*1]
obl_ang1_cv = np.PyUFunc_FromFuncAndData(ufunc_obl_ang1_cv_loops, ufunc_obl_ang1_cv_data, ufunc_obl_ang1_cv_types, 2, 5, 2, 0, "obl_ang1_cv", ufunc_obl_ang1_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_obl_cv_loops[2]
cdef void *ufunc_obl_cv_ptr[4]
cdef void *ufunc_obl_cv_data[2]
cdef char ufunc_obl_cv_types[8]
cdef char *ufunc_obl_cv_doc = (
    "obl_cv(m, n, c, out=None)\n"
    "\n"
    "Characteristic value of oblate spheroidal function\n"
    "\n"
    "Computes the characteristic value of oblate spheroidal wave\n"
    "functions of order `m`, `n` (n>=m) and spheroidal parameter `c`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Mode parameter m (nonnegative)\n"
    "n : array_like\n"
    "    Mode parameter n (>= m)\n"
    "c : array_like\n"
    "    Spheroidal parameter\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "cv : scalar or ndarray\n"
    "    Characteristic value")
ufunc_obl_cv_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_obl_cv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_obl_cv_types[0] = <char>NPY_FLOAT
ufunc_obl_cv_types[1] = <char>NPY_FLOAT
ufunc_obl_cv_types[2] = <char>NPY_FLOAT
ufunc_obl_cv_types[3] = <char>NPY_FLOAT
ufunc_obl_cv_types[4] = <char>NPY_DOUBLE
ufunc_obl_cv_types[5] = <char>NPY_DOUBLE
ufunc_obl_cv_types[6] = <char>NPY_DOUBLE
ufunc_obl_cv_types[7] = <char>NPY_DOUBLE
ufunc_obl_cv_ptr[2*0] = <void*>_func_oblate_segv_wrap
ufunc_obl_cv_ptr[2*0+1] = <void*>(<char*>"obl_cv")
ufunc_obl_cv_ptr[2*1] = <void*>_func_oblate_segv_wrap
ufunc_obl_cv_ptr[2*1+1] = <void*>(<char*>"obl_cv")
ufunc_obl_cv_data[0] = &ufunc_obl_cv_ptr[2*0]
ufunc_obl_cv_data[1] = &ufunc_obl_cv_ptr[2*1]
obl_cv = np.PyUFunc_FromFuncAndData(ufunc_obl_cv_loops, ufunc_obl_cv_data, ufunc_obl_cv_types, 2, 3, 1, 0, "obl_cv", ufunc_obl_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_obl_rad1_loops[2]
cdef void *ufunc_obl_rad1_ptr[4]
cdef void *ufunc_obl_rad1_data[2]
cdef char ufunc_obl_rad1_types[12]
cdef char *ufunc_obl_rad1_doc = (
    "obl_rad1(m, n, c, x, out=None)\n"
    "\n"
    "Oblate spheroidal radial function of the first kind and its derivative\n"
    "\n"
    "Computes the oblate spheroidal radial function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Mode parameter m (nonnegative)\n"
    "n : array_like\n"
    "    Mode parameter n (>= m)\n"
    "c : array_like\n"
    "    Spheroidal parameter\n"
    "x : array_like\n"
    "    Parameter x (``|x| < 1.0``)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : scalar or ndarray\n"
    "    Value of the function\n"
    "sp : scalar or ndarray\n"
    "    Value of the derivative vs x\n"
    "\n"
    "See Also\n"
    "--------\n"
    "obl_rad1_cv")
ufunc_obl_rad1_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_obl_rad1_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_obl_rad1_types[0] = <char>NPY_FLOAT
ufunc_obl_rad1_types[1] = <char>NPY_FLOAT
ufunc_obl_rad1_types[2] = <char>NPY_FLOAT
ufunc_obl_rad1_types[3] = <char>NPY_FLOAT
ufunc_obl_rad1_types[4] = <char>NPY_FLOAT
ufunc_obl_rad1_types[5] = <char>NPY_FLOAT
ufunc_obl_rad1_types[6] = <char>NPY_DOUBLE
ufunc_obl_rad1_types[7] = <char>NPY_DOUBLE
ufunc_obl_rad1_types[8] = <char>NPY_DOUBLE
ufunc_obl_rad1_types[9] = <char>NPY_DOUBLE
ufunc_obl_rad1_types[10] = <char>NPY_DOUBLE
ufunc_obl_rad1_types[11] = <char>NPY_DOUBLE
ufunc_obl_rad1_ptr[2*0] = <void*>_func_oblate_radial1_nocv_wrap
ufunc_obl_rad1_ptr[2*0+1] = <void*>(<char*>"obl_rad1")
ufunc_obl_rad1_ptr[2*1] = <void*>_func_oblate_radial1_nocv_wrap
ufunc_obl_rad1_ptr[2*1+1] = <void*>(<char*>"obl_rad1")
ufunc_obl_rad1_data[0] = &ufunc_obl_rad1_ptr[2*0]
ufunc_obl_rad1_data[1] = &ufunc_obl_rad1_ptr[2*1]
obl_rad1 = np.PyUFunc_FromFuncAndData(ufunc_obl_rad1_loops, ufunc_obl_rad1_data, ufunc_obl_rad1_types, 2, 4, 2, 0, "obl_rad1", ufunc_obl_rad1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_obl_rad1_cv_loops[2]
cdef void *ufunc_obl_rad1_cv_ptr[4]
cdef void *ufunc_obl_rad1_cv_data[2]
cdef char ufunc_obl_rad1_cv_types[14]
cdef char *ufunc_obl_rad1_cv_doc = (
    "obl_rad1_cv(m, n, c, cv, x, out=None)\n"
    "\n"
    "Oblate spheroidal radial function obl_rad1 for precomputed characteristic value\n"
    "\n"
    "Computes the oblate spheroidal radial function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``. Requires\n"
    "pre-computed characteristic value.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Mode parameter m (nonnegative)\n"
    "n : array_like\n"
    "    Mode parameter n (>= m)\n"
    "c : array_like\n"
    "    Spheroidal parameter\n"
    "cv : array_like\n"
    "    Characteristic value\n"
    "x : array_like\n"
    "    Parameter x (``|x| < 1.0``)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : scalar or ndarray\n"
    "    Value of the function\n"
    "sp : scalar or ndarray\n"
    "    Value of the derivative vs x\n"
    "\n"
    "See Also\n"
    "--------\n"
    "obl_rad1")
ufunc_obl_rad1_cv_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_fffff_ff
ufunc_obl_rad1_cv_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_ddddd_dd
ufunc_obl_rad1_cv_types[0] = <char>NPY_FLOAT
ufunc_obl_rad1_cv_types[1] = <char>NPY_FLOAT
ufunc_obl_rad1_cv_types[2] = <char>NPY_FLOAT
ufunc_obl_rad1_cv_types[3] = <char>NPY_FLOAT
ufunc_obl_rad1_cv_types[4] = <char>NPY_FLOAT
ufunc_obl_rad1_cv_types[5] = <char>NPY_FLOAT
ufunc_obl_rad1_cv_types[6] = <char>NPY_FLOAT
ufunc_obl_rad1_cv_types[7] = <char>NPY_DOUBLE
ufunc_obl_rad1_cv_types[8] = <char>NPY_DOUBLE
ufunc_obl_rad1_cv_types[9] = <char>NPY_DOUBLE
ufunc_obl_rad1_cv_types[10] = <char>NPY_DOUBLE
ufunc_obl_rad1_cv_types[11] = <char>NPY_DOUBLE
ufunc_obl_rad1_cv_types[12] = <char>NPY_DOUBLE
ufunc_obl_rad1_cv_types[13] = <char>NPY_DOUBLE
ufunc_obl_rad1_cv_ptr[2*0] = <void*>_func_oblate_radial1_wrap
ufunc_obl_rad1_cv_ptr[2*0+1] = <void*>(<char*>"obl_rad1_cv")
ufunc_obl_rad1_cv_ptr[2*1] = <void*>_func_oblate_radial1_wrap
ufunc_obl_rad1_cv_ptr[2*1+1] = <void*>(<char*>"obl_rad1_cv")
ufunc_obl_rad1_cv_data[0] = &ufunc_obl_rad1_cv_ptr[2*0]
ufunc_obl_rad1_cv_data[1] = &ufunc_obl_rad1_cv_ptr[2*1]
obl_rad1_cv = np.PyUFunc_FromFuncAndData(ufunc_obl_rad1_cv_loops, ufunc_obl_rad1_cv_data, ufunc_obl_rad1_cv_types, 2, 5, 2, 0, "obl_rad1_cv", ufunc_obl_rad1_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_obl_rad2_loops[2]
cdef void *ufunc_obl_rad2_ptr[4]
cdef void *ufunc_obl_rad2_data[2]
cdef char ufunc_obl_rad2_types[12]
cdef char *ufunc_obl_rad2_doc = (
    "obl_rad2(m, n, c, x, out=None)\n"
    "\n"
    "Oblate spheroidal radial function of the second kind and its derivative.\n"
    "\n"
    "Computes the oblate spheroidal radial function of the second kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Mode parameter m (nonnegative)\n"
    "n : array_like\n"
    "    Mode parameter n (>= m)\n"
    "c : array_like\n"
    "    Spheroidal parameter\n"
    "x : array_like\n"
    "    Parameter x (``|x| < 1.0``)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : scalar or ndarray\n"
    "    Value of the function\n"
    "sp : scalar or ndarray\n"
    "    Value of the derivative vs x\n"
    "\n"
    "See Also\n"
    "--------\n"
    "obl_rad2_cv")
ufunc_obl_rad2_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_obl_rad2_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_obl_rad2_types[0] = <char>NPY_FLOAT
ufunc_obl_rad2_types[1] = <char>NPY_FLOAT
ufunc_obl_rad2_types[2] = <char>NPY_FLOAT
ufunc_obl_rad2_types[3] = <char>NPY_FLOAT
ufunc_obl_rad2_types[4] = <char>NPY_FLOAT
ufunc_obl_rad2_types[5] = <char>NPY_FLOAT
ufunc_obl_rad2_types[6] = <char>NPY_DOUBLE
ufunc_obl_rad2_types[7] = <char>NPY_DOUBLE
ufunc_obl_rad2_types[8] = <char>NPY_DOUBLE
ufunc_obl_rad2_types[9] = <char>NPY_DOUBLE
ufunc_obl_rad2_types[10] = <char>NPY_DOUBLE
ufunc_obl_rad2_types[11] = <char>NPY_DOUBLE
ufunc_obl_rad2_ptr[2*0] = <void*>_func_oblate_radial2_nocv_wrap
ufunc_obl_rad2_ptr[2*0+1] = <void*>(<char*>"obl_rad2")
ufunc_obl_rad2_ptr[2*1] = <void*>_func_oblate_radial2_nocv_wrap
ufunc_obl_rad2_ptr[2*1+1] = <void*>(<char*>"obl_rad2")
ufunc_obl_rad2_data[0] = &ufunc_obl_rad2_ptr[2*0]
ufunc_obl_rad2_data[1] = &ufunc_obl_rad2_ptr[2*1]
obl_rad2 = np.PyUFunc_FromFuncAndData(ufunc_obl_rad2_loops, ufunc_obl_rad2_data, ufunc_obl_rad2_types, 2, 4, 2, 0, "obl_rad2", ufunc_obl_rad2_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_obl_rad2_cv_loops[2]
cdef void *ufunc_obl_rad2_cv_ptr[4]
cdef void *ufunc_obl_rad2_cv_data[2]
cdef char ufunc_obl_rad2_cv_types[14]
cdef char *ufunc_obl_rad2_cv_doc = (
    "obl_rad2_cv(m, n, c, cv, x, out=None)\n"
    "\n"
    "Oblate spheroidal radial function obl_rad2 for precomputed characteristic value\n"
    "\n"
    "Computes the oblate spheroidal radial function of the second kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``. Requires\n"
    "pre-computed characteristic value.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Mode parameter m (nonnegative)\n"
    "n : array_like\n"
    "    Mode parameter n (>= m)\n"
    "c : array_like\n"
    "    Spheroidal parameter\n"
    "cv : array_like\n"
    "    Characteristic value\n"
    "x : array_like\n"
    "    Parameter x (``|x| < 1.0``)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : scalar or ndarray\n"
    "    Value of the function\n"
    "sp : scalar or ndarray\n"
    "    Value of the derivative vs x\n"
    "\n"
    "See Also\n"
    "--------\n"
    "obl_rad2")
ufunc_obl_rad2_cv_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_fffff_ff
ufunc_obl_rad2_cv_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_ddddd_dd
ufunc_obl_rad2_cv_types[0] = <char>NPY_FLOAT
ufunc_obl_rad2_cv_types[1] = <char>NPY_FLOAT
ufunc_obl_rad2_cv_types[2] = <char>NPY_FLOAT
ufunc_obl_rad2_cv_types[3] = <char>NPY_FLOAT
ufunc_obl_rad2_cv_types[4] = <char>NPY_FLOAT
ufunc_obl_rad2_cv_types[5] = <char>NPY_FLOAT
ufunc_obl_rad2_cv_types[6] = <char>NPY_FLOAT
ufunc_obl_rad2_cv_types[7] = <char>NPY_DOUBLE
ufunc_obl_rad2_cv_types[8] = <char>NPY_DOUBLE
ufunc_obl_rad2_cv_types[9] = <char>NPY_DOUBLE
ufunc_obl_rad2_cv_types[10] = <char>NPY_DOUBLE
ufunc_obl_rad2_cv_types[11] = <char>NPY_DOUBLE
ufunc_obl_rad2_cv_types[12] = <char>NPY_DOUBLE
ufunc_obl_rad2_cv_types[13] = <char>NPY_DOUBLE
ufunc_obl_rad2_cv_ptr[2*0] = <void*>_func_oblate_radial2_wrap
ufunc_obl_rad2_cv_ptr[2*0+1] = <void*>(<char*>"obl_rad2_cv")
ufunc_obl_rad2_cv_ptr[2*1] = <void*>_func_oblate_radial2_wrap
ufunc_obl_rad2_cv_ptr[2*1+1] = <void*>(<char*>"obl_rad2_cv")
ufunc_obl_rad2_cv_data[0] = &ufunc_obl_rad2_cv_ptr[2*0]
ufunc_obl_rad2_cv_data[1] = &ufunc_obl_rad2_cv_ptr[2*1]
obl_rad2_cv = np.PyUFunc_FromFuncAndData(ufunc_obl_rad2_cv_loops, ufunc_obl_rad2_cv_data, ufunc_obl_rad2_cv_types, 2, 5, 2, 0, "obl_rad2_cv", ufunc_obl_rad2_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_owens_t_loops[2]
cdef void *ufunc_owens_t_ptr[4]
cdef void *ufunc_owens_t_data[2]
cdef char ufunc_owens_t_types[6]
cdef char *ufunc_owens_t_doc = (
    "owens_t(h, a, out=None)\n"
    "\n"
    "Owen's T Function.\n"
    "\n"
    "The function T(h, a) gives the probability of the event\n"
    "(X > h and 0 < Y < a * X) where X and Y are independent\n"
    "standard normal random variables.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "h: array_like\n"
    "    Input value.\n"
    "a: array_like\n"
    "    Input value.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "t: scalar or ndarray\n"
    "    Probability of the event (X > h and 0 < Y < a * X),\n"
    "    where X and Y are independent standard normal random variables.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] M. Patefield and D. Tandy, \"Fast and accurate calculation of\n"
    "       Owen's T Function\", Statistical Software vol. 5, pp. 1-25, 2000.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy import special\n"
    ">>> a = 3.5\n"
    ">>> h = 0.78\n"
    ">>> special.owens_t(h, a)\n"
    "0.10877216734852274")
ufunc_owens_t_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_owens_t_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_owens_t_types[0] = <char>NPY_FLOAT
ufunc_owens_t_types[1] = <char>NPY_FLOAT
ufunc_owens_t_types[2] = <char>NPY_FLOAT
ufunc_owens_t_types[3] = <char>NPY_DOUBLE
ufunc_owens_t_types[4] = <char>NPY_DOUBLE
ufunc_owens_t_types[5] = <char>NPY_DOUBLE
ufunc_owens_t_ptr[2*0] = <void*>_func_owens_t
ufunc_owens_t_ptr[2*0+1] = <void*>(<char*>"owens_t")
ufunc_owens_t_ptr[2*1] = <void*>_func_owens_t
ufunc_owens_t_ptr[2*1+1] = <void*>(<char*>"owens_t")
ufunc_owens_t_data[0] = &ufunc_owens_t_ptr[2*0]
ufunc_owens_t_data[1] = &ufunc_owens_t_ptr[2*1]
owens_t = np.PyUFunc_FromFuncAndData(ufunc_owens_t_loops, ufunc_owens_t_data, ufunc_owens_t_types, 2, 2, 1, 0, "owens_t", ufunc_owens_t_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pbdv_loops[2]
cdef void *ufunc_pbdv_ptr[4]
cdef void *ufunc_pbdv_data[2]
cdef char ufunc_pbdv_types[8]
cdef char *ufunc_pbdv_doc = (
    "pbdv(v, x, out=None)\n"
    "\n"
    "Parabolic cylinder function D\n"
    "\n"
    "Returns (d, dp) the parabolic cylinder function Dv(x) in d and the\n"
    "derivative, Dv'(x) in dp.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Real parameter\n"
    "x : array_like\n"
    "    Real argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "d : scalar or ndarray\n"
    "    Value of the function\n"
    "dp : scalar or ndarray\n"
    "    Value of the derivative vs x")
ufunc_pbdv_loops[0] = <np.PyUFuncGenericFunction>loop_i_dd_dd_As_ff_ff
ufunc_pbdv_loops[1] = <np.PyUFuncGenericFunction>loop_i_dd_dd_As_dd_dd
ufunc_pbdv_types[0] = <char>NPY_FLOAT
ufunc_pbdv_types[1] = <char>NPY_FLOAT
ufunc_pbdv_types[2] = <char>NPY_FLOAT
ufunc_pbdv_types[3] = <char>NPY_FLOAT
ufunc_pbdv_types[4] = <char>NPY_DOUBLE
ufunc_pbdv_types[5] = <char>NPY_DOUBLE
ufunc_pbdv_types[6] = <char>NPY_DOUBLE
ufunc_pbdv_types[7] = <char>NPY_DOUBLE
ufunc_pbdv_ptr[2*0] = <void*>_func_pbdv_wrap
ufunc_pbdv_ptr[2*0+1] = <void*>(<char*>"pbdv")
ufunc_pbdv_ptr[2*1] = <void*>_func_pbdv_wrap
ufunc_pbdv_ptr[2*1+1] = <void*>(<char*>"pbdv")
ufunc_pbdv_data[0] = &ufunc_pbdv_ptr[2*0]
ufunc_pbdv_data[1] = &ufunc_pbdv_ptr[2*1]
pbdv = np.PyUFunc_FromFuncAndData(ufunc_pbdv_loops, ufunc_pbdv_data, ufunc_pbdv_types, 2, 2, 2, 0, "pbdv", ufunc_pbdv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pbvv_loops[2]
cdef void *ufunc_pbvv_ptr[4]
cdef void *ufunc_pbvv_data[2]
cdef char ufunc_pbvv_types[8]
cdef char *ufunc_pbvv_doc = (
    "pbvv(v, x, out=None)\n"
    "\n"
    "Parabolic cylinder function V\n"
    "\n"
    "Returns the parabolic cylinder function Vv(x) in v and the\n"
    "derivative, Vv'(x) in vp.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Real parameter\n"
    "x : array_like\n"
    "    Real argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v : scalar or ndarray\n"
    "    Value of the function\n"
    "vp : scalar or ndarray\n"
    "    Value of the derivative vs x")
ufunc_pbvv_loops[0] = <np.PyUFuncGenericFunction>loop_i_dd_dd_As_ff_ff
ufunc_pbvv_loops[1] = <np.PyUFuncGenericFunction>loop_i_dd_dd_As_dd_dd
ufunc_pbvv_types[0] = <char>NPY_FLOAT
ufunc_pbvv_types[1] = <char>NPY_FLOAT
ufunc_pbvv_types[2] = <char>NPY_FLOAT
ufunc_pbvv_types[3] = <char>NPY_FLOAT
ufunc_pbvv_types[4] = <char>NPY_DOUBLE
ufunc_pbvv_types[5] = <char>NPY_DOUBLE
ufunc_pbvv_types[6] = <char>NPY_DOUBLE
ufunc_pbvv_types[7] = <char>NPY_DOUBLE
ufunc_pbvv_ptr[2*0] = <void*>_func_pbvv_wrap
ufunc_pbvv_ptr[2*0+1] = <void*>(<char*>"pbvv")
ufunc_pbvv_ptr[2*1] = <void*>_func_pbvv_wrap
ufunc_pbvv_ptr[2*1+1] = <void*>(<char*>"pbvv")
ufunc_pbvv_data[0] = &ufunc_pbvv_ptr[2*0]
ufunc_pbvv_data[1] = &ufunc_pbvv_ptr[2*1]
pbvv = np.PyUFunc_FromFuncAndData(ufunc_pbvv_loops, ufunc_pbvv_data, ufunc_pbvv_types, 2, 2, 2, 0, "pbvv", ufunc_pbvv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pbwa_loops[2]
cdef void *ufunc_pbwa_ptr[4]
cdef void *ufunc_pbwa_data[2]
cdef char ufunc_pbwa_types[8]
cdef char *ufunc_pbwa_doc = (
    "pbwa(a, x, out=None)\n"
    "\n"
    "Parabolic cylinder function W.\n"
    "\n"
    "The function is a particular solution to the differential equation\n"
    "\n"
    ".. math::\n"
    "\n"
    "    y'' + \\left(\\frac{1}{4}x^2 - a\\right)y = 0,\n"
    "\n"
    "for a full definition see section 12.14 in [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Real parameter\n"
    "x : array_like\n"
    "    Real argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "w : scalar or ndarray\n"
    "    Value of the function\n"
    "wp : scalar or ndarray\n"
    "    Value of the derivative in x\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The function is a wrapper for a Fortran routine by Zhang and Jin\n"
    "[2]_. The implementation is accurate only for ``|a|, |x| < 5`` and\n"
    "returns NaN outside that range.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Digital Library of Mathematical Functions, 14.30.\n"
    "       https://dlmf.nist.gov/14.30\n"
    ".. [2] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n"
    "       Functions\", John Wiley and Sons, 1996.\n"
    "       https://people.sc.fsu.edu/~jburkardt/f_src/special_functions/special_functions.html")
ufunc_pbwa_loops[0] = <np.PyUFuncGenericFunction>loop_i_dd_dd_As_ff_ff
ufunc_pbwa_loops[1] = <np.PyUFuncGenericFunction>loop_i_dd_dd_As_dd_dd
ufunc_pbwa_types[0] = <char>NPY_FLOAT
ufunc_pbwa_types[1] = <char>NPY_FLOAT
ufunc_pbwa_types[2] = <char>NPY_FLOAT
ufunc_pbwa_types[3] = <char>NPY_FLOAT
ufunc_pbwa_types[4] = <char>NPY_DOUBLE
ufunc_pbwa_types[5] = <char>NPY_DOUBLE
ufunc_pbwa_types[6] = <char>NPY_DOUBLE
ufunc_pbwa_types[7] = <char>NPY_DOUBLE
ufunc_pbwa_ptr[2*0] = <void*>_func_pbwa_wrap
ufunc_pbwa_ptr[2*0+1] = <void*>(<char*>"pbwa")
ufunc_pbwa_ptr[2*1] = <void*>_func_pbwa_wrap
ufunc_pbwa_ptr[2*1+1] = <void*>(<char*>"pbwa")
ufunc_pbwa_data[0] = &ufunc_pbwa_ptr[2*0]
ufunc_pbwa_data[1] = &ufunc_pbwa_ptr[2*1]
pbwa = np.PyUFunc_FromFuncAndData(ufunc_pbwa_loops, ufunc_pbwa_data, ufunc_pbwa_types, 2, 2, 2, 0, "pbwa", ufunc_pbwa_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pdtr_loops[2]
cdef void *ufunc_pdtr_ptr[4]
cdef void *ufunc_pdtr_data[2]
cdef char ufunc_pdtr_types[6]
cdef char *ufunc_pdtr_doc = (
    "pdtr(k, m, out=None)\n"
    "\n"
    "Poisson cumulative distribution function.\n"
    "\n"
    "Defined as the probability that a Poisson-distributed random\n"
    "variable with event rate :math:`m` is less than or equal to\n"
    ":math:`k`. More concretely, this works out to be [1]_\n"
    "\n"
    ".. math::\n"
    "\n"
    "   \\exp(-m) \\sum_{j = 0}^{\\lfloor{k}\\rfloor} \\frac{m^j}{j!}.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of occurrences (nonnegative, real)\n"
    "m : array_like\n"
    "    Shape parameter (nonnegative, real)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the Poisson cumulative distribution function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "pdtrc : Poisson survival function\n"
    "pdtrik : inverse of `pdtr` with respect to `k`\n"
    "pdtri : inverse of `pdtr` with respect to `m`\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] https://en.wikipedia.org/wiki/Poisson_distribution\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is a cumulative distribution function, so it converges to 1\n"
    "monotonically as `k` goes to infinity.\n"
    "\n"
    ">>> sc.pdtr([1, 10, 100, np.inf], 1)\n"
    "array([0.73575888, 0.99999999, 1.        , 1.        ])\n"
    "\n"
    "It is discontinuous at integers and constant between integers.\n"
    "\n"
    ">>> sc.pdtr([1, 1.5, 1.9, 2], 1)\n"
    "array([0.73575888, 0.73575888, 0.73575888, 0.9196986 ])")
ufunc_pdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pdtr_types[0] = <char>NPY_FLOAT
ufunc_pdtr_types[1] = <char>NPY_FLOAT
ufunc_pdtr_types[2] = <char>NPY_FLOAT
ufunc_pdtr_types[3] = <char>NPY_DOUBLE
ufunc_pdtr_types[4] = <char>NPY_DOUBLE
ufunc_pdtr_types[5] = <char>NPY_DOUBLE
ufunc_pdtr_ptr[2*0] = <void*>_func_pdtr
ufunc_pdtr_ptr[2*0+1] = <void*>(<char*>"pdtr")
ufunc_pdtr_ptr[2*1] = <void*>_func_pdtr
ufunc_pdtr_ptr[2*1+1] = <void*>(<char*>"pdtr")
ufunc_pdtr_data[0] = &ufunc_pdtr_ptr[2*0]
ufunc_pdtr_data[1] = &ufunc_pdtr_ptr[2*1]
pdtr = np.PyUFunc_FromFuncAndData(ufunc_pdtr_loops, ufunc_pdtr_data, ufunc_pdtr_types, 2, 2, 1, 0, "pdtr", ufunc_pdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pdtrc_loops[2]
cdef void *ufunc_pdtrc_ptr[4]
cdef void *ufunc_pdtrc_data[2]
cdef char ufunc_pdtrc_types[6]
cdef char *ufunc_pdtrc_doc = (
    "pdtrc(k, m, out=None)\n"
    "\n"
    "Poisson survival function\n"
    "\n"
    "Returns the sum of the terms from k+1 to infinity of the Poisson\n"
    "distribution: sum(exp(-m) * m**j / j!, j=k+1..inf) = gammainc(\n"
    "k+1, m). Arguments must both be non-negative doubles.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of occurrences (nonnegative, real)\n"
    "m : array_like\n"
    "    Shape parameter (nonnegative, real)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the Poisson survival function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "pdtr : Poisson cumulative distribution function\n"
    "pdtrik : inverse of `pdtr` with respect to `k`\n"
    "pdtri : inverse of `pdtr` with respect to `m`")
ufunc_pdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pdtrc_types[0] = <char>NPY_FLOAT
ufunc_pdtrc_types[1] = <char>NPY_FLOAT
ufunc_pdtrc_types[2] = <char>NPY_FLOAT
ufunc_pdtrc_types[3] = <char>NPY_DOUBLE
ufunc_pdtrc_types[4] = <char>NPY_DOUBLE
ufunc_pdtrc_types[5] = <char>NPY_DOUBLE
ufunc_pdtrc_ptr[2*0] = <void*>_func_pdtrc
ufunc_pdtrc_ptr[2*0+1] = <void*>(<char*>"pdtrc")
ufunc_pdtrc_ptr[2*1] = <void*>_func_pdtrc
ufunc_pdtrc_ptr[2*1+1] = <void*>(<char*>"pdtrc")
ufunc_pdtrc_data[0] = &ufunc_pdtrc_ptr[2*0]
ufunc_pdtrc_data[1] = &ufunc_pdtrc_ptr[2*1]
pdtrc = np.PyUFunc_FromFuncAndData(ufunc_pdtrc_loops, ufunc_pdtrc_data, ufunc_pdtrc_types, 2, 2, 1, 0, "pdtrc", ufunc_pdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pdtri_loops[3]
cdef void *ufunc_pdtri_ptr[6]
cdef void *ufunc_pdtri_data[3]
cdef char ufunc_pdtri_types[9]
cdef char *ufunc_pdtri_doc = (
    "pdtri(k, y, out=None)\n"
    "\n"
    "Inverse to `pdtr` vs m\n"
    "\n"
    "Returns the Poisson variable `m` such that the sum from 0 to `k` of\n"
    "the Poisson density is equal to the given probability `y`:\n"
    "calculated by ``gammaincinv(k + 1, y)``. `k` must be a nonnegative\n"
    "integer and `y` between 0 and 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of occurrences (nonnegative, real)\n"
    "y : array_like\n"
    "    Probability\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the shape parameter `m` such that ``pdtr(k, m) = p``\n"
    "\n"
    "See Also\n"
    "--------\n"
    "pdtr : Poisson cumulative distribution function\n"
    "pdtrc : Poisson survival function\n"
    "pdtrik : inverse of `pdtr` with respect to `k`")
ufunc_pdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_pdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pdtri_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pdtri_types[0] = <char>NPY_LONG
ufunc_pdtri_types[1] = <char>NPY_DOUBLE
ufunc_pdtri_types[2] = <char>NPY_DOUBLE
ufunc_pdtri_types[3] = <char>NPY_FLOAT
ufunc_pdtri_types[4] = <char>NPY_FLOAT
ufunc_pdtri_types[5] = <char>NPY_FLOAT
ufunc_pdtri_types[6] = <char>NPY_DOUBLE
ufunc_pdtri_types[7] = <char>NPY_DOUBLE
ufunc_pdtri_types[8] = <char>NPY_DOUBLE
ufunc_pdtri_ptr[2*0] = <void*>_func_pdtri
ufunc_pdtri_ptr[2*0+1] = <void*>(<char*>"pdtri")
ufunc_pdtri_ptr[2*1] = <void*>_func_pdtri_unsafe
ufunc_pdtri_ptr[2*1+1] = <void*>(<char*>"pdtri")
ufunc_pdtri_ptr[2*2] = <void*>_func_pdtri_unsafe
ufunc_pdtri_ptr[2*2+1] = <void*>(<char*>"pdtri")
ufunc_pdtri_data[0] = &ufunc_pdtri_ptr[2*0]
ufunc_pdtri_data[1] = &ufunc_pdtri_ptr[2*1]
ufunc_pdtri_data[2] = &ufunc_pdtri_ptr[2*2]
pdtri = np.PyUFunc_FromFuncAndData(ufunc_pdtri_loops, ufunc_pdtri_data, ufunc_pdtri_types, 3, 2, 1, 0, "pdtri", ufunc_pdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pdtrik_loops[2]
cdef void *ufunc_pdtrik_ptr[4]
cdef void *ufunc_pdtrik_data[2]
cdef char ufunc_pdtrik_types[6]
cdef char *ufunc_pdtrik_doc = (
    "pdtrik(p, m, out=None)\n"
    "\n"
    "Inverse to `pdtr` vs `m`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Shape parameter (nonnegative, real)\n"
    "p : array_like\n"
    "    Probability\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The number of occurrences `k` such that ``pdtr(k, m) = p``\n"
    "\n"
    "See Also\n"
    "--------\n"
    "pdtr : Poisson cumulative distribution function\n"
    "pdtrc : Poisson survival function\n"
    "pdtri : inverse of `pdtr` with respect to `m`")
ufunc_pdtrik_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pdtrik_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pdtrik_types[0] = <char>NPY_FLOAT
ufunc_pdtrik_types[1] = <char>NPY_FLOAT
ufunc_pdtrik_types[2] = <char>NPY_FLOAT
ufunc_pdtrik_types[3] = <char>NPY_DOUBLE
ufunc_pdtrik_types[4] = <char>NPY_DOUBLE
ufunc_pdtrik_types[5] = <char>NPY_DOUBLE
ufunc_pdtrik_ptr[2*0] = <void*>_func_cdfpoi2_wrap
ufunc_pdtrik_ptr[2*0+1] = <void*>(<char*>"pdtrik")
ufunc_pdtrik_ptr[2*1] = <void*>_func_cdfpoi2_wrap
ufunc_pdtrik_ptr[2*1+1] = <void*>(<char*>"pdtrik")
ufunc_pdtrik_data[0] = &ufunc_pdtrik_ptr[2*0]
ufunc_pdtrik_data[1] = &ufunc_pdtrik_ptr[2*1]
pdtrik = np.PyUFunc_FromFuncAndData(ufunc_pdtrik_loops, ufunc_pdtrik_data, ufunc_pdtrik_types, 2, 2, 1, 0, "pdtrik", ufunc_pdtrik_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_poch_loops[2]
cdef void *ufunc_poch_ptr[4]
cdef void *ufunc_poch_data[2]
cdef char ufunc_poch_types[6]
cdef char *ufunc_poch_doc = (
    "poch(z, m, out=None)\n"
    "\n"
    "Pochhammer symbol.\n"
    "\n"
    "The Pochhammer symbol (rising factorial) is defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    (z)_m = \\frac{\\Gamma(z + m)}{\\Gamma(z)}\n"
    "\n"
    "For positive integer `m` it reads\n"
    "\n"
    ".. math::\n"
    "\n"
    "    (z)_m = z (z + 1) ... (z + m - 1)\n"
    "\n"
    "See [dlmf]_ for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z, m : array_like\n"
    "    Real-valued arguments.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The value of the function.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] Nist, Digital Library of Mathematical Functions\n"
    "    https://dlmf.nist.gov/5.2#iii\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is 1 when m is 0.\n"
    "\n"
    ">>> sc.poch([1, 2, 3, 4], 0)\n"
    "array([1., 1., 1., 1.])\n"
    "\n"
    "For z equal to 1 it reduces to the factorial function.\n"
    "\n"
    ">>> sc.poch(1, 5)\n"
    "120.0\n"
    ">>> 1 * 2 * 3 * 4 * 5\n"
    "120\n"
    "\n"
    "It can be expressed in terms of the gamma function.\n"
    "\n"
    ">>> z, m = 3.7, 2.1\n"
    ">>> sc.poch(z, m)\n"
    "20.529581933776953\n"
    ">>> sc.gamma(z + m) / sc.gamma(z)\n"
    "20.52958193377696")
ufunc_poch_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_poch_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_poch_types[0] = <char>NPY_FLOAT
ufunc_poch_types[1] = <char>NPY_FLOAT
ufunc_poch_types[2] = <char>NPY_FLOAT
ufunc_poch_types[3] = <char>NPY_DOUBLE
ufunc_poch_types[4] = <char>NPY_DOUBLE
ufunc_poch_types[5] = <char>NPY_DOUBLE
ufunc_poch_ptr[2*0] = <void*>_func_poch
ufunc_poch_ptr[2*0+1] = <void*>(<char*>"poch")
ufunc_poch_ptr[2*1] = <void*>_func_poch
ufunc_poch_ptr[2*1+1] = <void*>(<char*>"poch")
ufunc_poch_data[0] = &ufunc_poch_ptr[2*0]
ufunc_poch_data[1] = &ufunc_poch_ptr[2*1]
poch = np.PyUFunc_FromFuncAndData(ufunc_poch_loops, ufunc_poch_data, ufunc_poch_types, 2, 2, 1, 0, "poch", ufunc_poch_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_powm1_loops[2]
cdef void *ufunc_powm1_ptr[4]
cdef void *ufunc_powm1_data[2]
cdef char ufunc_powm1_types[6]
cdef char *ufunc_powm1_doc = (
    "powm1(x, y, out=None)\n"
    "\n"
    "Computes ``x**y - 1``.\n"
    "\n"
    "This function is useful when `y` is near 0, or when `x` is near 1.\n"
    "\n"
    "The function is implemented for real types only (unlike ``numpy.power``,\n"
    "which accepts complex inputs).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    The base. Must be a real type (i.e. integer or float, not complex).\n"
    "y : array_like\n"
    "    The exponent. Must be a real type (i.e. integer or float, not complex).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "array_like\n"
    "    Result of the calculation\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 1.10.0\n"
    "\n"
    "The underlying code is implemented for single precision and double\n"
    "precision floats only.  Unlike `numpy.power`, integer inputs to\n"
    "`powm1` are converted to floating point, and complex inputs are\n"
    "not accepted.\n"
    "\n"
    "Note the following edge cases:\n"
    "\n"
    "* ``powm1(x, 0)`` returns 0 for any ``x``, including 0, ``inf``\n"
    "  and ``nan``.\n"
    "* ``powm1(1, y)`` returns 0 for any ``y``, including ``nan``\n"
    "  and ``inf``.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import powm1\n"
    "\n"
    ">>> x = np.array([1.2, 10.0, 0.9999999975])\n"
    ">>> y = np.array([1e-9, 1e-11, 0.1875])\n"
    ">>> powm1(x, y)\n"
    "array([ 1.82321557e-10,  2.30258509e-11, -4.68749998e-10])\n"
    "\n"
    "It can be verified that the relative errors in those results\n"
    "are less than 2.5e-16.\n"
    "\n"
    "Compare that to the result of ``x**y - 1``, where the\n"
    "relative errors are all larger than 8e-8:\n"
    "\n"
    ">>> x**y - 1\n"
    "array([ 1.82321491e-10,  2.30258035e-11, -4.68750039e-10])")
ufunc_powm1_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc_powm1_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_powm1_types[0] = <char>NPY_FLOAT
ufunc_powm1_types[1] = <char>NPY_FLOAT
ufunc_powm1_types[2] = <char>NPY_FLOAT
ufunc_powm1_types[3] = <char>NPY_DOUBLE
ufunc_powm1_types[4] = <char>NPY_DOUBLE
ufunc_powm1_types[5] = <char>NPY_DOUBLE
ufunc_powm1_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_powm1_float
ufunc_powm1_ptr[2*0+1] = <void*>(<char*>"powm1")
ufunc_powm1_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_powm1_double
ufunc_powm1_ptr[2*1+1] = <void*>(<char*>"powm1")
ufunc_powm1_data[0] = &ufunc_powm1_ptr[2*0]
ufunc_powm1_data[1] = &ufunc_powm1_ptr[2*1]
powm1 = np.PyUFunc_FromFuncAndData(ufunc_powm1_loops, ufunc_powm1_data, ufunc_powm1_types, 2, 2, 1, 0, "powm1", ufunc_powm1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pro_ang1_loops[2]
cdef void *ufunc_pro_ang1_ptr[4]
cdef void *ufunc_pro_ang1_data[2]
cdef char ufunc_pro_ang1_types[12]
cdef char *ufunc_pro_ang1_doc = (
    "pro_ang1(m, n, c, x, out=None)\n"
    "\n"
    "Prolate spheroidal angular function of the first kind and its derivative\n"
    "\n"
    "Computes the prolate spheroidal angular function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Nonnegative mode parameter m\n"
    "n : array_like\n"
    "    Mode parameter n (>= m)\n"
    "c : array_like\n"
    "    Spheroidal parameter\n"
    "x : array_like\n"
    "    Real parameter (``|x| < 1.0``)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : scalar or ndarray\n"
    "    Value of the function\n"
    "sp : scalar or ndarray\n"
    "    Value of the derivative vs x")
ufunc_pro_ang1_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_pro_ang1_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_pro_ang1_types[0] = <char>NPY_FLOAT
ufunc_pro_ang1_types[1] = <char>NPY_FLOAT
ufunc_pro_ang1_types[2] = <char>NPY_FLOAT
ufunc_pro_ang1_types[3] = <char>NPY_FLOAT
ufunc_pro_ang1_types[4] = <char>NPY_FLOAT
ufunc_pro_ang1_types[5] = <char>NPY_FLOAT
ufunc_pro_ang1_types[6] = <char>NPY_DOUBLE
ufunc_pro_ang1_types[7] = <char>NPY_DOUBLE
ufunc_pro_ang1_types[8] = <char>NPY_DOUBLE
ufunc_pro_ang1_types[9] = <char>NPY_DOUBLE
ufunc_pro_ang1_types[10] = <char>NPY_DOUBLE
ufunc_pro_ang1_types[11] = <char>NPY_DOUBLE
ufunc_pro_ang1_ptr[2*0] = <void*>_func_prolate_aswfa_nocv_wrap
ufunc_pro_ang1_ptr[2*0+1] = <void*>(<char*>"pro_ang1")
ufunc_pro_ang1_ptr[2*1] = <void*>_func_prolate_aswfa_nocv_wrap
ufunc_pro_ang1_ptr[2*1+1] = <void*>(<char*>"pro_ang1")
ufunc_pro_ang1_data[0] = &ufunc_pro_ang1_ptr[2*0]
ufunc_pro_ang1_data[1] = &ufunc_pro_ang1_ptr[2*1]
pro_ang1 = np.PyUFunc_FromFuncAndData(ufunc_pro_ang1_loops, ufunc_pro_ang1_data, ufunc_pro_ang1_types, 2, 4, 2, 0, "pro_ang1", ufunc_pro_ang1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pro_ang1_cv_loops[2]
cdef void *ufunc_pro_ang1_cv_ptr[4]
cdef void *ufunc_pro_ang1_cv_data[2]
cdef char ufunc_pro_ang1_cv_types[14]
cdef char *ufunc_pro_ang1_cv_doc = (
    "pro_ang1_cv(m, n, c, cv, x, out=None)\n"
    "\n"
    "Prolate spheroidal angular function pro_ang1 for precomputed characteristic value\n"
    "\n"
    "Computes the prolate spheroidal angular function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``. Requires\n"
    "pre-computed characteristic value.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Nonnegative mode parameter m\n"
    "n : array_like\n"
    "    Mode parameter n (>= m)\n"
    "c : array_like\n"
    "    Spheroidal parameter\n"
    "cv : array_like\n"
    "    Characteristic value\n"
    "x : array_like\n"
    "    Real parameter (``|x| < 1.0``)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : scalar or ndarray\n"
    "    Value of the function\n"
    "sp : scalar or ndarray\n"
    "    Value of the derivative vs x")
ufunc_pro_ang1_cv_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_fffff_ff
ufunc_pro_ang1_cv_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_ddddd_dd
ufunc_pro_ang1_cv_types[0] = <char>NPY_FLOAT
ufunc_pro_ang1_cv_types[1] = <char>NPY_FLOAT
ufunc_pro_ang1_cv_types[2] = <char>NPY_FLOAT
ufunc_pro_ang1_cv_types[3] = <char>NPY_FLOAT
ufunc_pro_ang1_cv_types[4] = <char>NPY_FLOAT
ufunc_pro_ang1_cv_types[5] = <char>NPY_FLOAT
ufunc_pro_ang1_cv_types[6] = <char>NPY_FLOAT
ufunc_pro_ang1_cv_types[7] = <char>NPY_DOUBLE
ufunc_pro_ang1_cv_types[8] = <char>NPY_DOUBLE
ufunc_pro_ang1_cv_types[9] = <char>NPY_DOUBLE
ufunc_pro_ang1_cv_types[10] = <char>NPY_DOUBLE
ufunc_pro_ang1_cv_types[11] = <char>NPY_DOUBLE
ufunc_pro_ang1_cv_types[12] = <char>NPY_DOUBLE
ufunc_pro_ang1_cv_types[13] = <char>NPY_DOUBLE
ufunc_pro_ang1_cv_ptr[2*0] = <void*>_func_prolate_aswfa_wrap
ufunc_pro_ang1_cv_ptr[2*0+1] = <void*>(<char*>"pro_ang1_cv")
ufunc_pro_ang1_cv_ptr[2*1] = <void*>_func_prolate_aswfa_wrap
ufunc_pro_ang1_cv_ptr[2*1+1] = <void*>(<char*>"pro_ang1_cv")
ufunc_pro_ang1_cv_data[0] = &ufunc_pro_ang1_cv_ptr[2*0]
ufunc_pro_ang1_cv_data[1] = &ufunc_pro_ang1_cv_ptr[2*1]
pro_ang1_cv = np.PyUFunc_FromFuncAndData(ufunc_pro_ang1_cv_loops, ufunc_pro_ang1_cv_data, ufunc_pro_ang1_cv_types, 2, 5, 2, 0, "pro_ang1_cv", ufunc_pro_ang1_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pro_cv_loops[2]
cdef void *ufunc_pro_cv_ptr[4]
cdef void *ufunc_pro_cv_data[2]
cdef char ufunc_pro_cv_types[8]
cdef char *ufunc_pro_cv_doc = (
    "pro_cv(m, n, c, out=None)\n"
    "\n"
    "Characteristic value of prolate spheroidal function\n"
    "\n"
    "Computes the characteristic value of prolate spheroidal wave\n"
    "functions of order `m`, `n` (n>=m) and spheroidal parameter `c`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Nonnegative mode parameter m\n"
    "n : array_like\n"
    "    Mode parameter n (>= m)\n"
    "c : array_like\n"
    "    Spheroidal parameter\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "cv : scalar or ndarray\n"
    "    Characteristic value")
ufunc_pro_cv_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_pro_cv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_pro_cv_types[0] = <char>NPY_FLOAT
ufunc_pro_cv_types[1] = <char>NPY_FLOAT
ufunc_pro_cv_types[2] = <char>NPY_FLOAT
ufunc_pro_cv_types[3] = <char>NPY_FLOAT
ufunc_pro_cv_types[4] = <char>NPY_DOUBLE
ufunc_pro_cv_types[5] = <char>NPY_DOUBLE
ufunc_pro_cv_types[6] = <char>NPY_DOUBLE
ufunc_pro_cv_types[7] = <char>NPY_DOUBLE
ufunc_pro_cv_ptr[2*0] = <void*>_func_prolate_segv_wrap
ufunc_pro_cv_ptr[2*0+1] = <void*>(<char*>"pro_cv")
ufunc_pro_cv_ptr[2*1] = <void*>_func_prolate_segv_wrap
ufunc_pro_cv_ptr[2*1+1] = <void*>(<char*>"pro_cv")
ufunc_pro_cv_data[0] = &ufunc_pro_cv_ptr[2*0]
ufunc_pro_cv_data[1] = &ufunc_pro_cv_ptr[2*1]
pro_cv = np.PyUFunc_FromFuncAndData(ufunc_pro_cv_loops, ufunc_pro_cv_data, ufunc_pro_cv_types, 2, 3, 1, 0, "pro_cv", ufunc_pro_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pro_rad1_loops[2]
cdef void *ufunc_pro_rad1_ptr[4]
cdef void *ufunc_pro_rad1_data[2]
cdef char ufunc_pro_rad1_types[12]
cdef char *ufunc_pro_rad1_doc = (
    "pro_rad1(m, n, c, x, out=None)\n"
    "\n"
    "Prolate spheroidal radial function of the first kind and its derivative\n"
    "\n"
    "Computes the prolate spheroidal radial function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Nonnegative mode parameter m\n"
    "n : array_like\n"
    "    Mode parameter n (>= m)\n"
    "c : array_like\n"
    "    Spheroidal parameter\n"
    "x : array_like\n"
    "    Real parameter (``|x| < 1.0``)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : scalar or ndarray\n"
    "    Value of the function\n"
    "sp : scalar or ndarray\n"
    "    Value of the derivative vs x")
ufunc_pro_rad1_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_pro_rad1_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_pro_rad1_types[0] = <char>NPY_FLOAT
ufunc_pro_rad1_types[1] = <char>NPY_FLOAT
ufunc_pro_rad1_types[2] = <char>NPY_FLOAT
ufunc_pro_rad1_types[3] = <char>NPY_FLOAT
ufunc_pro_rad1_types[4] = <char>NPY_FLOAT
ufunc_pro_rad1_types[5] = <char>NPY_FLOAT
ufunc_pro_rad1_types[6] = <char>NPY_DOUBLE
ufunc_pro_rad1_types[7] = <char>NPY_DOUBLE
ufunc_pro_rad1_types[8] = <char>NPY_DOUBLE
ufunc_pro_rad1_types[9] = <char>NPY_DOUBLE
ufunc_pro_rad1_types[10] = <char>NPY_DOUBLE
ufunc_pro_rad1_types[11] = <char>NPY_DOUBLE
ufunc_pro_rad1_ptr[2*0] = <void*>_func_prolate_radial1_nocv_wrap
ufunc_pro_rad1_ptr[2*0+1] = <void*>(<char*>"pro_rad1")
ufunc_pro_rad1_ptr[2*1] = <void*>_func_prolate_radial1_nocv_wrap
ufunc_pro_rad1_ptr[2*1+1] = <void*>(<char*>"pro_rad1")
ufunc_pro_rad1_data[0] = &ufunc_pro_rad1_ptr[2*0]
ufunc_pro_rad1_data[1] = &ufunc_pro_rad1_ptr[2*1]
pro_rad1 = np.PyUFunc_FromFuncAndData(ufunc_pro_rad1_loops, ufunc_pro_rad1_data, ufunc_pro_rad1_types, 2, 4, 2, 0, "pro_rad1", ufunc_pro_rad1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pro_rad1_cv_loops[2]
cdef void *ufunc_pro_rad1_cv_ptr[4]
cdef void *ufunc_pro_rad1_cv_data[2]
cdef char ufunc_pro_rad1_cv_types[14]
cdef char *ufunc_pro_rad1_cv_doc = (
    "pro_rad1_cv(m, n, c, cv, x, out=None)\n"
    "\n"
    "Prolate spheroidal radial function pro_rad1 for precomputed characteristic value\n"
    "\n"
    "Computes the prolate spheroidal radial function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``. Requires\n"
    "pre-computed characteristic value.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Nonnegative mode parameter m\n"
    "n : array_like\n"
    "    Mode parameter n (>= m)\n"
    "c : array_like\n"
    "    Spheroidal parameter\n"
    "cv : array_like\n"
    "    Characteristic value\n"
    "x : array_like\n"
    "    Real parameter (``|x| < 1.0``)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : scalar or ndarray\n"
    "    Value of the function\n"
    "sp : scalar or ndarray\n"
    "    Value of the derivative vs x")
ufunc_pro_rad1_cv_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_fffff_ff
ufunc_pro_rad1_cv_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_ddddd_dd
ufunc_pro_rad1_cv_types[0] = <char>NPY_FLOAT
ufunc_pro_rad1_cv_types[1] = <char>NPY_FLOAT
ufunc_pro_rad1_cv_types[2] = <char>NPY_FLOAT
ufunc_pro_rad1_cv_types[3] = <char>NPY_FLOAT
ufunc_pro_rad1_cv_types[4] = <char>NPY_FLOAT
ufunc_pro_rad1_cv_types[5] = <char>NPY_FLOAT
ufunc_pro_rad1_cv_types[6] = <char>NPY_FLOAT
ufunc_pro_rad1_cv_types[7] = <char>NPY_DOUBLE
ufunc_pro_rad1_cv_types[8] = <char>NPY_DOUBLE
ufunc_pro_rad1_cv_types[9] = <char>NPY_DOUBLE
ufunc_pro_rad1_cv_types[10] = <char>NPY_DOUBLE
ufunc_pro_rad1_cv_types[11] = <char>NPY_DOUBLE
ufunc_pro_rad1_cv_types[12] = <char>NPY_DOUBLE
ufunc_pro_rad1_cv_types[13] = <char>NPY_DOUBLE
ufunc_pro_rad1_cv_ptr[2*0] = <void*>_func_prolate_radial1_wrap
ufunc_pro_rad1_cv_ptr[2*0+1] = <void*>(<char*>"pro_rad1_cv")
ufunc_pro_rad1_cv_ptr[2*1] = <void*>_func_prolate_radial1_wrap
ufunc_pro_rad1_cv_ptr[2*1+1] = <void*>(<char*>"pro_rad1_cv")
ufunc_pro_rad1_cv_data[0] = &ufunc_pro_rad1_cv_ptr[2*0]
ufunc_pro_rad1_cv_data[1] = &ufunc_pro_rad1_cv_ptr[2*1]
pro_rad1_cv = np.PyUFunc_FromFuncAndData(ufunc_pro_rad1_cv_loops, ufunc_pro_rad1_cv_data, ufunc_pro_rad1_cv_types, 2, 5, 2, 0, "pro_rad1_cv", ufunc_pro_rad1_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pro_rad2_loops[2]
cdef void *ufunc_pro_rad2_ptr[4]
cdef void *ufunc_pro_rad2_data[2]
cdef char ufunc_pro_rad2_types[12]
cdef char *ufunc_pro_rad2_doc = (
    "pro_rad2(m, n, c, x, out=None)\n"
    "\n"
    "Prolate spheroidal radial function of the second kind and its derivative\n"
    "\n"
    "Computes the prolate spheroidal radial function of the second kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Nonnegative mode parameter m\n"
    "n : array_like\n"
    "    Mode parameter n (>= m)\n"
    "c : array_like\n"
    "    Spheroidal parameter\n"
    "cv : array_like\n"
    "    Characteristic value\n"
    "x : array_like\n"
    "    Real parameter (``|x| < 1.0``)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : scalar or ndarray\n"
    "    Value of the function\n"
    "sp : scalar or ndarray\n"
    "    Value of the derivative vs x")
ufunc_pro_rad2_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_pro_rad2_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_pro_rad2_types[0] = <char>NPY_FLOAT
ufunc_pro_rad2_types[1] = <char>NPY_FLOAT
ufunc_pro_rad2_types[2] = <char>NPY_FLOAT
ufunc_pro_rad2_types[3] = <char>NPY_FLOAT
ufunc_pro_rad2_types[4] = <char>NPY_FLOAT
ufunc_pro_rad2_types[5] = <char>NPY_FLOAT
ufunc_pro_rad2_types[6] = <char>NPY_DOUBLE
ufunc_pro_rad2_types[7] = <char>NPY_DOUBLE
ufunc_pro_rad2_types[8] = <char>NPY_DOUBLE
ufunc_pro_rad2_types[9] = <char>NPY_DOUBLE
ufunc_pro_rad2_types[10] = <char>NPY_DOUBLE
ufunc_pro_rad2_types[11] = <char>NPY_DOUBLE
ufunc_pro_rad2_ptr[2*0] = <void*>_func_prolate_radial2_nocv_wrap
ufunc_pro_rad2_ptr[2*0+1] = <void*>(<char*>"pro_rad2")
ufunc_pro_rad2_ptr[2*1] = <void*>_func_prolate_radial2_nocv_wrap
ufunc_pro_rad2_ptr[2*1+1] = <void*>(<char*>"pro_rad2")
ufunc_pro_rad2_data[0] = &ufunc_pro_rad2_ptr[2*0]
ufunc_pro_rad2_data[1] = &ufunc_pro_rad2_ptr[2*1]
pro_rad2 = np.PyUFunc_FromFuncAndData(ufunc_pro_rad2_loops, ufunc_pro_rad2_data, ufunc_pro_rad2_types, 2, 4, 2, 0, "pro_rad2", ufunc_pro_rad2_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pro_rad2_cv_loops[2]
cdef void *ufunc_pro_rad2_cv_ptr[4]
cdef void *ufunc_pro_rad2_cv_data[2]
cdef char ufunc_pro_rad2_cv_types[14]
cdef char *ufunc_pro_rad2_cv_doc = (
    "pro_rad2_cv(m, n, c, cv, x, out=None)\n"
    "\n"
    "Prolate spheroidal radial function pro_rad2 for precomputed characteristic value\n"
    "\n"
    "Computes the prolate spheroidal radial function of the second kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``. Requires\n"
    "pre-computed characteristic value.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Nonnegative mode parameter m\n"
    "n : array_like\n"
    "    Mode parameter n (>= m)\n"
    "c : array_like\n"
    "    Spheroidal parameter\n"
    "cv : array_like\n"
    "    Characteristic value\n"
    "x : array_like\n"
    "    Real parameter (``|x| < 1.0``)\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : scalar or ndarray\n"
    "    Value of the function\n"
    "sp : scalar or ndarray\n"
    "    Value of the derivative vs x")
ufunc_pro_rad2_cv_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_fffff_ff
ufunc_pro_rad2_cv_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_ddddd_dd
ufunc_pro_rad2_cv_types[0] = <char>NPY_FLOAT
ufunc_pro_rad2_cv_types[1] = <char>NPY_FLOAT
ufunc_pro_rad2_cv_types[2] = <char>NPY_FLOAT
ufunc_pro_rad2_cv_types[3] = <char>NPY_FLOAT
ufunc_pro_rad2_cv_types[4] = <char>NPY_FLOAT
ufunc_pro_rad2_cv_types[5] = <char>NPY_FLOAT
ufunc_pro_rad2_cv_types[6] = <char>NPY_FLOAT
ufunc_pro_rad2_cv_types[7] = <char>NPY_DOUBLE
ufunc_pro_rad2_cv_types[8] = <char>NPY_DOUBLE
ufunc_pro_rad2_cv_types[9] = <char>NPY_DOUBLE
ufunc_pro_rad2_cv_types[10] = <char>NPY_DOUBLE
ufunc_pro_rad2_cv_types[11] = <char>NPY_DOUBLE
ufunc_pro_rad2_cv_types[12] = <char>NPY_DOUBLE
ufunc_pro_rad2_cv_types[13] = <char>NPY_DOUBLE
ufunc_pro_rad2_cv_ptr[2*0] = <void*>_func_prolate_radial2_wrap
ufunc_pro_rad2_cv_ptr[2*0+1] = <void*>(<char*>"pro_rad2_cv")
ufunc_pro_rad2_cv_ptr[2*1] = <void*>_func_prolate_radial2_wrap
ufunc_pro_rad2_cv_ptr[2*1+1] = <void*>(<char*>"pro_rad2_cv")
ufunc_pro_rad2_cv_data[0] = &ufunc_pro_rad2_cv_ptr[2*0]
ufunc_pro_rad2_cv_data[1] = &ufunc_pro_rad2_cv_ptr[2*1]
pro_rad2_cv = np.PyUFunc_FromFuncAndData(ufunc_pro_rad2_cv_loops, ufunc_pro_rad2_cv_data, ufunc_pro_rad2_cv_types, 2, 5, 2, 0, "pro_rad2_cv", ufunc_pro_rad2_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pseudo_huber_loops[2]
cdef void *ufunc_pseudo_huber_ptr[4]
cdef void *ufunc_pseudo_huber_data[2]
cdef char ufunc_pseudo_huber_types[6]
cdef char *ufunc_pseudo_huber_doc = (
    "pseudo_huber(delta, r, out=None)\n"
    "\n"
    "Pseudo-Huber loss function.\n"
    "\n"
    ".. math:: \\mathrm{pseudo\\_huber}(\\delta, r) =\n"
    "          \\delta^2 \\left( \\sqrt{ 1 + \\left( \\frac{r}{\\delta} \\right)^2 } - 1 \\right)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "delta : array_like\n"
    "    Input array, indicating the soft quadratic vs. linear loss changepoint.\n"
    "r : array_like\n"
    "    Input array, possibly representing residuals.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "res : scalar or ndarray\n"
    "    The computed Pseudo-Huber loss function values.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "huber: Similar function which this function approximates\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Like `huber`, `pseudo_huber` often serves as a robust loss function\n"
    "in statistics or machine learning to reduce the influence of outliers.\n"
    "Unlike `huber`, `pseudo_huber` is smooth.\n"
    "\n"
    "Typically, `r` represents residuals, the difference\n"
    "between a model prediction and data. Then, for :math:`|r|\\leq\\delta`,\n"
    "`pseudo_huber` resembles the squared error and for :math:`|r|>\\delta` the\n"
    "absolute error. This way, the Pseudo-Huber loss often achieves\n"
    "a fast convergence in model fitting for small residuals like the squared\n"
    "error loss function and still reduces the influence of outliers\n"
    "(:math:`|r|>\\delta`) like the absolute error loss. As :math:`\\delta` is\n"
    "the cutoff between squared and absolute error regimes, it has\n"
    "to be tuned carefully for each problem. `pseudo_huber` is also\n"
    "convex, making it suitable for gradient based optimization. [1]_ [2]_\n"
    "\n"
    ".. versionadded:: 0.15.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Hartley, Zisserman, \"Multiple View Geometry in Computer Vision\".\n"
    "       2003. Cambridge University Press. p. 619\n"
    ".. [2] Charbonnier et al. \"Deterministic edge-preserving regularization\n"
    "       in computed imaging\". 1997. IEEE Trans. Image Processing.\n"
    "       6 (2): 298 - 311.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Import all necessary modules.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import pseudo_huber, huber\n"
    ">>> import matplotlib.pyplot as plt\n"
    "\n"
    "Calculate the function for ``delta=1`` at ``r=2``.\n"
    "\n"
    ">>> pseudo_huber(1., 2.)\n"
    "1.2360679774997898\n"
    "\n"
    "Calculate the function at ``r=2`` for different `delta` by providing\n"
    "a list or NumPy array for `delta`.\n"
    "\n"
    ">>> pseudo_huber([1., 2., 4.], 3.)\n"
    "array([2.16227766, 3.21110255, 4.        ])\n"
    "\n"
    "Calculate the function for ``delta=1`` at several points by providing\n"
    "a list or NumPy array for `r`.\n"
    "\n"
    ">>> pseudo_huber(2., np.array([1., 1.5, 3., 4.]))\n"
    "array([0.47213595, 1.        , 3.21110255, 4.94427191])\n"
    "\n"
    "The function can be calculated for different `delta` and `r` by\n"
    "providing arrays for both with compatible shapes for broadcasting.\n"
    "\n"
    ">>> r = np.array([1., 2.5, 8., 10.])\n"
    ">>> deltas = np.array([[1.], [5.], [9.]])\n"
    ">>> print(r.shape, deltas.shape)\n"
    "(4,) (3, 1)\n"
    "\n"
    ">>> pseudo_huber(deltas, r)\n"
    "array([[ 0.41421356,  1.6925824 ,  7.06225775,  9.04987562],\n"
    "       [ 0.49509757,  2.95084972, 22.16990566, 30.90169944],\n"
    "       [ 0.49846624,  3.06693762, 27.37435121, 40.08261642]])\n"
    "\n"
    "Plot the function for different `delta`.\n"
    "\n"
    ">>> x = np.linspace(-4, 4, 500)\n"
    ">>> deltas = [1, 2, 3]\n"
    ">>> linestyles = [\"dashed\", \"dotted\", \"dashdot\"]\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> combined_plot_parameters = list(zip(deltas, linestyles))\n"
    ">>> for delta, style in combined_plot_parameters:\n"
    "...     ax.plot(x, pseudo_huber(delta, x), label=f\"$\\delta={delta}$\",\n"
    "...             ls=style)\n"
    ">>> ax.legend(loc=\"upper center\")\n"
    ">>> ax.set_xlabel(\"$x$\")\n"
    ">>> ax.set_title(\"Pseudo-Huber loss function $h_{\\delta}(x)$\")\n"
    ">>> ax.set_xlim(-4, 4)\n"
    ">>> ax.set_ylim(0, 8)\n"
    ">>> plt.show()\n"
    "\n"
    "Finally, illustrate the difference between `huber` and `pseudo_huber` by\n"
    "plotting them and their gradients with respect to `r`. The plot shows\n"
    "that `pseudo_huber` is continuously differentiable while `huber` is not\n"
    "at the points :math:`\\pm\\delta`.\n"
    "\n"
    ">>> def huber_grad(delta, x):\n"
    "...     grad = np.copy(x)\n"
    "...     linear_area = np.argwhere(np.abs(x) > delta)\n"
    "...     grad[linear_area]=delta*np.sign(x[linear_area])\n"
    "...     return grad\n"
    ">>> def pseudo_huber_grad(delta, x):\n"
    "...     return x* (1+(x/delta)**2)**(-0.5)\n"
    ">>> x=np.linspace(-3, 3, 500)\n"
    ">>> delta = 1.\n"
    ">>> fig, ax = plt.subplots(figsize=(7, 7))\n"
    ">>> ax.plot(x, huber(delta, x), label=\"Huber\", ls=\"dashed\")\n"
    ">>> ax.plot(x, huber_grad(delta, x), label=\"Huber Gradient\", ls=\"dashdot\")\n"
    ">>> ax.plot(x, pseudo_huber(delta, x), label=\"Pseudo-Huber\", ls=\"dotted\")\n"
    ">>> ax.plot(x, pseudo_huber_grad(delta, x), label=\"Pseudo-Huber Gradient\",\n"
    "...         ls=\"solid\")\n"
    ">>> ax.legend(loc=\"upper center\")\n"
    ">>> plt.show()")
ufunc_pseudo_huber_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pseudo_huber_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pseudo_huber_types[0] = <char>NPY_FLOAT
ufunc_pseudo_huber_types[1] = <char>NPY_FLOAT
ufunc_pseudo_huber_types[2] = <char>NPY_FLOAT
ufunc_pseudo_huber_types[3] = <char>NPY_DOUBLE
ufunc_pseudo_huber_types[4] = <char>NPY_DOUBLE
ufunc_pseudo_huber_types[5] = <char>NPY_DOUBLE
ufunc_pseudo_huber_ptr[2*0] = <void*>_func_pseudo_huber
ufunc_pseudo_huber_ptr[2*0+1] = <void*>(<char*>"pseudo_huber")
ufunc_pseudo_huber_ptr[2*1] = <void*>_func_pseudo_huber
ufunc_pseudo_huber_ptr[2*1+1] = <void*>(<char*>"pseudo_huber")
ufunc_pseudo_huber_data[0] = &ufunc_pseudo_huber_ptr[2*0]
ufunc_pseudo_huber_data[1] = &ufunc_pseudo_huber_ptr[2*1]
pseudo_huber = np.PyUFunc_FromFuncAndData(ufunc_pseudo_huber_loops, ufunc_pseudo_huber_data, ufunc_pseudo_huber_types, 2, 2, 1, 0, "pseudo_huber", ufunc_pseudo_huber_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_psi_loops[4]
cdef void *ufunc_psi_ptr[8]
cdef void *ufunc_psi_data[4]
cdef char ufunc_psi_types[8]
cdef char *ufunc_psi_doc = (
    "psi(z, out=None)\n"
    "\n"
    "The digamma function.\n"
    "\n"
    "The logarithmic derivative of the gamma function evaluated at ``z``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Real or complex argument.\n"
    "out : ndarray, optional\n"
    "    Array for the computed values of ``psi``.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "digamma : scalar or ndarray\n"
    "    Computed values of ``psi``.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For large values not close to the negative real axis, ``psi`` is\n"
    "computed using the asymptotic series (5.11.2) from [1]_. For small\n"
    "arguments not close to the negative real axis, the recurrence\n"
    "relation (5.5.2) from [1]_ is used until the argument is large\n"
    "enough to use the asymptotic series. For values close to the\n"
    "negative real axis, the reflection formula (5.5.4) from [1]_ is\n"
    "used first. Note that ``psi`` has a family of zeros on the\n"
    "negative real axis which occur between the poles at nonpositive\n"
    "integers. Around the zeros the reflection formula suffers from\n"
    "cancellation and the implementation loses precision. The sole\n"
    "positive zero and the first negative zero, however, are handled\n"
    "separately by precomputing series expansions using [2]_, so the\n"
    "function should maintain full accuracy around the origin.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/5\n"
    ".. [2] Fredrik Johansson and others.\n"
    "       \"mpmath: a Python library for arbitrary-precision floating-point arithmetic\"\n"
    "       (Version 0.19) http://mpmath.org/\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import psi\n"
    ">>> z = 3 + 4j\n"
    ">>> psi(z)\n"
    "(1.55035981733341+1.0105022091860445j)\n"
    "\n"
    "Verify psi(z) = psi(z + 1) - 1/z:\n"
    "\n"
    ">>> psi(z + 1) - 1/z\n"
    "(1.55035981733341+1.0105022091860445j)")
ufunc_psi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_psi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_psi_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_psi_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_psi_types[0] = <char>NPY_FLOAT
ufunc_psi_types[1] = <char>NPY_FLOAT
ufunc_psi_types[2] = <char>NPY_DOUBLE
ufunc_psi_types[3] = <char>NPY_DOUBLE
ufunc_psi_types[4] = <char>NPY_CFLOAT
ufunc_psi_types[5] = <char>NPY_CFLOAT
ufunc_psi_types[6] = <char>NPY_CDOUBLE
ufunc_psi_types[7] = <char>NPY_CDOUBLE
ufunc_psi_ptr[2*0] = <void*>_func_digamma
ufunc_psi_ptr[2*0+1] = <void*>(<char*>"psi")
ufunc_psi_ptr[2*1] = <void*>_func_digamma
ufunc_psi_ptr[2*1+1] = <void*>(<char*>"psi")
ufunc_psi_ptr[2*2] = <void*>_func_cdigamma
ufunc_psi_ptr[2*2+1] = <void*>(<char*>"psi")
ufunc_psi_ptr[2*3] = <void*>_func_cdigamma
ufunc_psi_ptr[2*3+1] = <void*>(<char*>"psi")
ufunc_psi_data[0] = &ufunc_psi_ptr[2*0]
ufunc_psi_data[1] = &ufunc_psi_ptr[2*1]
ufunc_psi_data[2] = &ufunc_psi_ptr[2*2]
ufunc_psi_data[3] = &ufunc_psi_ptr[2*3]
psi = np.PyUFunc_FromFuncAndData(ufunc_psi_loops, ufunc_psi_data, ufunc_psi_types, 4, 1, 1, 0, "psi", ufunc_psi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_radian_loops[2]
cdef void *ufunc_radian_ptr[4]
cdef void *ufunc_radian_data[2]
cdef char ufunc_radian_types[8]
cdef char *ufunc_radian_doc = (
    "radian(d, m, s, out=None)\n"
    "\n"
    "Convert from degrees to radians.\n"
    "\n"
    "Returns the angle given in (d)egrees, (m)inutes, and (s)econds in\n"
    "radians.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "d : array_like\n"
    "    Degrees, can be real-valued.\n"
    "m : array_like\n"
    "    Minutes, can be real-valued.\n"
    "s : array_like\n"
    "    Seconds, can be real-valued.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the inputs in radians.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "There are many ways to specify an angle.\n"
    "\n"
    ">>> sc.radian(90, 0, 0)\n"
    "1.5707963267948966\n"
    ">>> sc.radian(0, 60 * 90, 0)\n"
    "1.5707963267948966\n"
    ">>> sc.radian(0, 0, 60**2 * 90)\n"
    "1.5707963267948966\n"
    "\n"
    "The inputs can be real-valued.\n"
    "\n"
    ">>> sc.radian(1.5, 0, 0)\n"
    "0.02617993877991494\n"
    ">>> sc.radian(1, 30, 0)\n"
    "0.02617993877991494")
ufunc_radian_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_radian_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_radian_types[0] = <char>NPY_FLOAT
ufunc_radian_types[1] = <char>NPY_FLOAT
ufunc_radian_types[2] = <char>NPY_FLOAT
ufunc_radian_types[3] = <char>NPY_FLOAT
ufunc_radian_types[4] = <char>NPY_DOUBLE
ufunc_radian_types[5] = <char>NPY_DOUBLE
ufunc_radian_types[6] = <char>NPY_DOUBLE
ufunc_radian_types[7] = <char>NPY_DOUBLE
ufunc_radian_ptr[2*0] = <void*>_func_radian
ufunc_radian_ptr[2*0+1] = <void*>(<char*>"radian")
ufunc_radian_ptr[2*1] = <void*>_func_radian
ufunc_radian_ptr[2*1+1] = <void*>(<char*>"radian")
ufunc_radian_data[0] = &ufunc_radian_ptr[2*0]
ufunc_radian_data[1] = &ufunc_radian_ptr[2*1]
radian = np.PyUFunc_FromFuncAndData(ufunc_radian_loops, ufunc_radian_data, ufunc_radian_types, 2, 3, 1, 0, "radian", ufunc_radian_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_rel_entr_loops[2]
cdef void *ufunc_rel_entr_ptr[4]
cdef void *ufunc_rel_entr_data[2]
cdef char ufunc_rel_entr_types[6]
cdef char *ufunc_rel_entr_doc = (
    "rel_entr(x, y, out=None)\n"
    "\n"
    "Elementwise function for computing relative entropy.\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\mathrm{rel\\_entr}(x, y) =\n"
    "        \\begin{cases}\n"
    "            x \\log(x / y) & x > 0, y > 0 \\\\\n"
    "            0 & x = 0, y \\ge 0 \\\\\n"
    "            \\infty & \\text{otherwise}\n"
    "        \\end{cases}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, y : array_like\n"
    "    Input arrays\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Relative entropy of the inputs\n"
    "\n"
    "See Also\n"
    "--------\n"
    "entr, kl_div, scipy.stats.entropy\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 0.15.0\n"
    "\n"
    "This function is jointly convex in x and y.\n"
    "\n"
    "The origin of this function is in convex programming; see\n"
    "[1]_. Given two discrete probability distributions :math:`p_1,\n"
    "\\ldots, p_n` and :math:`q_1, \\ldots, q_n`, the definition of relative\n"
    "entropy in the context of *information theory* is\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\sum_{i = 1}^n \\mathrm{rel\\_entr}(p_i, q_i).\n"
    "\n"
    "To compute the latter quantity, use `scipy.stats.entropy`.\n"
    "\n"
    "See [2]_ for details.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Boyd, Stephen and Lieven Vandenberghe. *Convex optimization*.\n"
    "       Cambridge University Press, 2004.\n"
    "       :doi:`https://doi.org/10.1017/CBO9780511804441`\n"
    ".. [2] Kullback-Leibler divergence,\n"
    "       https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence")
ufunc_rel_entr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_rel_entr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_rel_entr_types[0] = <char>NPY_FLOAT
ufunc_rel_entr_types[1] = <char>NPY_FLOAT
ufunc_rel_entr_types[2] = <char>NPY_FLOAT
ufunc_rel_entr_types[3] = <char>NPY_DOUBLE
ufunc_rel_entr_types[4] = <char>NPY_DOUBLE
ufunc_rel_entr_types[5] = <char>NPY_DOUBLE
ufunc_rel_entr_ptr[2*0] = <void*>_func_rel_entr
ufunc_rel_entr_ptr[2*0+1] = <void*>(<char*>"rel_entr")
ufunc_rel_entr_ptr[2*1] = <void*>_func_rel_entr
ufunc_rel_entr_ptr[2*1+1] = <void*>(<char*>"rel_entr")
ufunc_rel_entr_data[0] = &ufunc_rel_entr_ptr[2*0]
ufunc_rel_entr_data[1] = &ufunc_rel_entr_ptr[2*1]
rel_entr = np.PyUFunc_FromFuncAndData(ufunc_rel_entr_loops, ufunc_rel_entr_data, ufunc_rel_entr_types, 2, 2, 1, 0, "rel_entr", ufunc_rel_entr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_rgamma_loops[4]
cdef void *ufunc_rgamma_ptr[8]
cdef void *ufunc_rgamma_data[4]
cdef char ufunc_rgamma_types[8]
cdef char *ufunc_rgamma_doc = (
    "rgamma(z, out=None)\n"
    "\n"
    "Reciprocal of the gamma function.\n"
    "\n"
    "Defined as :math:`1 / \\Gamma(z)`, where :math:`\\Gamma` is the\n"
    "gamma function. For more on the gamma function see `gamma`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Real or complex valued input\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Function results\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gamma, gammaln, loggamma\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The gamma function has no zeros and has simple poles at\n"
    "nonpositive integers, so `rgamma` is an entire function with zeros\n"
    "at the nonpositive integers. See the discussion in [dlmf]_ for\n"
    "more details.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] Nist, Digital Library of Mathematical functions,\n"
    "    https://dlmf.nist.gov/5.2#i\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is the reciprocal of the gamma function.\n"
    "\n"
    ">>> sc.rgamma([1, 2, 3, 4])\n"
    "array([1.        , 1.        , 0.5       , 0.16666667])\n"
    ">>> 1 / sc.gamma([1, 2, 3, 4])\n"
    "array([1.        , 1.        , 0.5       , 0.16666667])\n"
    "\n"
    "It is zero at nonpositive integers.\n"
    "\n"
    ">>> sc.rgamma([0, -1, -2, -3])\n"
    "array([0., 0., 0., 0.])\n"
    "\n"
    "It rapidly underflows to zero along the positive real axis.\n"
    "\n"
    ">>> sc.rgamma([10, 100, 179])\n"
    "array([2.75573192e-006, 1.07151029e-156, 0.00000000e+000])")
ufunc_rgamma_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_rgamma_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_rgamma_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_rgamma_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_rgamma_types[0] = <char>NPY_FLOAT
ufunc_rgamma_types[1] = <char>NPY_FLOAT
ufunc_rgamma_types[2] = <char>NPY_DOUBLE
ufunc_rgamma_types[3] = <char>NPY_DOUBLE
ufunc_rgamma_types[4] = <char>NPY_CFLOAT
ufunc_rgamma_types[5] = <char>NPY_CFLOAT
ufunc_rgamma_types[6] = <char>NPY_CDOUBLE
ufunc_rgamma_types[7] = <char>NPY_CDOUBLE
ufunc_rgamma_ptr[2*0] = <void*>_func_rgamma
ufunc_rgamma_ptr[2*0+1] = <void*>(<char*>"rgamma")
ufunc_rgamma_ptr[2*1] = <void*>_func_rgamma
ufunc_rgamma_ptr[2*1+1] = <void*>(<char*>"rgamma")
ufunc_rgamma_ptr[2*2] = <void*>_func_crgamma
ufunc_rgamma_ptr[2*2+1] = <void*>(<char*>"rgamma")
ufunc_rgamma_ptr[2*3] = <void*>_func_crgamma
ufunc_rgamma_ptr[2*3+1] = <void*>(<char*>"rgamma")
ufunc_rgamma_data[0] = &ufunc_rgamma_ptr[2*0]
ufunc_rgamma_data[1] = &ufunc_rgamma_ptr[2*1]
ufunc_rgamma_data[2] = &ufunc_rgamma_ptr[2*2]
ufunc_rgamma_data[3] = &ufunc_rgamma_ptr[2*3]
rgamma = np.PyUFunc_FromFuncAndData(ufunc_rgamma_loops, ufunc_rgamma_data, ufunc_rgamma_types, 4, 1, 1, 0, "rgamma", ufunc_rgamma_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_round_loops[2]
cdef void *ufunc_round_ptr[4]
cdef void *ufunc_round_data[2]
cdef char ufunc_round_types[4]
cdef char *ufunc_round_doc = (
    "round(x, out=None)\n"
    "\n"
    "Round to the nearest integer.\n"
    "\n"
    "Returns the nearest integer to `x`.  If `x` ends in 0.5 exactly,\n"
    "the nearest even integer is chosen.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real valued input.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The nearest integers to the elements of `x`. The result is of\n"
    "    floating type, not integer type.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It rounds to even.\n"
    "\n"
    ">>> sc.round([0.5, 1.5])\n"
    "array([0., 2.])")
ufunc_round_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_round_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_round_types[0] = <char>NPY_FLOAT
ufunc_round_types[1] = <char>NPY_FLOAT
ufunc_round_types[2] = <char>NPY_DOUBLE
ufunc_round_types[3] = <char>NPY_DOUBLE
ufunc_round_ptr[2*0] = <void*>_func_round
ufunc_round_ptr[2*0+1] = <void*>(<char*>"round")
ufunc_round_ptr[2*1] = <void*>_func_round
ufunc_round_ptr[2*1+1] = <void*>(<char*>"round")
ufunc_round_data[0] = &ufunc_round_ptr[2*0]
ufunc_round_data[1] = &ufunc_round_ptr[2*1]
round = np.PyUFunc_FromFuncAndData(ufunc_round_loops, ufunc_round_data, ufunc_round_types, 2, 1, 1, 0, "round", ufunc_round_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_shichi_loops[4]
cdef void *ufunc_shichi_ptr[8]
cdef void *ufunc_shichi_data[4]
cdef char ufunc_shichi_types[12]
cdef char *ufunc_shichi_doc = (
    "shichi(x, out=None)\n"
    "\n"
    "Hyperbolic sine and cosine integrals.\n"
    "\n"
    "The hyperbolic sine integral is\n"
    "\n"
    ".. math::\n"
    "\n"
    "  \\int_0^x \\frac{\\sinh{t}}{t}dt\n"
    "\n"
    "and the hyperbolic cosine integral is\n"
    "\n"
    ".. math::\n"
    "\n"
    "  \\gamma + \\log(x) + \\int_0^x \\frac{\\cosh{t} - 1}{t} dt\n"
    "\n"
    "where :math:`\\gamma` is Euler's constant and :math:`\\log` is the\n"
    "principal branch of the logarithm [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real or complex points at which to compute the hyperbolic sine\n"
    "    and cosine integrals.\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "si : scalar or ndarray\n"
    "    Hyperbolic sine integral at ``x``\n"
    "ci : scalar or ndarray\n"
    "    Hyperbolic cosine integral at ``x``\n"
    "\n"
    "See Also\n"
    "--------\n"
    "sici : Sine and cosine integrals.\n"
    "exp1 : Exponential integral E1.\n"
    "expi : Exponential integral Ei.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For real arguments with ``x < 0``, ``chi`` is the real part of the\n"
    "hyperbolic cosine integral. For such points ``chi(x)`` and ``chi(x\n"
    "+ 0j)`` differ by a factor of ``1j*pi``.\n"
    "\n"
    "For real arguments the function is computed by calling Cephes'\n"
    "[2]_ *shichi* routine. For complex arguments the algorithm is based\n"
    "on Mpmath's [3]_ *shi* and *chi* routines.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "       (See Section 5.2.)\n"
    ".. [2] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    ".. [3] Fredrik Johansson and others.\n"
    "       \"mpmath: a Python library for arbitrary-precision floating-point\n"
    "       arithmetic\" (Version 0.19) http://mpmath.org/\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> from scipy.special import shichi, sici\n"
    "\n"
    "`shichi` accepts real or complex input:\n"
    "\n"
    ">>> shichi(0.5)\n"
    "(0.5069967498196671, -0.05277684495649357)\n"
    ">>> shichi(0.5 + 2.5j)\n"
    "((0.11772029666668238+1.831091777729851j),\n"
    " (0.29912435887648825+1.7395351121166562j))\n"
    "\n"
    "The hyperbolic sine and cosine integrals Shi(z) and Chi(z) are\n"
    "related to the sine and cosine integrals Si(z) and Ci(z) by\n"
    "\n"
    "* Shi(z) = -i*Si(i*z)\n"
    "* Chi(z) = Ci(-i*z) + i*pi/2\n"
    "\n"
    ">>> z = 0.25 + 5j\n"
    ">>> shi, chi = shichi(z)\n"
    ">>> shi, -1j*sici(1j*z)[0]            # Should be the same.\n"
    "((-0.04834719325101729+1.5469354086921228j),\n"
    " (-0.04834719325101729+1.5469354086921228j))\n"
    ">>> chi, sici(-1j*z)[1] + 1j*np.pi/2  # Should be the same.\n"
    "((-0.19568708973868087+1.556276312103824j),\n"
    " (-0.19568708973868087+1.556276312103824j))\n"
    "\n"
    "Plot the functions evaluated on the real axis:\n"
    "\n"
    ">>> xp = np.geomspace(1e-8, 4.0, 250)\n"
    ">>> x = np.concatenate((-xp[::-1], xp))\n"
    ">>> shi, chi = shichi(x)\n"
    "\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(x, shi, label='Shi(x)')\n"
    ">>> ax.plot(x, chi, '--', label='Chi(x)')\n"
    ">>> ax.set_xlabel('x')\n"
    ">>> ax.set_title('Hyperbolic Sine and Cosine Integrals')\n"
    ">>> ax.legend(shadow=True, framealpha=1, loc='lower right')\n"
    ">>> ax.grid(True)\n"
    ">>> plt.show()")
ufunc_shichi_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_shichi_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_shichi_loops[2] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_F_FF
ufunc_shichi_loops[3] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_D_DD
ufunc_shichi_types[0] = <char>NPY_FLOAT
ufunc_shichi_types[1] = <char>NPY_FLOAT
ufunc_shichi_types[2] = <char>NPY_FLOAT
ufunc_shichi_types[3] = <char>NPY_DOUBLE
ufunc_shichi_types[4] = <char>NPY_DOUBLE
ufunc_shichi_types[5] = <char>NPY_DOUBLE
ufunc_shichi_types[6] = <char>NPY_CFLOAT
ufunc_shichi_types[7] = <char>NPY_CFLOAT
ufunc_shichi_types[8] = <char>NPY_CFLOAT
ufunc_shichi_types[9] = <char>NPY_CDOUBLE
ufunc_shichi_types[10] = <char>NPY_CDOUBLE
ufunc_shichi_types[11] = <char>NPY_CDOUBLE
ufunc_shichi_ptr[2*0] = <void*>_func_shichi
ufunc_shichi_ptr[2*0+1] = <void*>(<char*>"shichi")
ufunc_shichi_ptr[2*1] = <void*>_func_shichi
ufunc_shichi_ptr[2*1+1] = <void*>(<char*>"shichi")
ufunc_shichi_ptr[2*2] = <void*>_func_cshichi
ufunc_shichi_ptr[2*2+1] = <void*>(<char*>"shichi")
ufunc_shichi_ptr[2*3] = <void*>_func_cshichi
ufunc_shichi_ptr[2*3+1] = <void*>(<char*>"shichi")
ufunc_shichi_data[0] = &ufunc_shichi_ptr[2*0]
ufunc_shichi_data[1] = &ufunc_shichi_ptr[2*1]
ufunc_shichi_data[2] = &ufunc_shichi_ptr[2*2]
ufunc_shichi_data[3] = &ufunc_shichi_ptr[2*3]
shichi = np.PyUFunc_FromFuncAndData(ufunc_shichi_loops, ufunc_shichi_data, ufunc_shichi_types, 4, 1, 2, 0, "shichi", ufunc_shichi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_sici_loops[4]
cdef void *ufunc_sici_ptr[8]
cdef void *ufunc_sici_data[4]
cdef char ufunc_sici_types[12]
cdef char *ufunc_sici_doc = (
    "sici(x, out=None)\n"
    "\n"
    "Sine and cosine integrals.\n"
    "\n"
    "The sine integral is\n"
    "\n"
    ".. math::\n"
    "\n"
    "  \\int_0^x \\frac{\\sin{t}}{t}dt\n"
    "\n"
    "and the cosine integral is\n"
    "\n"
    ".. math::\n"
    "\n"
    "  \\gamma + \\log(x) + \\int_0^x \\frac{\\cos{t} - 1}{t}dt\n"
    "\n"
    "where :math:`\\gamma` is Euler's constant and :math:`\\log` is the\n"
    "principal branch of the logarithm [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real or complex points at which to compute the sine and cosine\n"
    "    integrals.\n"
    "out : tuple of ndarray, optional\n"
    "    Optional output arrays for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "si : scalar or ndarray\n"
    "    Sine integral at ``x``\n"
    "ci : scalar or ndarray\n"
    "    Cosine integral at ``x``\n"
    "\n"
    "See Also\n"
    "--------\n"
    "shichi : Hyperbolic sine and cosine integrals.\n"
    "exp1 : Exponential integral E1.\n"
    "expi : Exponential integral Ei.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For real arguments with ``x < 0``, ``ci`` is the real part of the\n"
    "cosine integral. For such points ``ci(x)`` and ``ci(x + 0j)``\n"
    "differ by a factor of ``1j*pi``.\n"
    "\n"
    "For real arguments the function is computed by calling Cephes'\n"
    "[2]_ *sici* routine. For complex arguments the algorithm is based\n"
    "on Mpmath's [3]_ *si* and *ci* routines.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "       (See Section 5.2.)\n"
    ".. [2] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    ".. [3] Fredrik Johansson and others.\n"
    "       \"mpmath: a Python library for arbitrary-precision floating-point\n"
    "       arithmetic\" (Version 0.19) http://mpmath.org/\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> from scipy.special import sici, exp1\n"
    "\n"
    "`sici` accepts real or complex input:\n"
    "\n"
    ">>> sici(2.5)\n"
    "(1.7785201734438267, 0.2858711963653835)\n"
    ">>> sici(2.5 + 3j)\n"
    "((4.505735874563953+0.06863305018999577j),\n"
    "(0.0793644206906966-2.935510262937543j))\n"
    "\n"
    "For z in the right half plane, the sine and cosine integrals are\n"
    "related to the exponential integral E1 (implemented in SciPy as\n"
    "`scipy.special.exp1`) by\n"
    "\n"
    "* Si(z) = (E1(i*z) - E1(-i*z))/2i + pi/2\n"
    "* Ci(z) = -(E1(i*z) + E1(-i*z))/2\n"
    "\n"
    "See [1]_ (equations 5.2.21 and 5.2.23).\n"
    "\n"
    "We can verify these relations:\n"
    "\n"
    ">>> z = 2 - 3j\n"
    ">>> sici(z)\n"
    "((4.54751388956229-1.3991965806460565j),\n"
    "(1.408292501520851+2.9836177420296055j))\n"
    "\n"
    ">>> (exp1(1j*z) - exp1(-1j*z))/2j + np.pi/2  # Same as sine integral\n"
    "(4.54751388956229-1.3991965806460565j)\n"
    "\n"
    ">>> -(exp1(1j*z) + exp1(-1j*z))/2            # Same as cosine integral\n"
    "(1.408292501520851+2.9836177420296055j)\n"
    "\n"
    "Plot the functions evaluated on the real axis; the dotted horizontal\n"
    "lines are at pi/2 and -pi/2:\n"
    "\n"
    ">>> x = np.linspace(-16, 16, 150)\n"
    ">>> si, ci = sici(x)\n"
    "\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> ax.plot(x, si, label='Si(x)')\n"
    ">>> ax.plot(x, ci, '--', label='Ci(x)')\n"
    ">>> ax.legend(shadow=True, framealpha=1, loc='upper left')\n"
    ">>> ax.set_xlabel('x')\n"
    ">>> ax.set_title('Sine and Cosine Integrals')\n"
    ">>> ax.axhline(np.pi/2, linestyle=':', alpha=0.5, color='k')\n"
    ">>> ax.axhline(-np.pi/2, linestyle=':', alpha=0.5, color='k')\n"
    ">>> ax.grid(True)\n"
    ">>> plt.show()")
ufunc_sici_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_sici_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_sici_loops[2] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_F_FF
ufunc_sici_loops[3] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_D_DD
ufunc_sici_types[0] = <char>NPY_FLOAT
ufunc_sici_types[1] = <char>NPY_FLOAT
ufunc_sici_types[2] = <char>NPY_FLOAT
ufunc_sici_types[3] = <char>NPY_DOUBLE
ufunc_sici_types[4] = <char>NPY_DOUBLE
ufunc_sici_types[5] = <char>NPY_DOUBLE
ufunc_sici_types[6] = <char>NPY_CFLOAT
ufunc_sici_types[7] = <char>NPY_CFLOAT
ufunc_sici_types[8] = <char>NPY_CFLOAT
ufunc_sici_types[9] = <char>NPY_CDOUBLE
ufunc_sici_types[10] = <char>NPY_CDOUBLE
ufunc_sici_types[11] = <char>NPY_CDOUBLE
ufunc_sici_ptr[2*0] = <void*>_func_sici
ufunc_sici_ptr[2*0+1] = <void*>(<char*>"sici")
ufunc_sici_ptr[2*1] = <void*>_func_sici
ufunc_sici_ptr[2*1+1] = <void*>(<char*>"sici")
ufunc_sici_ptr[2*2] = <void*>_func_csici
ufunc_sici_ptr[2*2+1] = <void*>(<char*>"sici")
ufunc_sici_ptr[2*3] = <void*>_func_csici
ufunc_sici_ptr[2*3+1] = <void*>(<char*>"sici")
ufunc_sici_data[0] = &ufunc_sici_ptr[2*0]
ufunc_sici_data[1] = &ufunc_sici_ptr[2*1]
ufunc_sici_data[2] = &ufunc_sici_ptr[2*2]
ufunc_sici_data[3] = &ufunc_sici_ptr[2*3]
sici = np.PyUFunc_FromFuncAndData(ufunc_sici_loops, ufunc_sici_data, ufunc_sici_types, 4, 1, 2, 0, "sici", ufunc_sici_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_sindg_loops[2]
cdef void *ufunc_sindg_ptr[4]
cdef void *ufunc_sindg_data[2]
cdef char ufunc_sindg_types[4]
cdef char *ufunc_sindg_doc = (
    "sindg(x, out=None)\n"
    "\n"
    "Sine of the angle `x` given in degrees.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Angle, given in degrees.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Sine at the input.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "cosdg, tandg, cotdg\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is more accurate than using sine directly.\n"
    "\n"
    ">>> x = 180 * np.arange(3)\n"
    ">>> sc.sindg(x)\n"
    "array([ 0., -0.,  0.])\n"
    ">>> np.sin(x * np.pi / 180)\n"
    "array([ 0.0000000e+00,  1.2246468e-16, -2.4492936e-16])")
ufunc_sindg_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_sindg_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_sindg_types[0] = <char>NPY_FLOAT
ufunc_sindg_types[1] = <char>NPY_FLOAT
ufunc_sindg_types[2] = <char>NPY_DOUBLE
ufunc_sindg_types[3] = <char>NPY_DOUBLE
ufunc_sindg_ptr[2*0] = <void*>_func_sindg
ufunc_sindg_ptr[2*0+1] = <void*>(<char*>"sindg")
ufunc_sindg_ptr[2*1] = <void*>_func_sindg
ufunc_sindg_ptr[2*1+1] = <void*>(<char*>"sindg")
ufunc_sindg_data[0] = &ufunc_sindg_ptr[2*0]
ufunc_sindg_data[1] = &ufunc_sindg_ptr[2*1]
sindg = np.PyUFunc_FromFuncAndData(ufunc_sindg_loops, ufunc_sindg_data, ufunc_sindg_types, 2, 1, 1, 0, "sindg", ufunc_sindg_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_smirnov_loops[3]
cdef void *ufunc_smirnov_ptr[6]
cdef void *ufunc_smirnov_data[3]
cdef char ufunc_smirnov_types[9]
cdef char *ufunc_smirnov_doc = (
    "smirnov(n, d, out=None)\n"
    "\n"
    "Kolmogorov-Smirnov complementary cumulative distribution function\n"
    "\n"
    "Returns the exact Kolmogorov-Smirnov complementary cumulative\n"
    "distribution function,(aka the Survival Function) of Dn+ (or Dn-)\n"
    "for a one-sided test of equality between an empirical and a\n"
    "theoretical distribution. It is equal to the probability that the\n"
    "maximum difference between a theoretical distribution and an empirical\n"
    "one based on `n` samples is greater than d.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : int\n"
    "  Number of samples\n"
    "d : float array_like\n"
    "  Deviation between the Empirical CDF (ECDF) and the target CDF.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The value(s) of smirnov(n, d), Prob(Dn+ >= d) (Also Prob(Dn- >= d))\n"
    "\n"
    "See Also\n"
    "--------\n"
    "smirnovi : The Inverse Survival Function for the distribution\n"
    "scipy.stats.ksone : Provides the functionality as a continuous distribution\n"
    "kolmogorov, kolmogi : Functions for the two-sided distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "`smirnov` is used by `stats.kstest` in the application of the\n"
    "Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this\n"
    "function is exposed in `scpy.special`, but the recommended way to achieve\n"
    "the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n"
    "`stats.ksone` distribution.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import smirnov\n"
    ">>> from scipy.stats import norm\n"
    "\n"
    "Show the probability of a gap at least as big as 0, 0.5 and 1.0 for a\n"
    "sample of size 5.\n"
    "\n"
    ">>> smirnov(5, [0, 0.5, 1.0])\n"
    "array([ 1.   ,  0.056,  0.   ])\n"
    "\n"
    "Compare a sample of size 5 against N(0, 1), the standard normal\n"
    "distribution with mean 0 and standard deviation 1.\n"
    "\n"
    "`x` is the sample.\n"
    "\n"
    ">>> x = np.array([-1.392, -0.135, 0.114, 0.190, 1.82])\n"
    "\n"
    ">>> target = norm(0, 1)\n"
    ">>> cdfs = target.cdf(x)\n"
    ">>> cdfs\n"
    "array([0.0819612 , 0.44630594, 0.5453811 , 0.57534543, 0.9656205 ])\n"
    "\n"
    "Construct the empirical CDF and the K-S statistics (Dn+, Dn-, Dn).\n"
    "\n"
    ">>> n = len(x)\n"
    ">>> ecdfs = np.arange(n+1, dtype=float)/n\n"
    ">>> cols = np.column_stack([x, ecdfs[1:], cdfs, cdfs - ecdfs[:n],\n"
    "...                        ecdfs[1:] - cdfs])\n"
    ">>> with np.printoptions(precision=3):\n"
    "...    print(cols)\n"
    "[[-1.392  0.2    0.082  0.082  0.118]\n"
    " [-0.135  0.4    0.446  0.246 -0.046]\n"
    " [ 0.114  0.6    0.545  0.145  0.055]\n"
    " [ 0.19   0.8    0.575 -0.025  0.225]\n"
    " [ 1.82   1.     0.966  0.166  0.034]]\n"
    ">>> gaps = cols[:, -2:]\n"
    ">>> Dnpm = np.max(gaps, axis=0)\n"
    ">>> print(f'Dn-={Dnpm[0]:f}, Dn+={Dnpm[1]:f}')\n"
    "Dn-=0.246306, Dn+=0.224655\n"
    ">>> probs = smirnov(n, Dnpm)\n"
    ">>> print(f'For a sample of size {n} drawn from N(0, 1):',\n"
    "...       f' Smirnov n={n}: Prob(Dn- >= {Dnpm[0]:f}) = {probs[0]:.4f}',\n"
    "...       f' Smirnov n={n}: Prob(Dn+ >= {Dnpm[1]:f}) = {probs[1]:.4f}',\n"
    "...       sep='\\n')\n"
    "For a sample of size 5 drawn from N(0, 1):\n"
    " Smirnov n=5: Prob(Dn- >= 0.246306) = 0.4711\n"
    " Smirnov n=5: Prob(Dn+ >= 0.224655) = 0.5245\n"
    "\n"
    "Plot the empirical CDF and the standard normal CDF.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> plt.step(np.concatenate(([-2.5], x, [2.5])),\n"
    "...          np.concatenate((ecdfs, [1])),\n"
    "...          where='post', label='Empirical CDF')\n"
    ">>> xx = np.linspace(-2.5, 2.5, 100)\n"
    ">>> plt.plot(xx, target.cdf(xx), '--', label='CDF for N(0, 1)')\n"
    "\n"
    "Add vertical lines marking Dn+ and Dn-.\n"
    "\n"
    ">>> iminus, iplus = np.argmax(gaps, axis=0)\n"
    ">>> plt.vlines([x[iminus]], ecdfs[iminus], cdfs[iminus], color='r',\n"
    "...            alpha=0.5, lw=4)\n"
    ">>> plt.vlines([x[iplus]], cdfs[iplus], ecdfs[iplus+1], color='m',\n"
    "...            alpha=0.5, lw=4)\n"
    "\n"
    ">>> plt.grid(True)\n"
    ">>> plt.legend(framealpha=1, shadow=True)\n"
    ">>> plt.show()")
ufunc_smirnov_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_smirnov_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_smirnov_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_smirnov_types[0] = <char>NPY_LONG
ufunc_smirnov_types[1] = <char>NPY_DOUBLE
ufunc_smirnov_types[2] = <char>NPY_DOUBLE
ufunc_smirnov_types[3] = <char>NPY_FLOAT
ufunc_smirnov_types[4] = <char>NPY_FLOAT
ufunc_smirnov_types[5] = <char>NPY_FLOAT
ufunc_smirnov_types[6] = <char>NPY_DOUBLE
ufunc_smirnov_types[7] = <char>NPY_DOUBLE
ufunc_smirnov_types[8] = <char>NPY_DOUBLE
ufunc_smirnov_ptr[2*0] = <void*>_func_smirnov
ufunc_smirnov_ptr[2*0+1] = <void*>(<char*>"smirnov")
ufunc_smirnov_ptr[2*1] = <void*>_func_smirnov_unsafe
ufunc_smirnov_ptr[2*1+1] = <void*>(<char*>"smirnov")
ufunc_smirnov_ptr[2*2] = <void*>_func_smirnov_unsafe
ufunc_smirnov_ptr[2*2+1] = <void*>(<char*>"smirnov")
ufunc_smirnov_data[0] = &ufunc_smirnov_ptr[2*0]
ufunc_smirnov_data[1] = &ufunc_smirnov_ptr[2*1]
ufunc_smirnov_data[2] = &ufunc_smirnov_ptr[2*2]
smirnov = np.PyUFunc_FromFuncAndData(ufunc_smirnov_loops, ufunc_smirnov_data, ufunc_smirnov_types, 3, 2, 1, 0, "smirnov", ufunc_smirnov_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_smirnovi_loops[3]
cdef void *ufunc_smirnovi_ptr[6]
cdef void *ufunc_smirnovi_data[3]
cdef char ufunc_smirnovi_types[9]
cdef char *ufunc_smirnovi_doc = (
    "smirnovi(n, p, out=None)\n"
    "\n"
    "Inverse to `smirnov`\n"
    "\n"
    "Returns `d` such that ``smirnov(n, d) == p``, the critical value\n"
    "corresponding to `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : int\n"
    "  Number of samples\n"
    "p : float array_like\n"
    "    Probability\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The value(s) of smirnovi(n, p), the critical values.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "smirnov : The Survival Function (SF) for the distribution\n"
    "scipy.stats.ksone : Provides the functionality as a continuous distribution\n"
    "kolmogorov, kolmogi : Functions for the two-sided distribution\n"
    "scipy.stats.kstwobign : Two-sided Kolmogorov-Smirnov distribution, large n\n"
    "\n"
    "Notes\n"
    "-----\n"
    "`smirnov` is used by `stats.kstest` in the application of the\n"
    "Kolmogorov-Smirnov Goodness of Fit test. For historical reasons this\n"
    "function is exposed in `scpy.special`, but the recommended way to achieve\n"
    "the most accurate CDF/SF/PDF/PPF/ISF computations is to use the\n"
    "`stats.ksone` distribution.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import smirnovi, smirnov\n"
    "\n"
    ">>> n = 24\n"
    ">>> deviations = [0.1, 0.2, 0.3]\n"
    "\n"
    "Use `smirnov` to compute the complementary CDF of the Smirnov\n"
    "distribution for the given number of samples and deviations.\n"
    "\n"
    ">>> p = smirnov(n, deviations)\n"
    ">>> p\n"
    "array([0.58105083, 0.12826832, 0.01032231])\n"
    "\n"
    "The inverse function ``smirnovi(n, p)`` returns ``deviations``.\n"
    "\n"
    ">>> smirnovi(n, p)\n"
    "array([0.1, 0.2, 0.3])")
ufunc_smirnovi_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_smirnovi_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_smirnovi_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_smirnovi_types[0] = <char>NPY_LONG
ufunc_smirnovi_types[1] = <char>NPY_DOUBLE
ufunc_smirnovi_types[2] = <char>NPY_DOUBLE
ufunc_smirnovi_types[3] = <char>NPY_FLOAT
ufunc_smirnovi_types[4] = <char>NPY_FLOAT
ufunc_smirnovi_types[5] = <char>NPY_FLOAT
ufunc_smirnovi_types[6] = <char>NPY_DOUBLE
ufunc_smirnovi_types[7] = <char>NPY_DOUBLE
ufunc_smirnovi_types[8] = <char>NPY_DOUBLE
ufunc_smirnovi_ptr[2*0] = <void*>_func_smirnovi
ufunc_smirnovi_ptr[2*0+1] = <void*>(<char*>"smirnovi")
ufunc_smirnovi_ptr[2*1] = <void*>_func_smirnovi_unsafe
ufunc_smirnovi_ptr[2*1+1] = <void*>(<char*>"smirnovi")
ufunc_smirnovi_ptr[2*2] = <void*>_func_smirnovi_unsafe
ufunc_smirnovi_ptr[2*2+1] = <void*>(<char*>"smirnovi")
ufunc_smirnovi_data[0] = &ufunc_smirnovi_ptr[2*0]
ufunc_smirnovi_data[1] = &ufunc_smirnovi_ptr[2*1]
ufunc_smirnovi_data[2] = &ufunc_smirnovi_ptr[2*2]
smirnovi = np.PyUFunc_FromFuncAndData(ufunc_smirnovi_loops, ufunc_smirnovi_data, ufunc_smirnovi_types, 3, 2, 1, 0, "smirnovi", ufunc_smirnovi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_spence_loops[4]
cdef void *ufunc_spence_ptr[8]
cdef void *ufunc_spence_data[4]
cdef char ufunc_spence_types[8]
cdef char *ufunc_spence_doc = (
    "spence(z, out=None)\n"
    "\n"
    "Spence's function, also known as the dilogarithm.\n"
    "\n"
    "It is defined to be\n"
    "\n"
    ".. math::\n"
    "  \\int_1^z \\frac{\\log(t)}{1 - t}dt\n"
    "\n"
    "for complex :math:`z`, where the contour of integration is taken\n"
    "to avoid the branch cut of the logarithm. Spence's function is\n"
    "analytic everywhere except the negative real axis where it has a\n"
    "branch cut.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Points at which to evaluate Spence's function\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : scalar or ndarray\n"
    "    Computed values of Spence's function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "There is a different convention which defines Spence's function by\n"
    "the integral\n"
    "\n"
    ".. math::\n"
    "  -\\int_0^z \\frac{\\log(1 - t)}{t}dt;\n"
    "\n"
    "this is our ``spence(1 - z)``.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import spence\n"
    ">>> import matplotlib.pyplot as plt\n"
    "\n"
    "The function is defined for complex inputs:\n"
    "\n"
    ">>> spence([1-1j, 1.5+2j, 3j, -10-5j])\n"
    "array([-0.20561676+0.91596559j, -0.86766909-1.39560134j,\n"
    "       -0.59422064-2.49129918j, -1.14044398+6.80075924j])\n"
    "\n"
    "For complex inputs on the branch cut, which is the negative real axis,\n"
    "the function returns the limit for ``z`` with positive imaginary part.\n"
    "For example, in the following, note the sign change of the imaginary\n"
    "part of the output for ``z = -2`` and ``z = -2 - 1e-8j``:\n"
    "\n"
    ">>> spence([-2 + 1e-8j, -2, -2 - 1e-8j])\n"
    "array([2.32018041-3.45139229j, 2.32018042-3.4513923j ,\n"
    "       2.32018041+3.45139229j])\n"
    "\n"
    "The function returns ``nan`` for real inputs on the branch cut:\n"
    "\n"
    ">>> spence(-1.5)\n"
    "nan\n"
    "\n"
    "Verify some particular values: ``spence(0) = pi**2/6``,\n"
    "``spence(1) = 0`` and ``spence(2) = -pi**2/12``.\n"
    "\n"
    ">>> spence([0, 1, 2])\n"
    "array([ 1.64493407,  0.        , -0.82246703])\n"
    ">>> np.pi**2/6, -np.pi**2/12\n"
    "(1.6449340668482264, -0.8224670334241132)\n"
    "\n"
    "Verify the identity::\n"
    "\n"
    "    spence(z) + spence(1 - z) = pi**2/6 - log(z)*log(1 - z)\n"
    "\n"
    ">>> z = 3 + 4j\n"
    ">>> spence(z) + spence(1 - z)\n"
    "(-2.6523186143876067+1.8853470951513935j)\n"
    ">>> np.pi**2/6 - np.log(z)*np.log(1 - z)\n"
    "(-2.652318614387606+1.885347095151394j)\n"
    "\n"
    "Plot the function for positive real input.\n"
    "\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0, 6, 400)\n"
    ">>> ax.plot(x, spence(x))\n"
    ">>> ax.grid()\n"
    ">>> ax.set_xlabel('x')\n"
    ">>> ax.set_title('spence(x)')\n"
    ">>> plt.show()")
ufunc_spence_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_spence_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_spence_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_spence_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_spence_types[0] = <char>NPY_FLOAT
ufunc_spence_types[1] = <char>NPY_FLOAT
ufunc_spence_types[2] = <char>NPY_DOUBLE
ufunc_spence_types[3] = <char>NPY_DOUBLE
ufunc_spence_types[4] = <char>NPY_CFLOAT
ufunc_spence_types[5] = <char>NPY_CFLOAT
ufunc_spence_types[6] = <char>NPY_CDOUBLE
ufunc_spence_types[7] = <char>NPY_CDOUBLE
ufunc_spence_ptr[2*0] = <void*>_func_spence
ufunc_spence_ptr[2*0+1] = <void*>(<char*>"spence")
ufunc_spence_ptr[2*1] = <void*>_func_spence
ufunc_spence_ptr[2*1+1] = <void*>(<char*>"spence")
ufunc_spence_ptr[2*2] = <void*>_func_cspence
ufunc_spence_ptr[2*2+1] = <void*>(<char*>"spence")
ufunc_spence_ptr[2*3] = <void*>_func_cspence
ufunc_spence_ptr[2*3+1] = <void*>(<char*>"spence")
ufunc_spence_data[0] = &ufunc_spence_ptr[2*0]
ufunc_spence_data[1] = &ufunc_spence_ptr[2*1]
ufunc_spence_data[2] = &ufunc_spence_ptr[2*2]
ufunc_spence_data[3] = &ufunc_spence_ptr[2*3]
spence = np.PyUFunc_FromFuncAndData(ufunc_spence_loops, ufunc_spence_data, ufunc_spence_types, 4, 1, 1, 0, "spence", ufunc_spence_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_sph_harm_loops[3]
cdef void *ufunc_sph_harm_ptr[6]
cdef void *ufunc_sph_harm_data[3]
cdef char ufunc_sph_harm_types[15]
cdef char *ufunc_sph_harm_doc = (
    "sph_harm(m, n, theta, phi, out=None)\n"
    "\n"
    "Compute spherical harmonics.\n"
    "\n"
    "The spherical harmonics are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    Y^m_n(\\theta,\\phi) = \\sqrt{\\frac{2n+1}{4\\pi} \\frac{(n-m)!}{(n+m)!}}\n"
    "      e^{i m \\theta} P^m_n(\\cos(\\phi))\n"
    "\n"
    "where :math:`P_n^m` are the associated Legendre functions; see `lpmv`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Order of the harmonic (int); must have ``|m| <= n``.\n"
    "n : array_like\n"
    "   Degree of the harmonic (int); must have ``n >= 0``. This is\n"
    "   often denoted by ``l`` (lower case L) in descriptions of\n"
    "   spherical harmonics.\n"
    "theta : array_like\n"
    "   Azimuthal (longitudinal) coordinate; must be in ``[0, 2*pi]``.\n"
    "phi : array_like\n"
    "   Polar (colatitudinal) coordinate; must be in ``[0, pi]``.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y_mn : complex scalar or ndarray\n"
    "   The harmonic :math:`Y^m_n` sampled at ``theta`` and ``phi``.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "There are different conventions for the meanings of the input\n"
    "arguments ``theta`` and ``phi``. In SciPy ``theta`` is the\n"
    "azimuthal angle and ``phi`` is the polar angle. It is common to\n"
    "see the opposite convention, that is, ``theta`` as the polar angle\n"
    "and ``phi`` as the azimuthal angle.\n"
    "\n"
    "Note that SciPy's spherical harmonics include the Condon-Shortley\n"
    "phase [2]_ because it is part of `lpmv`.\n"
    "\n"
    "With SciPy's conventions, the first several spherical harmonics\n"
    "are\n"
    "\n"
    ".. math::\n"
    "\n"
    "    Y_0^0(\\theta, \\phi) &= \\frac{1}{2} \\sqrt{\\frac{1}{\\pi}} \\\\\n"
    "    Y_1^{-1}(\\theta, \\phi) &= \\frac{1}{2} \\sqrt{\\frac{3}{2\\pi}}\n"
    "                                e^{-i\\theta} \\sin(\\phi) \\\\\n"
    "    Y_1^0(\\theta, \\phi) &= \\frac{1}{2} \\sqrt{\\frac{3}{\\pi}}\n"
    "                             \\cos(\\phi) \\\\\n"
    "    Y_1^1(\\theta, \\phi) &= -\\frac{1}{2} \\sqrt{\\frac{3}{2\\pi}}\n"
    "                             e^{i\\theta} \\sin(\\phi).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Digital Library of Mathematical Functions, 14.30.\n"
    "       https://dlmf.nist.gov/14.30\n"
    ".. [2] https://en.wikipedia.org/wiki/Spherical_harmonics#Condon.E2.80.93Shortley_phase")
ufunc_sph_harm_loops[0] = <np.PyUFuncGenericFunction>loop_D_iidd__As_lldd_D
ufunc_sph_harm_loops[1] = <np.PyUFuncGenericFunction>loop_D_dddd__As_ffff_F
ufunc_sph_harm_loops[2] = <np.PyUFuncGenericFunction>loop_D_dddd__As_dddd_D
ufunc_sph_harm_types[0] = <char>NPY_LONG
ufunc_sph_harm_types[1] = <char>NPY_LONG
ufunc_sph_harm_types[2] = <char>NPY_DOUBLE
ufunc_sph_harm_types[3] = <char>NPY_DOUBLE
ufunc_sph_harm_types[4] = <char>NPY_CDOUBLE
ufunc_sph_harm_types[5] = <char>NPY_FLOAT
ufunc_sph_harm_types[6] = <char>NPY_FLOAT
ufunc_sph_harm_types[7] = <char>NPY_FLOAT
ufunc_sph_harm_types[8] = <char>NPY_FLOAT
ufunc_sph_harm_types[9] = <char>NPY_CFLOAT
ufunc_sph_harm_types[10] = <char>NPY_DOUBLE
ufunc_sph_harm_types[11] = <char>NPY_DOUBLE
ufunc_sph_harm_types[12] = <char>NPY_DOUBLE
ufunc_sph_harm_types[13] = <char>NPY_DOUBLE
ufunc_sph_harm_types[14] = <char>NPY_CDOUBLE
ufunc_sph_harm_ptr[2*0] = <void*>_func_sph_harmonic
ufunc_sph_harm_ptr[2*0+1] = <void*>(<char*>"sph_harm")
ufunc_sph_harm_ptr[2*1] = <void*>_func_sph_harmonic_unsafe
ufunc_sph_harm_ptr[2*1+1] = <void*>(<char*>"sph_harm")
ufunc_sph_harm_ptr[2*2] = <void*>_func_sph_harmonic_unsafe
ufunc_sph_harm_ptr[2*2+1] = <void*>(<char*>"sph_harm")
ufunc_sph_harm_data[0] = &ufunc_sph_harm_ptr[2*0]
ufunc_sph_harm_data[1] = &ufunc_sph_harm_ptr[2*1]
ufunc_sph_harm_data[2] = &ufunc_sph_harm_ptr[2*2]
sph_harm = np.PyUFunc_FromFuncAndData(ufunc_sph_harm_loops, ufunc_sph_harm_data, ufunc_sph_harm_types, 3, 4, 1, 0, "sph_harm", ufunc_sph_harm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_stdtr_loops[2]
cdef void *ufunc_stdtr_ptr[4]
cdef void *ufunc_stdtr_data[2]
cdef char ufunc_stdtr_types[6]
cdef char *ufunc_stdtr_doc = (
    "stdtr(df, t, out=None)\n"
    "\n"
    "Student t distribution cumulative distribution function\n"
    "\n"
    "Returns the integral:\n"
    "\n"
    ".. math::\n"
    "    \\frac{\\Gamma((df+1)/2)}{\\sqrt{\\pi df} \\Gamma(df/2)}\n"
    "    \\int_{-\\infty}^t (1+x^2/df)^{-(df+1)/2}\\, dx\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "df : array_like\n"
    "    Degrees of freedom\n"
    "t : array_like\n"
    "    Upper bound of the integral\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the Student t CDF at t\n"
    "\n"
    "See Also\n"
    "--------\n"
    "stdtridf : inverse of stdtr with respect to `df`\n"
    "stdtrit : inverse of stdtr with respect to `t`\n"
    "scipy.stats.t : student t distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The student t distribution is also available as `scipy.stats.t`.\n"
    "Calling `stdtr` directly can improve performance compared to the\n"
    "``cdf`` method of `scipy.stats.t` (see last example below).\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function for ``df=3`` at ``t=1``.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import stdtr\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> stdtr(3, 1)\n"
    "0.8044988905221148\n"
    "\n"
    "Plot the function for three different degrees of freedom.\n"
    "\n"
    ">>> x = np.linspace(-10, 10, 1000)\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> parameters = [(1, \"solid\"), (3, \"dashed\"), (10, \"dotted\")]\n"
    ">>> for (df, linestyle) in parameters:\n"
    "...     ax.plot(x, stdtr(df, x), ls=linestyle, label=f\"$df={df}$\")\n"
    ">>> ax.legend()\n"
    ">>> ax.set_title(\"Student t distribution cumulative distribution function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The function can be computed for several degrees of freedom at the same\n"
    "time by providing a NumPy array or list for `df`:\n"
    "\n"
    ">>> stdtr([1, 2, 3], 1)\n"
    "array([0.75      , 0.78867513, 0.80449889])\n"
    "\n"
    "It is possible to calculate the function at several points for several\n"
    "different degrees of freedom simultaneously by providing arrays for `df`\n"
    "and `t` with shapes compatible for broadcasting. Compute `stdtr` at\n"
    "4 points for 3 degrees of freedom resulting in an array of shape 3x4.\n"
    "\n"
    ">>> dfs = np.array([[1], [2], [3]])\n"
    ">>> t = np.array([2, 4, 6, 8])\n"
    ">>> dfs.shape, t.shape\n"
    "((3, 1), (4,))\n"
    "\n"
    ">>> stdtr(dfs, t)\n"
    "array([[0.85241638, 0.92202087, 0.94743154, 0.96041658],\n"
    "       [0.90824829, 0.97140452, 0.98666426, 0.99236596],\n"
    "       [0.93033702, 0.98599577, 0.99536364, 0.99796171]])\n"
    "\n"
    "The t distribution is also available as `scipy.stats.t`. Calling `stdtr`\n"
    "directly can be much faster than calling the ``cdf`` method of\n"
    "`scipy.stats.t`. To get the same results, one must use the following\n"
    "parametrization: ``scipy.stats.t(df).cdf(x) = stdtr(df, x)``.\n"
    "\n"
    ">>> from scipy.stats import t\n"
    ">>> df, x = 3, 1\n"
    ">>> stdtr_result = stdtr(df, x)  # this can be faster than below\n"
    ">>> stats_result = t(df).cdf(x)\n"
    ">>> stats_result == stdtr_result  # test that results are equal\n"
    "True")
ufunc_stdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_stdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_stdtr_types[0] = <char>NPY_FLOAT
ufunc_stdtr_types[1] = <char>NPY_FLOAT
ufunc_stdtr_types[2] = <char>NPY_FLOAT
ufunc_stdtr_types[3] = <char>NPY_DOUBLE
ufunc_stdtr_types[4] = <char>NPY_DOUBLE
ufunc_stdtr_types[5] = <char>NPY_DOUBLE
ufunc_stdtr_ptr[2*0] = <void*>_func_cdft1_wrap
ufunc_stdtr_ptr[2*0+1] = <void*>(<char*>"stdtr")
ufunc_stdtr_ptr[2*1] = <void*>_func_cdft1_wrap
ufunc_stdtr_ptr[2*1+1] = <void*>(<char*>"stdtr")
ufunc_stdtr_data[0] = &ufunc_stdtr_ptr[2*0]
ufunc_stdtr_data[1] = &ufunc_stdtr_ptr[2*1]
stdtr = np.PyUFunc_FromFuncAndData(ufunc_stdtr_loops, ufunc_stdtr_data, ufunc_stdtr_types, 2, 2, 1, 0, "stdtr", ufunc_stdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_stdtridf_loops[2]
cdef void *ufunc_stdtridf_ptr[4]
cdef void *ufunc_stdtridf_data[2]
cdef char ufunc_stdtridf_types[6]
cdef char *ufunc_stdtridf_doc = (
    "stdtridf(p, t, out=None)\n"
    "\n"
    "Inverse of `stdtr` vs df\n"
    "\n"
    "Returns the argument df such that stdtr(df, t) is equal to `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability\n"
    "t : array_like\n"
    "    Upper bound of the integral\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "df : scalar or ndarray\n"
    "    Value of `df` such that ``stdtr(df, t) == p``\n"
    "\n"
    "See Also\n"
    "--------\n"
    "stdtr : Student t CDF\n"
    "stdtrit : inverse of stdtr with respect to `t`\n"
    "scipy.stats.t : Student t distribution\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the student t cumulative distribution function for one\n"
    "parameter set.\n"
    "\n"
    ">>> from scipy.special import stdtr, stdtridf\n"
    ">>> df, x = 5, 2\n"
    ">>> cdf_value = stdtr(df, x)\n"
    ">>> cdf_value\n"
    "0.9490302605850709\n"
    "\n"
    "Verify that `stdtridf` recovers the original value for `df` given\n"
    "the CDF value and `x`.\n"
    "\n"
    ">>> stdtridf(cdf_value, x)\n"
    "5.0")
ufunc_stdtridf_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_stdtridf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_stdtridf_types[0] = <char>NPY_FLOAT
ufunc_stdtridf_types[1] = <char>NPY_FLOAT
ufunc_stdtridf_types[2] = <char>NPY_FLOAT
ufunc_stdtridf_types[3] = <char>NPY_DOUBLE
ufunc_stdtridf_types[4] = <char>NPY_DOUBLE
ufunc_stdtridf_types[5] = <char>NPY_DOUBLE
ufunc_stdtridf_ptr[2*0] = <void*>_func_cdft3_wrap
ufunc_stdtridf_ptr[2*0+1] = <void*>(<char*>"stdtridf")
ufunc_stdtridf_ptr[2*1] = <void*>_func_cdft3_wrap
ufunc_stdtridf_ptr[2*1+1] = <void*>(<char*>"stdtridf")
ufunc_stdtridf_data[0] = &ufunc_stdtridf_ptr[2*0]
ufunc_stdtridf_data[1] = &ufunc_stdtridf_ptr[2*1]
stdtridf = np.PyUFunc_FromFuncAndData(ufunc_stdtridf_loops, ufunc_stdtridf_data, ufunc_stdtridf_types, 2, 2, 1, 0, "stdtridf", ufunc_stdtridf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_stdtrit_loops[2]
cdef void *ufunc_stdtrit_ptr[4]
cdef void *ufunc_stdtrit_data[2]
cdef char ufunc_stdtrit_types[6]
cdef char *ufunc_stdtrit_doc = (
    "stdtrit(df, p, out=None)\n"
    "\n"
    "The `p`-th quantile of the student t distribution.\n"
    "\n"
    "This function is the inverse of the student t distribution cumulative\n"
    "distribution function (CDF), returning `t` such that `stdtr(df, t) = p`.\n"
    "\n"
    "Returns the argument `t` such that stdtr(df, t) is equal to `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "df : array_like\n"
    "    Degrees of freedom\n"
    "p : array_like\n"
    "    Probability\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "t : scalar or ndarray\n"
    "    Value of `t` such that ``stdtr(df, t) == p``\n"
    "\n"
    "See Also\n"
    "--------\n"
    "stdtr : Student t CDF\n"
    "stdtridf : inverse of stdtr with respect to `df`\n"
    "scipy.stats.t : Student t distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The student t distribution is also available as `scipy.stats.t`. Calling\n"
    "`stdtrit` directly can improve performance compared to the ``ppf``\n"
    "method of `scipy.stats.t` (see last example below).\n"
    "\n"
    "Examples\n"
    "--------\n"
    "`stdtrit` represents the inverse of the student t distribution CDF which\n"
    "is available as `stdtr`. Here, we calculate the CDF for ``df`` at\n"
    "``x=1``. `stdtrit` then returns ``1`` up to floating point errors\n"
    "given the same value for `df` and the computed CDF value.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import stdtr, stdtrit\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> df = 3\n"
    ">>> x = 1\n"
    ">>> cdf_value = stdtr(df, x)\n"
    ">>> stdtrit(df, cdf_value)\n"
    "0.9999999994418539\n"
    "\n"
    "Plot the function for three different degrees of freedom.\n"
    "\n"
    ">>> x = np.linspace(0, 1, 1000)\n"
    ">>> parameters = [(1, \"solid\"), (2, \"dashed\"), (5, \"dotted\")]\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> for (df, linestyle) in parameters:\n"
    "...     ax.plot(x, stdtrit(df, x), ls=linestyle, label=f\"$df={df}$\")\n"
    ">>> ax.legend()\n"
    ">>> ax.set_ylim(-10, 10)\n"
    ">>> ax.set_title(\"Student t distribution quantile function\")\n"
    ">>> plt.show()\n"
    "\n"
    "The function can be computed for several degrees of freedom at the same\n"
    "time by providing a NumPy array or list for `df`:\n"
    "\n"
    ">>> stdtrit([1, 2, 3], 0.7)\n"
    "array([0.72654253, 0.6172134 , 0.58438973])\n"
    "\n"
    "It is possible to calculate the function at several points for several\n"
    "different degrees of freedom simultaneously by providing arrays for `df`\n"
    "and `p` with shapes compatible for broadcasting. Compute `stdtrit` at\n"
    "4 points for 3 degrees of freedom resulting in an array of shape 3x4.\n"
    "\n"
    ">>> dfs = np.array([[1], [2], [3]])\n"
    ">>> p = np.array([0.2, 0.4, 0.7, 0.8])\n"
    ">>> dfs.shape, p.shape\n"
    "((3, 1), (4,))\n"
    "\n"
    ">>> stdtrit(dfs, p)\n"
    "array([[-1.37638192, -0.3249197 ,  0.72654253,  1.37638192],\n"
    "       [-1.06066017, -0.28867513,  0.6172134 ,  1.06066017],\n"
    "       [-0.97847231, -0.27667066,  0.58438973,  0.97847231]])\n"
    "\n"
    "The t distribution is also available as `scipy.stats.t`. Calling `stdtrit`\n"
    "directly can be much faster than calling the ``ppf`` method of\n"
    "`scipy.stats.t`. To get the same results, one must use the following\n"
    "parametrization: ``scipy.stats.t(df).ppf(x) = stdtrit(df, x)``.\n"
    "\n"
    ">>> from scipy.stats import t\n"
    ">>> df, x = 3, 0.5\n"
    ">>> stdtrit_result = stdtrit(df, x)  # this can be faster than below\n"
    ">>> stats_result = t(df).ppf(x)\n"
    ">>> stats_result == stdtrit_result  # test that results are equal\n"
    "True")
ufunc_stdtrit_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_stdtrit_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_stdtrit_types[0] = <char>NPY_FLOAT
ufunc_stdtrit_types[1] = <char>NPY_FLOAT
ufunc_stdtrit_types[2] = <char>NPY_FLOAT
ufunc_stdtrit_types[3] = <char>NPY_DOUBLE
ufunc_stdtrit_types[4] = <char>NPY_DOUBLE
ufunc_stdtrit_types[5] = <char>NPY_DOUBLE
ufunc_stdtrit_ptr[2*0] = <void*>_func_cdft2_wrap
ufunc_stdtrit_ptr[2*0+1] = <void*>(<char*>"stdtrit")
ufunc_stdtrit_ptr[2*1] = <void*>_func_cdft2_wrap
ufunc_stdtrit_ptr[2*1+1] = <void*>(<char*>"stdtrit")
ufunc_stdtrit_data[0] = &ufunc_stdtrit_ptr[2*0]
ufunc_stdtrit_data[1] = &ufunc_stdtrit_ptr[2*1]
stdtrit = np.PyUFunc_FromFuncAndData(ufunc_stdtrit_loops, ufunc_stdtrit_data, ufunc_stdtrit_types, 2, 2, 1, 0, "stdtrit", ufunc_stdtrit_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_struve_loops[2]
cdef void *ufunc_struve_ptr[4]
cdef void *ufunc_struve_data[2]
cdef char ufunc_struve_types[6]
cdef char *ufunc_struve_doc = (
    "struve(v, x, out=None)\n"
    "\n"
    "Struve function.\n"
    "\n"
    "Return the value of the Struve function of order `v` at `x`.  The Struve\n"
    "function is defined as,\n"
    "\n"
    ".. math::\n"
    "    H_v(x) = (z/2)^{v + 1} \\sum_{n=0}^\\infty\n"
    "    \\frac{(-1)^n (z/2)^{2n}}{\\Gamma(n + \\frac{3}{2}) \\Gamma(n + v + \\frac{3}{2})},\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order of the Struve function (float).\n"
    "x : array_like\n"
    "    Argument of the Struve function (float; must be positive unless `v` is\n"
    "    an integer).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "H : scalar or ndarray\n"
    "    Value of the Struve function of order `v` at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "modstruve: Modified Struve function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Three methods discussed in [1]_ are used to evaluate the Struve function:\n"
    "\n"
    "- power series\n"
    "- expansion in Bessel functions (if :math:`|z| < |v| + 20`)\n"
    "- asymptotic large-z expansion (if :math:`z \\geq 0.7v + 12`)\n"
    "\n"
    "Rounding errors are estimated based on the largest terms in the sums, and\n"
    "the result associated with the smallest error is returned.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/11\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the Struve function of order 1 at 2.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import struve\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> struve(1, 2.)\n"
    "0.6467637282835622\n"
    "\n"
    "Calculate the Struve function at 2 for orders 1, 2 and 3 by providing\n"
    "a list for the order parameter `v`.\n"
    "\n"
    ">>> struve([1, 2, 3], 2.)\n"
    "array([0.64676373, 0.28031806, 0.08363767])\n"
    "\n"
    "Calculate the Struve function of order 1 for several points by providing\n"
    "an array for `x`.\n"
    "\n"
    ">>> points = np.array([2., 5., 8.])\n"
    ">>> struve(1, points)\n"
    "array([0.64676373, 0.80781195, 0.48811605])\n"
    "\n"
    "Compute the Struve function for several orders at several points by\n"
    "providing arrays for `v` and `z`. The arrays have to be broadcastable\n"
    "to the correct shapes.\n"
    "\n"
    ">>> orders = np.array([[1], [2], [3]])\n"
    ">>> points.shape, orders.shape\n"
    "((3,), (3, 1))\n"
    "\n"
    ">>> struve(orders, points)\n"
    "array([[0.64676373, 0.80781195, 0.48811605],\n"
    "       [0.28031806, 1.56937455, 1.51769363],\n"
    "       [0.08363767, 1.50872065, 2.98697513]])\n"
    "\n"
    "Plot the Struve functions of order 0 to 3 from -10 to 10.\n"
    "\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-10., 10., 1000)\n"
    ">>> for i in range(4):\n"
    "...     ax.plot(x, struve(i, x), label=f'$H_{i!r}$')\n"
    ">>> ax.legend(ncol=2)\n"
    ">>> ax.set_xlim(-10, 10)\n"
    ">>> ax.set_title(r\"Struve functions $H_{\\nu}$\")\n"
    ">>> plt.show()")
ufunc_struve_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_struve_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_struve_types[0] = <char>NPY_FLOAT
ufunc_struve_types[1] = <char>NPY_FLOAT
ufunc_struve_types[2] = <char>NPY_FLOAT
ufunc_struve_types[3] = <char>NPY_DOUBLE
ufunc_struve_types[4] = <char>NPY_DOUBLE
ufunc_struve_types[5] = <char>NPY_DOUBLE
ufunc_struve_ptr[2*0] = <void*>_func_struve_h
ufunc_struve_ptr[2*0+1] = <void*>(<char*>"struve")
ufunc_struve_ptr[2*1] = <void*>_func_struve_h
ufunc_struve_ptr[2*1+1] = <void*>(<char*>"struve")
ufunc_struve_data[0] = &ufunc_struve_ptr[2*0]
ufunc_struve_data[1] = &ufunc_struve_ptr[2*1]
struve = np.PyUFunc_FromFuncAndData(ufunc_struve_loops, ufunc_struve_data, ufunc_struve_types, 2, 2, 1, 0, "struve", ufunc_struve_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_tandg_loops[2]
cdef void *ufunc_tandg_ptr[4]
cdef void *ufunc_tandg_data[2]
cdef char ufunc_tandg_types[4]
cdef char *ufunc_tandg_doc = (
    "tandg(x, out=None)\n"
    "\n"
    "Tangent of angle `x` given in degrees.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Angle, given in degrees.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Tangent at the input.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "sindg, cosdg, cotdg\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is more accurate than using tangent directly.\n"
    "\n"
    ">>> x = 180 * np.arange(3)\n"
    ">>> sc.tandg(x)\n"
    "array([0., 0., 0.])\n"
    ">>> np.tan(x * np.pi / 180)\n"
    "array([ 0.0000000e+00, -1.2246468e-16, -2.4492936e-16])")
ufunc_tandg_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_tandg_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_tandg_types[0] = <char>NPY_FLOAT
ufunc_tandg_types[1] = <char>NPY_FLOAT
ufunc_tandg_types[2] = <char>NPY_DOUBLE
ufunc_tandg_types[3] = <char>NPY_DOUBLE
ufunc_tandg_ptr[2*0] = <void*>_func_tandg
ufunc_tandg_ptr[2*0+1] = <void*>(<char*>"tandg")
ufunc_tandg_ptr[2*1] = <void*>_func_tandg
ufunc_tandg_ptr[2*1+1] = <void*>(<char*>"tandg")
ufunc_tandg_data[0] = &ufunc_tandg_ptr[2*0]
ufunc_tandg_data[1] = &ufunc_tandg_ptr[2*1]
tandg = np.PyUFunc_FromFuncAndData(ufunc_tandg_loops, ufunc_tandg_data, ufunc_tandg_types, 2, 1, 1, 0, "tandg", ufunc_tandg_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_tklmbda_loops[2]
cdef void *ufunc_tklmbda_ptr[4]
cdef void *ufunc_tklmbda_data[2]
cdef char ufunc_tklmbda_types[6]
cdef char *ufunc_tklmbda_doc = (
    "tklmbda(x, lmbda, out=None)\n"
    "\n"
    "Cumulative distribution function of the Tukey lambda distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x, lmbda : array_like\n"
    "    Parameters\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "cdf : scalar or ndarray\n"
    "    Value of the Tukey lambda CDF\n"
    "\n"
    "See Also\n"
    "--------\n"
    "scipy.stats.tukeylambda : Tukey lambda distribution\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> from scipy.special import tklmbda, expit\n"
    "\n"
    "Compute the cumulative distribution function (CDF) of the Tukey lambda\n"
    "distribution at several ``x`` values for `lmbda` = -1.5.\n"
    "\n"
    ">>> x = np.linspace(-2, 2, 9)\n"
    ">>> x\n"
    "array([-2. , -1.5, -1. , -0.5,  0. ,  0.5,  1. ,  1.5,  2. ])\n"
    ">>> tklmbda(x, -1.5)\n"
    "array([0.34688734, 0.3786554 , 0.41528805, 0.45629737, 0.5       ,\n"
    "       0.54370263, 0.58471195, 0.6213446 , 0.65311266])\n"
    "\n"
    "When `lmbda` is 0, the function is the logistic sigmoid function,\n"
    "which is implemented in `scipy.special` as `expit`.\n"
    "\n"
    ">>> tklmbda(x, 0)\n"
    "array([0.11920292, 0.18242552, 0.26894142, 0.37754067, 0.5       ,\n"
    "       0.62245933, 0.73105858, 0.81757448, 0.88079708])\n"
    ">>> expit(x)\n"
    "array([0.11920292, 0.18242552, 0.26894142, 0.37754067, 0.5       ,\n"
    "       0.62245933, 0.73105858, 0.81757448, 0.88079708])\n"
    "\n"
    "When `lmbda` is 1, the Tukey lambda distribution is uniform on the\n"
    "interval [-1, 1], so the CDF increases linearly.\n"
    "\n"
    ">>> t = np.linspace(-1, 1, 9)\n"
    ">>> tklmbda(t, 1)\n"
    "array([0.   , 0.125, 0.25 , 0.375, 0.5  , 0.625, 0.75 , 0.875, 1.   ])\n"
    "\n"
    "In the following, we generate plots for several values of `lmbda`.\n"
    "\n"
    "The first figure shows graphs for `lmbda` <= 0.\n"
    "\n"
    ">>> styles = ['-', '-.', '--', ':']\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-12, 12, 500)\n"
    ">>> for k, lmbda in enumerate([-1.0, -0.5, 0.0]):\n"
    "...     y = tklmbda(x, lmbda)\n"
    "...     ax.plot(x, y, styles[k], label=f'$\\lambda$ = {lmbda:-4.1f}')\n"
    "\n"
    ">>> ax.set_title('tklmbda(x, $\\lambda$)')\n"
    ">>> ax.set_label('x')\n"
    ">>> ax.legend(framealpha=1, shadow=True)\n"
    ">>> ax.grid(True)\n"
    "\n"
    "The second figure shows graphs for `lmbda` > 0.  The dots in the\n"
    "graphs show the bounds of the support of the distribution.\n"
    "\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(-4.2, 4.2, 500)\n"
    ">>> lmbdas = [0.25, 0.5, 1.0, 1.5]\n"
    ">>> for k, lmbda in enumerate(lmbdas):\n"
    "...     y = tklmbda(x, lmbda)\n"
    "...     ax.plot(x, y, styles[k], label=f'$\\lambda$ = {lmbda}')\n"
    "\n"
    ">>> ax.set_prop_cycle(None)\n"
    ">>> for lmbda in lmbdas:\n"
    "...     ax.plot([-1/lmbda, 1/lmbda], [0, 1], '.', ms=8)\n"
    "\n"
    ">>> ax.set_title('tklmbda(x, $\\lambda$)')\n"
    ">>> ax.set_xlabel('x')\n"
    ">>> ax.legend(framealpha=1, shadow=True)\n"
    ">>> ax.grid(True)\n"
    "\n"
    ">>> plt.tight_layout()\n"
    ">>> plt.show()\n"
    "\n"
    "The CDF of the Tukey lambda distribution is also implemented as the\n"
    "``cdf`` method of `scipy.stats.tukeylambda`.  In the following,\n"
    "``tukeylambda.cdf(x, -0.5)`` and ``tklmbda(x, -0.5)`` compute the\n"
    "same values:\n"
    "\n"
    ">>> from scipy.stats import tukeylambda\n"
    ">>> x = np.linspace(-2, 2, 9)\n"
    "\n"
    ">>> tukeylambda.cdf(x, -0.5)\n"
    "array([0.21995157, 0.27093858, 0.33541677, 0.41328161, 0.5       ,\n"
    "       0.58671839, 0.66458323, 0.72906142, 0.78004843])\n"
    "\n"
    ">>> tklmbda(x, -0.5)\n"
    "array([0.21995157, 0.27093858, 0.33541677, 0.41328161, 0.5       ,\n"
    "       0.58671839, 0.66458323, 0.72906142, 0.78004843])\n"
    "\n"
    "The implementation in ``tukeylambda`` also provides location and scale\n"
    "parameters, and other methods such as ``pdf()`` (the probability\n"
    "density function) and ``ppf()`` (the inverse of the CDF), so for\n"
    "working with the Tukey lambda distribution, ``tukeylambda`` is more\n"
    "generally useful.  The primary advantage of ``tklmbda`` is that it is\n"
    "significantly faster than ``tukeylambda.cdf``.")
ufunc_tklmbda_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_tklmbda_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_tklmbda_types[0] = <char>NPY_FLOAT
ufunc_tklmbda_types[1] = <char>NPY_FLOAT
ufunc_tklmbda_types[2] = <char>NPY_FLOAT
ufunc_tklmbda_types[3] = <char>NPY_DOUBLE
ufunc_tklmbda_types[4] = <char>NPY_DOUBLE
ufunc_tklmbda_types[5] = <char>NPY_DOUBLE
ufunc_tklmbda_ptr[2*0] = <void*>_func_tukeylambdacdf
ufunc_tklmbda_ptr[2*0+1] = <void*>(<char*>"tklmbda")
ufunc_tklmbda_ptr[2*1] = <void*>_func_tukeylambdacdf
ufunc_tklmbda_ptr[2*1+1] = <void*>(<char*>"tklmbda")
ufunc_tklmbda_data[0] = &ufunc_tklmbda_ptr[2*0]
ufunc_tklmbda_data[1] = &ufunc_tklmbda_ptr[2*1]
tklmbda = np.PyUFunc_FromFuncAndData(ufunc_tklmbda_loops, ufunc_tklmbda_data, ufunc_tklmbda_types, 2, 2, 1, 0, "tklmbda", ufunc_tklmbda_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_voigt_profile_loops[2]
cdef void *ufunc_voigt_profile_ptr[4]
cdef void *ufunc_voigt_profile_data[2]
cdef char ufunc_voigt_profile_types[8]
cdef char *ufunc_voigt_profile_doc = (
    "voigt_profile(x, sigma, gamma, out=None)\n"
    "\n"
    "Voigt profile.\n"
    "\n"
    "The Voigt profile is a convolution of a 1-D Normal distribution with\n"
    "standard deviation ``sigma`` and a 1-D Cauchy distribution with half-width at\n"
    "half-maximum ``gamma``.\n"
    "\n"
    "If ``sigma = 0``, PDF of Cauchy distribution is returned.\n"
    "Conversely, if ``gamma = 0``, PDF of Normal distribution is returned.\n"
    "If ``sigma = gamma = 0``, the return value is ``Inf`` for ``x = 0``,\n"
    "and ``0`` for all other ``x``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real argument\n"
    "sigma : array_like\n"
    "    The standard deviation of the Normal distribution part\n"
    "gamma : array_like\n"
    "    The half-width at half-maximum of the Cauchy distribution part\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The Voigt profile at the given arguments\n"
    "\n"
    "See Also\n"
    "--------\n"
    "wofz : Faddeeva function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "It can be expressed in terms of Faddeeva function\n"
    "\n"
    ".. math:: V(x; \\sigma, \\gamma) = \\frac{Re[w(z)]}{\\sigma\\sqrt{2\\pi}},\n"
    ".. math:: z = \\frac{x + i\\gamma}{\\sqrt{2}\\sigma}\n"
    "\n"
    "where :math:`w(z)` is the Faddeeva function.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] https://en.wikipedia.org/wiki/Voigt_profile\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function at point 2 for ``sigma=1`` and ``gamma=1``.\n"
    "\n"
    ">>> from scipy.special import voigt_profile\n"
    ">>> import numpy as np\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> voigt_profile(2, 1., 1.)\n"
    "0.09071519942627544\n"
    "\n"
    "Calculate the function at several points by providing a NumPy array\n"
    "for `x`.\n"
    "\n"
    ">>> values = np.array([-2., 0., 5])\n"
    ">>> voigt_profile(values, 1., 1.)\n"
    "array([0.0907152 , 0.20870928, 0.01388492])\n"
    "\n"
    "Plot the function for different parameter sets.\n"
    "\n"
    ">>> fig, ax = plt.subplots(figsize=(8, 8))\n"
    ">>> x = np.linspace(-10, 10, 500)\n"
    ">>> parameters_list = [(1.5, 0., \"solid\"), (1.3, 0.5, \"dashed\"),\n"
    "...                    (0., 1.8, \"dotted\"), (1., 1., \"dashdot\")]\n"
    ">>> for params in parameters_list:\n"
    "...     sigma, gamma, linestyle = params\n"
    "...     voigt = voigt_profile(x, sigma, gamma)\n"
    "...     ax.plot(x, voigt, label=rf\"$\\sigma={sigma},\\, \\gamma={gamma}$\",\n"
    "...             ls=linestyle)\n"
    ">>> ax.legend()\n"
    ">>> plt.show()\n"
    "\n"
    "Verify visually that the Voigt profile indeed arises as the convolution\n"
    "of a normal and a Cauchy distribution.\n"
    "\n"
    ">>> from scipy.signal import convolve\n"
    ">>> x, dx = np.linspace(-10, 10, 500, retstep=True)\n"
    ">>> def gaussian(x, sigma):\n"
    "...     return np.exp(-0.5 * x**2/sigma**2)/(sigma * np.sqrt(2*np.pi))\n"
    ">>> def cauchy(x, gamma):\n"
    "...     return gamma/(np.pi * (np.square(x)+gamma**2))\n"
    ">>> sigma = 2\n"
    ">>> gamma = 1\n"
    ">>> gauss_profile = gaussian(x, sigma)\n"
    ">>> cauchy_profile = cauchy(x, gamma)\n"
    ">>> convolved = dx * convolve(cauchy_profile, gauss_profile, mode=\"same\")\n"
    ">>> voigt = voigt_profile(x, sigma, gamma)\n"
    ">>> fig, ax = plt.subplots(figsize=(8, 8))\n"
    ">>> ax.plot(x, gauss_profile, label=\"Gauss: $G$\", c='b')\n"
    ">>> ax.plot(x, cauchy_profile, label=\"Cauchy: $C$\", c='y', ls=\"dashed\")\n"
    ">>> xx = 0.5*(x[1:] + x[:-1])  # midpoints\n"
    ">>> ax.plot(xx, convolved[1:], label=\"Convolution: $G * C$\", ls='dashdot',\n"
    "...         c='k')\n"
    ">>> ax.plot(x, voigt, label=\"Voigt\", ls='dotted', c='r')\n"
    ">>> ax.legend()\n"
    ">>> plt.show()")
ufunc_voigt_profile_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_voigt_profile_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_voigt_profile_types[0] = <char>NPY_FLOAT
ufunc_voigt_profile_types[1] = <char>NPY_FLOAT
ufunc_voigt_profile_types[2] = <char>NPY_FLOAT
ufunc_voigt_profile_types[3] = <char>NPY_FLOAT
ufunc_voigt_profile_types[4] = <char>NPY_DOUBLE
ufunc_voigt_profile_types[5] = <char>NPY_DOUBLE
ufunc_voigt_profile_types[6] = <char>NPY_DOUBLE
ufunc_voigt_profile_types[7] = <char>NPY_DOUBLE
ufunc_voigt_profile_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_voigt_profile
ufunc_voigt_profile_ptr[2*0+1] = <void*>(<char*>"voigt_profile")
ufunc_voigt_profile_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_voigt_profile
ufunc_voigt_profile_ptr[2*1+1] = <void*>(<char*>"voigt_profile")
ufunc_voigt_profile_data[0] = &ufunc_voigt_profile_ptr[2*0]
ufunc_voigt_profile_data[1] = &ufunc_voigt_profile_ptr[2*1]
voigt_profile = np.PyUFunc_FromFuncAndData(ufunc_voigt_profile_loops, ufunc_voigt_profile_data, ufunc_voigt_profile_types, 2, 3, 1, 0, "voigt_profile", ufunc_voigt_profile_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_wofz_loops[2]
cdef void *ufunc_wofz_ptr[4]
cdef void *ufunc_wofz_data[2]
cdef char ufunc_wofz_types[4]
cdef char *ufunc_wofz_doc = (
    "wofz(z, out=None)\n"
    "\n"
    "Faddeeva function\n"
    "\n"
    "Returns the value of the Faddeeva function for complex argument::\n"
    "\n"
    "    exp(-z**2) * erfc(-i*z)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    complex argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the Faddeeva function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "dawsn, erf, erfc, erfcx, erfi\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    "\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> z = special.wofz(x)\n"
    "\n"
    ">>> plt.plot(x, z.real, label='wofz(x).real')\n"
    ">>> plt.plot(x, z.imag, label='wofz(x).imag')\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.legend(framealpha=1, shadow=True)\n"
    ">>> plt.grid(alpha=0.25)\n"
    ">>> plt.show()")
ufunc_wofz_loops[0] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_wofz_loops[1] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_wofz_types[0] = <char>NPY_CFLOAT
ufunc_wofz_types[1] = <char>NPY_CFLOAT
ufunc_wofz_types[2] = <char>NPY_CDOUBLE
ufunc_wofz_types[3] = <char>NPY_CDOUBLE
ufunc_wofz_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_w
ufunc_wofz_ptr[2*0+1] = <void*>(<char*>"wofz")
ufunc_wofz_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_w
ufunc_wofz_ptr[2*1+1] = <void*>(<char*>"wofz")
ufunc_wofz_data[0] = &ufunc_wofz_ptr[2*0]
ufunc_wofz_data[1] = &ufunc_wofz_ptr[2*1]
wofz = np.PyUFunc_FromFuncAndData(ufunc_wofz_loops, ufunc_wofz_data, ufunc_wofz_types, 2, 1, 1, 0, "wofz", ufunc_wofz_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_wright_bessel_loops[2]
cdef void *ufunc_wright_bessel_ptr[4]
cdef void *ufunc_wright_bessel_data[2]
cdef char ufunc_wright_bessel_types[8]
cdef char *ufunc_wright_bessel_doc = (
    "wright_bessel(a, b, x, out=None)\n"
    "\n"
    "Wright's generalized Bessel function.\n"
    "\n"
    "Wright's generalized Bessel function is an entire function and defined as\n"
    "\n"
    ".. math:: \\Phi(a, b; x) = \\sum_{k=0}^\\infty \\frac{x^k}{k! \\Gamma(a k + b)}\n"
    "\n"
    "See Also [1].\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like of float\n"
    "    a >= 0\n"
    "b : array_like of float\n"
    "    b >= 0\n"
    "x : array_like of float\n"
    "    x >= 0\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the Wright's generalized Bessel function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Due to the complexity of the function with its three parameters, only\n"
    "non-negative arguments are implemented.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Digital Library of Mathematical Functions, 10.46.\n"
    "       https://dlmf.nist.gov/10.46.E1\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import wright_bessel\n"
    ">>> a, b, x = 1.5, 1.1, 2.5\n"
    ">>> wright_bessel(a, b-1, x)\n"
    "4.5314465939443025\n"
    "\n"
    "Now, let us verify the relation\n"
    "\n"
    ".. math:: \\Phi(a, b-1; x) = a x \\Phi(a, b+a; x) + (b-1) \\Phi(a, b; x)\n"
    "\n"
    ">>> a * x * wright_bessel(a, b+a, x) + (b-1) * wright_bessel(a, b, x)\n"
    "4.5314465939443025")
ufunc_wright_bessel_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_wright_bessel_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_wright_bessel_types[0] = <char>NPY_FLOAT
ufunc_wright_bessel_types[1] = <char>NPY_FLOAT
ufunc_wright_bessel_types[2] = <char>NPY_FLOAT
ufunc_wright_bessel_types[3] = <char>NPY_FLOAT
ufunc_wright_bessel_types[4] = <char>NPY_DOUBLE
ufunc_wright_bessel_types[5] = <char>NPY_DOUBLE
ufunc_wright_bessel_types[6] = <char>NPY_DOUBLE
ufunc_wright_bessel_types[7] = <char>NPY_DOUBLE
ufunc_wright_bessel_ptr[2*0] = <void*>_func_wright_bessel_scalar
ufunc_wright_bessel_ptr[2*0+1] = <void*>(<char*>"wright_bessel")
ufunc_wright_bessel_ptr[2*1] = <void*>_func_wright_bessel_scalar
ufunc_wright_bessel_ptr[2*1+1] = <void*>(<char*>"wright_bessel")
ufunc_wright_bessel_data[0] = &ufunc_wright_bessel_ptr[2*0]
ufunc_wright_bessel_data[1] = &ufunc_wright_bessel_ptr[2*1]
wright_bessel = np.PyUFunc_FromFuncAndData(ufunc_wright_bessel_loops, ufunc_wright_bessel_data, ufunc_wright_bessel_types, 2, 3, 1, 0, "wright_bessel", ufunc_wright_bessel_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_wrightomega_loops[4]
cdef void *ufunc_wrightomega_ptr[8]
cdef void *ufunc_wrightomega_data[4]
cdef char ufunc_wrightomega_types[8]
cdef char *ufunc_wrightomega_doc = (
    "wrightomega(z, out=None)\n"
    "\n"
    "Wright Omega function.\n"
    "\n"
    "Defined as the solution to\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\omega + \\log(\\omega) = z\n"
    "\n"
    "where :math:`\\log` is the principal branch of the complex logarithm.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Points at which to evaluate the Wright Omega function\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "omega : scalar or ndarray\n"
    "    Values of the Wright Omega function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "lambertw : The Lambert W function\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 0.19.0\n"
    "\n"
    "The function can also be defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\omega(z) = W_{K(z)}(e^z)\n"
    "\n"
    "where :math:`K(z) = \\lceil (\\Im(z) - \\pi)/(2\\pi) \\rceil` is the\n"
    "unwinding number and :math:`W` is the Lambert W function.\n"
    "\n"
    "The implementation here is taken from [1]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Lawrence, Corless, and Jeffrey, \"Algorithm 917: Complex\n"
    "       Double-Precision Evaluation of the Wright :math:`\\omega`\n"
    "       Function.\" ACM Transactions on Mathematical Software,\n"
    "       2012. :doi:`10.1145/2168773.2168779`.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import wrightomega, lambertw\n"
    "\n"
    ">>> wrightomega([-2, -1, 0, 1, 2])\n"
    "array([0.12002824, 0.27846454, 0.56714329, 1.        , 1.5571456 ])\n"
    "\n"
    "Complex input:\n"
    "\n"
    ">>> wrightomega(3 + 5j)\n"
    "(1.5804428632097158+3.8213626783287937j)\n"
    "\n"
    "Verify that ``wrightomega(z)`` satisfies ``w + log(w) = z``:\n"
    "\n"
    ">>> w = -5 + 4j\n"
    ">>> wrightomega(w + np.log(w))\n"
    "(-5+4j)\n"
    "\n"
    "Verify the connection to ``lambertw``:\n"
    "\n"
    ">>> z = 0.5 + 3j\n"
    ">>> wrightomega(z)\n"
    "(0.0966015889280649+1.4937828458191993j)\n"
    ">>> lambertw(np.exp(z))\n"
    "(0.09660158892806493+1.4937828458191993j)\n"
    "\n"
    ">>> z = 0.5 + 4j\n"
    ">>> wrightomega(z)\n"
    "(-0.3362123489037213+2.282986001579032j)\n"
    ">>> lambertw(np.exp(z), k=1)\n"
    "(-0.33621234890372115+2.282986001579032j)")
ufunc_wrightomega_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_wrightomega_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_wrightomega_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_wrightomega_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_wrightomega_types[0] = <char>NPY_FLOAT
ufunc_wrightomega_types[1] = <char>NPY_FLOAT
ufunc_wrightomega_types[2] = <char>NPY_DOUBLE
ufunc_wrightomega_types[3] = <char>NPY_DOUBLE
ufunc_wrightomega_types[4] = <char>NPY_CFLOAT
ufunc_wrightomega_types[5] = <char>NPY_CFLOAT
ufunc_wrightomega_types[6] = <char>NPY_CDOUBLE
ufunc_wrightomega_types[7] = <char>NPY_CDOUBLE
ufunc_wrightomega_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_wrightomega_real
ufunc_wrightomega_ptr[2*0+1] = <void*>(<char*>"wrightomega")
ufunc_wrightomega_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_wrightomega_real
ufunc_wrightomega_ptr[2*1+1] = <void*>(<char*>"wrightomega")
ufunc_wrightomega_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_wrightomega
ufunc_wrightomega_ptr[2*2+1] = <void*>(<char*>"wrightomega")
ufunc_wrightomega_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_wrightomega
ufunc_wrightomega_ptr[2*3+1] = <void*>(<char*>"wrightomega")
ufunc_wrightomega_data[0] = &ufunc_wrightomega_ptr[2*0]
ufunc_wrightomega_data[1] = &ufunc_wrightomega_ptr[2*1]
ufunc_wrightomega_data[2] = &ufunc_wrightomega_ptr[2*2]
ufunc_wrightomega_data[3] = &ufunc_wrightomega_ptr[2*3]
wrightomega = np.PyUFunc_FromFuncAndData(ufunc_wrightomega_loops, ufunc_wrightomega_data, ufunc_wrightomega_types, 4, 1, 1, 0, "wrightomega", ufunc_wrightomega_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_xlog1py_loops[4]
cdef void *ufunc_xlog1py_ptr[8]
cdef void *ufunc_xlog1py_data[4]
cdef char ufunc_xlog1py_types[12]
cdef char *ufunc_xlog1py_doc = (
    "xlog1py(x, y, out=None)\n"
    "\n"
    "Compute ``x*log1p(y)`` so that the result is 0 if ``x = 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Multiplier\n"
    "y : array_like\n"
    "    Argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "z : scalar or ndarray\n"
    "    Computed x*log1p(y)\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.13.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    "This example shows how the function can be used to calculate the log of\n"
    "the probability mass function for a geometric discrete random variable.\n"
    "The probability mass function of the geometric distribution is defined\n"
    "as follows:\n"
    "\n"
    ".. math:: f(k) = (1-p)^{k-1} p\n"
    "\n"
    "where :math:`p` is the probability of a single success\n"
    "and :math:`1-p` is the probability of a single failure\n"
    "and :math:`k` is the number of trials to get the first success.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import xlog1py\n"
    ">>> p = 0.5\n"
    ">>> k = 100\n"
    ">>> _pmf = np.power(1 - p, k - 1) * p\n"
    ">>> _pmf\n"
    "7.888609052210118e-31\n"
    "\n"
    "If we take k as a relatively large number the value of the probability\n"
    "mass function can become very low. In such cases taking the log of the\n"
    "pmf would be more suitable as the log function can change the values\n"
    "to a scale that is more appropriate to work with.\n"
    "\n"
    ">>> _log_pmf = xlog1py(k - 1, -p) + np.log(p)\n"
    ">>> _log_pmf\n"
    "-69.31471805599453\n"
    "\n"
    "We can confirm that we get a value close to the original pmf value by\n"
    "taking the exponential of the log pmf.\n"
    "\n"
    ">>> _orig_pmf = np.exp(_log_pmf)\n"
    ">>> np.isclose(_pmf, _orig_pmf)\n"
    "True")
ufunc_xlog1py_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_xlog1py_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_xlog1py_loops[2] = <np.PyUFuncGenericFunction>loop_D_DD__As_FF_F
ufunc_xlog1py_loops[3] = <np.PyUFuncGenericFunction>loop_D_DD__As_DD_D
ufunc_xlog1py_types[0] = <char>NPY_FLOAT
ufunc_xlog1py_types[1] = <char>NPY_FLOAT
ufunc_xlog1py_types[2] = <char>NPY_FLOAT
ufunc_xlog1py_types[3] = <char>NPY_DOUBLE
ufunc_xlog1py_types[4] = <char>NPY_DOUBLE
ufunc_xlog1py_types[5] = <char>NPY_DOUBLE
ufunc_xlog1py_types[6] = <char>NPY_CFLOAT
ufunc_xlog1py_types[7] = <char>NPY_CFLOAT
ufunc_xlog1py_types[8] = <char>NPY_CFLOAT
ufunc_xlog1py_types[9] = <char>NPY_CDOUBLE
ufunc_xlog1py_types[10] = <char>NPY_CDOUBLE
ufunc_xlog1py_types[11] = <char>NPY_CDOUBLE
ufunc_xlog1py_ptr[2*0] = <void*>_func_xlog1py[double]
ufunc_xlog1py_ptr[2*0+1] = <void*>(<char*>"xlog1py")
ufunc_xlog1py_ptr[2*1] = <void*>_func_xlog1py[double]
ufunc_xlog1py_ptr[2*1+1] = <void*>(<char*>"xlog1py")
ufunc_xlog1py_ptr[2*2] = <void*>_func_xlog1py[double_complex]
ufunc_xlog1py_ptr[2*2+1] = <void*>(<char*>"xlog1py")
ufunc_xlog1py_ptr[2*3] = <void*>_func_xlog1py[double_complex]
ufunc_xlog1py_ptr[2*3+1] = <void*>(<char*>"xlog1py")
ufunc_xlog1py_data[0] = &ufunc_xlog1py_ptr[2*0]
ufunc_xlog1py_data[1] = &ufunc_xlog1py_ptr[2*1]
ufunc_xlog1py_data[2] = &ufunc_xlog1py_ptr[2*2]
ufunc_xlog1py_data[3] = &ufunc_xlog1py_ptr[2*3]
xlog1py = np.PyUFunc_FromFuncAndData(ufunc_xlog1py_loops, ufunc_xlog1py_data, ufunc_xlog1py_types, 4, 2, 1, 0, "xlog1py", ufunc_xlog1py_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_xlogy_loops[4]
cdef void *ufunc_xlogy_ptr[8]
cdef void *ufunc_xlogy_data[4]
cdef char ufunc_xlogy_types[12]
cdef char *ufunc_xlogy_doc = (
    "xlogy(x, y, out=None)\n"
    "\n"
    "Compute ``x*log(y)`` so that the result is 0 if ``x = 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Multiplier\n"
    "y : array_like\n"
    "    Argument\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "z : scalar or ndarray\n"
    "    Computed x*log(y)\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The log function used in the computation is the natural log.\n"
    "\n"
    ".. versionadded:: 0.13.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    "We can use this function to calculate the binary logistic loss also\n"
    "known as the binary cross entropy. This loss function is used for\n"
    "binary classification problems and is defined as:\n"
    "\n"
    ".. math::\n"
    "    L = 1/n * \\sum_{i=0}^n -(y_i*log(y\\_pred_i) + (1-y_i)*log(1-y\\_pred_i))\n"
    "\n"
    "We can define the parameters `x` and `y` as y and y_pred respectively.\n"
    "y is the array of the actual labels which over here can be either 0 or 1.\n"
    "y_pred is the array of the predicted probabilities with respect to\n"
    "the positive class (1).\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import xlogy\n"
    ">>> y = np.array([0, 1, 0, 1, 1, 0])\n"
    ">>> y_pred = np.array([0.3, 0.8, 0.4, 0.7, 0.9, 0.2])\n"
    ">>> n = len(y)\n"
    ">>> loss = -(xlogy(y, y_pred) + xlogy(1 - y, 1 - y_pred)).sum()\n"
    ">>> loss /= n\n"
    ">>> loss\n"
    "0.29597052165495025\n"
    "\n"
    "A lower loss is usually better as it indicates that the predictions are\n"
    "similar to the actual labels. In this example since our predicted\n"
    "probabilities are close to the actual labels, we get an overall loss\n"
    "that is reasonably low and appropriate.")
ufunc_xlogy_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_xlogy_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_xlogy_loops[2] = <np.PyUFuncGenericFunction>loop_D_DD__As_FF_F
ufunc_xlogy_loops[3] = <np.PyUFuncGenericFunction>loop_D_DD__As_DD_D
ufunc_xlogy_types[0] = <char>NPY_FLOAT
ufunc_xlogy_types[1] = <char>NPY_FLOAT
ufunc_xlogy_types[2] = <char>NPY_FLOAT
ufunc_xlogy_types[3] = <char>NPY_DOUBLE
ufunc_xlogy_types[4] = <char>NPY_DOUBLE
ufunc_xlogy_types[5] = <char>NPY_DOUBLE
ufunc_xlogy_types[6] = <char>NPY_CFLOAT
ufunc_xlogy_types[7] = <char>NPY_CFLOAT
ufunc_xlogy_types[8] = <char>NPY_CFLOAT
ufunc_xlogy_types[9] = <char>NPY_CDOUBLE
ufunc_xlogy_types[10] = <char>NPY_CDOUBLE
ufunc_xlogy_types[11] = <char>NPY_CDOUBLE
ufunc_xlogy_ptr[2*0] = <void*>_func_xlogy[double]
ufunc_xlogy_ptr[2*0+1] = <void*>(<char*>"xlogy")
ufunc_xlogy_ptr[2*1] = <void*>_func_xlogy[double]
ufunc_xlogy_ptr[2*1+1] = <void*>(<char*>"xlogy")
ufunc_xlogy_ptr[2*2] = <void*>_func_xlogy[double_complex]
ufunc_xlogy_ptr[2*2+1] = <void*>(<char*>"xlogy")
ufunc_xlogy_ptr[2*3] = <void*>_func_xlogy[double_complex]
ufunc_xlogy_ptr[2*3+1] = <void*>(<char*>"xlogy")
ufunc_xlogy_data[0] = &ufunc_xlogy_ptr[2*0]
ufunc_xlogy_data[1] = &ufunc_xlogy_ptr[2*1]
ufunc_xlogy_data[2] = &ufunc_xlogy_ptr[2*2]
ufunc_xlogy_data[3] = &ufunc_xlogy_ptr[2*3]
xlogy = np.PyUFunc_FromFuncAndData(ufunc_xlogy_loops, ufunc_xlogy_data, ufunc_xlogy_types, 4, 2, 1, 0, "xlogy", ufunc_xlogy_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_y0_loops[2]
cdef void *ufunc_y0_ptr[4]
cdef void *ufunc_y0_data[2]
cdef char ufunc_y0_types[4]
cdef char *ufunc_y0_doc = (
    "y0(x, out=None)\n"
    "\n"
    "Bessel function of the second kind of order 0.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Y : scalar or ndarray\n"
    "    Value of the Bessel function of the second kind of order 0 at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "j0: Bessel function of the first kind of order 0\n"
    "yv: Bessel function of the first kind\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The domain is divided into the intervals [0, 5] and (5, infinity). In the\n"
    "first interval a rational approximation :math:`R(x)` is employed to\n"
    "compute,\n"
    "\n"
    ".. math::\n"
    "\n"
    "    Y_0(x) = R(x) + \\frac{2 \\log(x) J_0(x)}{\\pi},\n"
    "\n"
    "where :math:`J_0` is the Bessel function of the first kind of order 0.\n"
    "\n"
    "In the second interval, the Hankel asymptotic expansion is employed with\n"
    "two rational functions of degree 6/6 and 7/7.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `y0`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function at one point:\n"
    "\n"
    ">>> from scipy.special import y0\n"
    ">>> y0(1.)\n"
    "0.08825696421567697\n"
    "\n"
    "Calculate at several points:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> y0(np.array([0.5, 2., 3.]))\n"
    "array([-0.44451873,  0.51037567,  0.37685001])\n"
    "\n"
    "Plot the function from 0 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0., 10., 1000)\n"
    ">>> y = y0(x)\n"
    ">>> ax.plot(x, y)\n"
    ">>> plt.show()")
ufunc_y0_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_y0_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_y0_types[0] = <char>NPY_FLOAT
ufunc_y0_types[1] = <char>NPY_FLOAT
ufunc_y0_types[2] = <char>NPY_DOUBLE
ufunc_y0_types[3] = <char>NPY_DOUBLE
ufunc_y0_ptr[2*0] = <void*>_func_y0
ufunc_y0_ptr[2*0+1] = <void*>(<char*>"y0")
ufunc_y0_ptr[2*1] = <void*>_func_y0
ufunc_y0_ptr[2*1+1] = <void*>(<char*>"y0")
ufunc_y0_data[0] = &ufunc_y0_ptr[2*0]
ufunc_y0_data[1] = &ufunc_y0_ptr[2*1]
y0 = np.PyUFunc_FromFuncAndData(ufunc_y0_loops, ufunc_y0_data, ufunc_y0_types, 2, 1, 1, 0, "y0", ufunc_y0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_y1_loops[2]
cdef void *ufunc_y1_ptr[4]
cdef void *ufunc_y1_data[2]
cdef char ufunc_y1_types[4]
cdef char *ufunc_y1_doc = (
    "y1(x, out=None)\n"
    "\n"
    "Bessel function of the second kind of order 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Y : scalar or ndarray\n"
    "    Value of the Bessel function of the second kind of order 1 at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "j1: Bessel function of the first kind of order 1\n"
    "yn: Bessel function of the second kind\n"
    "yv: Bessel function of the second kind\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The domain is divided into the intervals [0, 8] and (8, infinity). In the\n"
    "first interval a 25 term Chebyshev expansion is used, and computing\n"
    ":math:`J_1` (the Bessel function of the first kind) is required. In the\n"
    "second, the asymptotic trigonometric representation is employed using two\n"
    "rational functions of degree 5/5.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `y1`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Calculate the function at one point:\n"
    "\n"
    ">>> from scipy.special import y1\n"
    ">>> y1(1.)\n"
    "-0.7812128213002888\n"
    "\n"
    "Calculate at several points:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> y1(np.array([0.5, 2., 3.]))\n"
    "array([-1.47147239, -0.10703243,  0.32467442])\n"
    "\n"
    "Plot the function from 0 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0., 10., 1000)\n"
    ">>> y = y1(x)\n"
    ">>> ax.plot(x, y)\n"
    ">>> plt.show()")
ufunc_y1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_y1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_y1_types[0] = <char>NPY_FLOAT
ufunc_y1_types[1] = <char>NPY_FLOAT
ufunc_y1_types[2] = <char>NPY_DOUBLE
ufunc_y1_types[3] = <char>NPY_DOUBLE
ufunc_y1_ptr[2*0] = <void*>_func_y1
ufunc_y1_ptr[2*0+1] = <void*>(<char*>"y1")
ufunc_y1_ptr[2*1] = <void*>_func_y1
ufunc_y1_ptr[2*1+1] = <void*>(<char*>"y1")
ufunc_y1_data[0] = &ufunc_y1_ptr[2*0]
ufunc_y1_data[1] = &ufunc_y1_ptr[2*1]
y1 = np.PyUFunc_FromFuncAndData(ufunc_y1_loops, ufunc_y1_data, ufunc_y1_types, 2, 1, 1, 0, "y1", ufunc_y1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_yn_loops[3]
cdef void *ufunc_yn_ptr[6]
cdef void *ufunc_yn_data[3]
cdef char ufunc_yn_types[9]
cdef char *ufunc_yn_doc = (
    "yn(n, x, out=None)\n"
    "\n"
    "Bessel function of the second kind of integer order and real argument.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Order (integer).\n"
    "x : array_like\n"
    "    Argument (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Y : scalar or ndarray\n"
    "    Value of the Bessel function, :math:`Y_n(x)`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "yv : For real order and real or complex argument.\n"
    "y0: faster implementation of this function for order 0\n"
    "y1: faster implementation of this function for order 1\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `yn`.\n"
    "\n"
    "The function is evaluated by forward recurrence on `n`, starting with\n"
    "values computed by the Cephes routines `y0` and `y1`. If `n = 0` or 1,\n"
    "the routine for `y0` or `y1` is called directly.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the function of order 0 at one point.\n"
    "\n"
    ">>> from scipy.special import yn\n"
    ">>> yn(0, 1.)\n"
    "0.08825696421567697\n"
    "\n"
    "Evaluate the function at one point for different orders.\n"
    "\n"
    ">>> yn(0, 1.), yn(1, 1.), yn(2, 1.)\n"
    "(0.08825696421567697, -0.7812128213002888, -1.6506826068162546)\n"
    "\n"
    "The evaluation for different orders can be carried out in one call by\n"
    "providing a list or NumPy array as argument for the `v` parameter:\n"
    "\n"
    ">>> yn([0, 1, 2], 1.)\n"
    "array([ 0.08825696, -0.78121282, -1.65068261])\n"
    "\n"
    "Evaluate the function at several points for order 0 by providing an\n"
    "array for `z`.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> points = np.array([0.5, 3., 8.])\n"
    ">>> yn(0, points)\n"
    "array([-0.44451873,  0.37685001,  0.22352149])\n"
    "\n"
    "If `z` is an array, the order parameter `v` must be broadcastable to\n"
    "the correct shape if different orders shall be computed in one call.\n"
    "To calculate the orders 0 and 1 for an 1D array:\n"
    "\n"
    ">>> orders = np.array([[0], [1]])\n"
    ">>> orders.shape\n"
    "(2, 1)\n"
    "\n"
    ">>> yn(orders, points)\n"
    "array([[-0.44451873,  0.37685001,  0.22352149],\n"
    "       [-1.47147239,  0.32467442, -0.15806046]])\n"
    "\n"
    "Plot the functions of order 0 to 3 from 0 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0., 10., 1000)\n"
    ">>> for i in range(4):\n"
    "...     ax.plot(x, yn(i, x), label=f'$Y_{i!r}$')\n"
    ">>> ax.set_ylim(-3, 1)\n"
    ">>> ax.legend()\n"
    ">>> plt.show()")
ufunc_yn_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_yn_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_yn_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_yn_types[0] = <char>NPY_LONG
ufunc_yn_types[1] = <char>NPY_DOUBLE
ufunc_yn_types[2] = <char>NPY_DOUBLE
ufunc_yn_types[3] = <char>NPY_FLOAT
ufunc_yn_types[4] = <char>NPY_FLOAT
ufunc_yn_types[5] = <char>NPY_FLOAT
ufunc_yn_types[6] = <char>NPY_DOUBLE
ufunc_yn_types[7] = <char>NPY_DOUBLE
ufunc_yn_types[8] = <char>NPY_DOUBLE
ufunc_yn_ptr[2*0] = <void*>_func_yn
ufunc_yn_ptr[2*0+1] = <void*>(<char*>"yn")
ufunc_yn_ptr[2*1] = <void*>_func_yn_unsafe
ufunc_yn_ptr[2*1+1] = <void*>(<char*>"yn")
ufunc_yn_ptr[2*2] = <void*>_func_yn_unsafe
ufunc_yn_ptr[2*2+1] = <void*>(<char*>"yn")
ufunc_yn_data[0] = &ufunc_yn_ptr[2*0]
ufunc_yn_data[1] = &ufunc_yn_ptr[2*1]
ufunc_yn_data[2] = &ufunc_yn_ptr[2*2]
yn = np.PyUFunc_FromFuncAndData(ufunc_yn_loops, ufunc_yn_data, ufunc_yn_types, 3, 2, 1, 0, "yn", ufunc_yn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_yv_loops[4]
cdef void *ufunc_yv_ptr[8]
cdef void *ufunc_yv_data[4]
cdef char ufunc_yv_types[12]
cdef char *ufunc_yv_doc = (
    "yv(v, z, out=None)\n"
    "\n"
    "Bessel function of the second kind of real order and complex argument.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Y : scalar or ndarray\n"
    "    Value of the Bessel function of the second kind, :math:`Y_v(x)`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "yve : :math:`Y_v` with leading exponential behavior stripped off.\n"
    "y0: faster implementation of this function for order 0\n"
    "y1: faster implementation of this function for order 1\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For positive `v` values, the computation is carried out using the\n"
    "AMOS [1]_ `zbesy` routine, which exploits the connection to the Hankel\n"
    "Bessel functions :math:`H_v^{(1)}` and :math:`H_v^{(2)}`,\n"
    "\n"
    ".. math:: Y_v(z) = \\frac{1}{2\\imath} (H_v^{(1)} - H_v^{(2)}).\n"
    "\n"
    "For negative `v` values the formula,\n"
    "\n"
    ".. math:: Y_{-v}(z) = Y_v(z) \\cos(\\pi v) + J_v(z) \\sin(\\pi v)\n"
    "\n"
    "is used, where :math:`J_v(z)` is the Bessel function of the first kind,\n"
    "computed using the AMOS routine `zbesj`.  Note that the second term is\n"
    "exactly zero for integer `v`; to improve accuracy the second term is\n"
    "explicitly omitted for `v` values such that `v = floor(v)`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the function of order 0 at one point.\n"
    "\n"
    ">>> from scipy.special import yv\n"
    ">>> yv(0, 1.)\n"
    "0.088256964215677\n"
    "\n"
    "Evaluate the function at one point for different orders.\n"
    "\n"
    ">>> yv(0, 1.), yv(1, 1.), yv(1.5, 1.)\n"
    "(0.088256964215677, -0.7812128213002889, -1.102495575160179)\n"
    "\n"
    "The evaluation for different orders can be carried out in one call by\n"
    "providing a list or NumPy array as argument for the `v` parameter:\n"
    "\n"
    ">>> yv([0, 1, 1.5], 1.)\n"
    "array([ 0.08825696, -0.78121282, -1.10249558])\n"
    "\n"
    "Evaluate the function at several points for order 0 by providing an\n"
    "array for `z`.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> points = np.array([0.5, 3., 8.])\n"
    ">>> yv(0, points)\n"
    "array([-0.44451873,  0.37685001,  0.22352149])\n"
    "\n"
    "If `z` is an array, the order parameter `v` must be broadcastable to\n"
    "the correct shape if different orders shall be computed in one call.\n"
    "To calculate the orders 0 and 1 for an 1D array:\n"
    "\n"
    ">>> orders = np.array([[0], [1]])\n"
    ">>> orders.shape\n"
    "(2, 1)\n"
    "\n"
    ">>> yv(orders, points)\n"
    "array([[-0.44451873,  0.37685001,  0.22352149],\n"
    "       [-1.47147239,  0.32467442, -0.15806046]])\n"
    "\n"
    "Plot the functions of order 0 to 3 from 0 to 10.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> x = np.linspace(0., 10., 1000)\n"
    ">>> for i in range(4):\n"
    "...     ax.plot(x, yv(i, x), label=f'$Y_{i!r}$')\n"
    ">>> ax.set_ylim(-3, 1)\n"
    ">>> ax.legend()\n"
    ">>> plt.show()")
ufunc_yv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_yv_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_yv_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_yv_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_yv_types[0] = <char>NPY_FLOAT
ufunc_yv_types[1] = <char>NPY_FLOAT
ufunc_yv_types[2] = <char>NPY_FLOAT
ufunc_yv_types[3] = <char>NPY_FLOAT
ufunc_yv_types[4] = <char>NPY_CFLOAT
ufunc_yv_types[5] = <char>NPY_CFLOAT
ufunc_yv_types[6] = <char>NPY_DOUBLE
ufunc_yv_types[7] = <char>NPY_DOUBLE
ufunc_yv_types[8] = <char>NPY_DOUBLE
ufunc_yv_types[9] = <char>NPY_DOUBLE
ufunc_yv_types[10] = <char>NPY_CDOUBLE
ufunc_yv_types[11] = <char>NPY_CDOUBLE
ufunc_yv_ptr[2*0] = <void*>_func_cbesy_wrap_real
ufunc_yv_ptr[2*0+1] = <void*>(<char*>"yv")
ufunc_yv_ptr[2*1] = <void*>_func_cbesy_wrap
ufunc_yv_ptr[2*1+1] = <void*>(<char*>"yv")
ufunc_yv_ptr[2*2] = <void*>_func_cbesy_wrap_real
ufunc_yv_ptr[2*2+1] = <void*>(<char*>"yv")
ufunc_yv_ptr[2*3] = <void*>_func_cbesy_wrap
ufunc_yv_ptr[2*3+1] = <void*>(<char*>"yv")
ufunc_yv_data[0] = &ufunc_yv_ptr[2*0]
ufunc_yv_data[1] = &ufunc_yv_ptr[2*1]
ufunc_yv_data[2] = &ufunc_yv_ptr[2*2]
ufunc_yv_data[3] = &ufunc_yv_ptr[2*3]
yv = np.PyUFunc_FromFuncAndData(ufunc_yv_loops, ufunc_yv_data, ufunc_yv_types, 4, 2, 1, 0, "yv", ufunc_yv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_yve_loops[4]
cdef void *ufunc_yve_ptr[8]
cdef void *ufunc_yve_data[4]
cdef char ufunc_yve_types[12]
cdef char *ufunc_yve_doc = (
    "yve(v, z, out=None)\n"
    "\n"
    "Exponentially scaled Bessel function of the second kind of real order.\n"
    "\n"
    "Returns the exponentially scaled Bessel function of the second\n"
    "kind of real order `v` at complex `z`::\n"
    "\n"
    "    yve(v, z) = yv(v, z) * exp(-abs(z.imag))\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Y : scalar or ndarray\n"
    "    Value of the exponentially scaled Bessel function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "yv: Unscaled Bessel function of the second kind of real order.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For positive `v` values, the computation is carried out using the\n"
    "AMOS [1]_ `zbesy` routine, which exploits the connection to the Hankel\n"
    "Bessel functions :math:`H_v^{(1)}` and :math:`H_v^{(2)}`,\n"
    "\n"
    ".. math:: Y_v(z) = \\frac{1}{2\\imath} (H_v^{(1)} - H_v^{(2)}).\n"
    "\n"
    "For negative `v` values the formula,\n"
    "\n"
    ".. math:: Y_{-v}(z) = Y_v(z) \\cos(\\pi v) + J_v(z) \\sin(\\pi v)\n"
    "\n"
    "is used, where :math:`J_v(z)` is the Bessel function of the first kind,\n"
    "computed using the AMOS routine `zbesj`.  Note that the second term is\n"
    "exactly zero for integer `v`; to improve accuracy the second term is\n"
    "explicitly omitted for `v` values such that `v = floor(v)`.\n"
    "\n"
    "Exponentially scaled Bessel functions are useful for large `z`:\n"
    "for these, the unscaled Bessel functions can easily under-or overflow.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compare the output of `yv` and `yve` for large complex arguments for `z`\n"
    "by computing their values for order ``v=1`` at ``z=1000j``. We see that\n"
    "`yv` returns nan but `yve` returns a finite number:\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import yv, yve\n"
    ">>> v = 1\n"
    ">>> z = 1000j\n"
    ">>> yv(v, z), yve(v, z)\n"
    "((nan+nanj), (-0.012610930256928629+7.721967686709076e-19j))\n"
    "\n"
    "For real arguments for `z`, `yve` returns the same as `yv` up to\n"
    "floating point errors.\n"
    "\n"
    ">>> v, z = 1, 1000\n"
    ">>> yv(v, z), yve(v, z)\n"
    "(-0.02478433129235178, -0.02478433129235179)\n"
    "\n"
    "The function can be evaluated for several orders at the same time by\n"
    "providing a list or NumPy array for `v`:\n"
    "\n"
    ">>> yve([1, 2, 3], 1j)\n"
    "array([-0.20791042+0.14096627j,  0.38053618-0.04993878j,\n"
    "       0.00815531-1.66311097j])\n"
    "\n"
    "In the same way, the function can be evaluated at several points in one\n"
    "call by providing a list or NumPy array for `z`:\n"
    "\n"
    ">>> yve(1, np.array([1j, 2j, 3j]))\n"
    "array([-0.20791042+0.14096627j, -0.21526929+0.01205044j,\n"
    "       -0.19682671+0.00127278j])\n"
    "\n"
    "It is also possible to evaluate several orders at several points\n"
    "at the same time by providing arrays for `v` and `z` with\n"
    "broadcasting compatible shapes. Compute `yve` for two different orders\n"
    "`v` and three points `z` resulting in a 2x3 array.\n"
    "\n"
    ">>> v = np.array([[1], [2]])\n"
    ">>> z = np.array([3j, 4j, 5j])\n"
    ">>> v.shape, z.shape\n"
    "((2, 1), (3,))\n"
    "\n"
    ">>> yve(v, z)\n"
    "array([[-1.96826713e-01+1.27277544e-03j, -1.78750840e-01+1.45558819e-04j,\n"
    "        -1.63972267e-01+1.73494110e-05j],\n"
    "       [1.94960056e-03-1.11782545e-01j,  2.02902325e-04-1.17626501e-01j,\n"
    "        2.27727687e-05-1.17951906e-01j]])")
ufunc_yve_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_yve_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_yve_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_yve_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_yve_types[0] = <char>NPY_FLOAT
ufunc_yve_types[1] = <char>NPY_FLOAT
ufunc_yve_types[2] = <char>NPY_FLOAT
ufunc_yve_types[3] = <char>NPY_FLOAT
ufunc_yve_types[4] = <char>NPY_CFLOAT
ufunc_yve_types[5] = <char>NPY_CFLOAT
ufunc_yve_types[6] = <char>NPY_DOUBLE
ufunc_yve_types[7] = <char>NPY_DOUBLE
ufunc_yve_types[8] = <char>NPY_DOUBLE
ufunc_yve_types[9] = <char>NPY_DOUBLE
ufunc_yve_types[10] = <char>NPY_CDOUBLE
ufunc_yve_types[11] = <char>NPY_CDOUBLE
ufunc_yve_ptr[2*0] = <void*>_func_cbesy_wrap_e_real
ufunc_yve_ptr[2*0+1] = <void*>(<char*>"yve")
ufunc_yve_ptr[2*1] = <void*>_func_cbesy_wrap_e
ufunc_yve_ptr[2*1+1] = <void*>(<char*>"yve")
ufunc_yve_ptr[2*2] = <void*>_func_cbesy_wrap_e_real
ufunc_yve_ptr[2*2+1] = <void*>(<char*>"yve")
ufunc_yve_ptr[2*3] = <void*>_func_cbesy_wrap_e
ufunc_yve_ptr[2*3+1] = <void*>(<char*>"yve")
ufunc_yve_data[0] = &ufunc_yve_ptr[2*0]
ufunc_yve_data[1] = &ufunc_yve_ptr[2*1]
ufunc_yve_data[2] = &ufunc_yve_ptr[2*2]
ufunc_yve_data[3] = &ufunc_yve_ptr[2*3]
yve = np.PyUFunc_FromFuncAndData(ufunc_yve_loops, ufunc_yve_data, ufunc_yve_types, 4, 2, 1, 0, "yve", ufunc_yve_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_zetac_loops[2]
cdef void *ufunc_zetac_ptr[4]
cdef void *ufunc_zetac_data[2]
cdef char ufunc_zetac_types[4]
cdef char *ufunc_zetac_doc = (
    "zetac(x, out=None)\n"
    "\n"
    "Riemann zeta function minus 1.\n"
    "\n"
    "This function is defined as\n"
    "\n"
    ".. math:: \\zeta(x) = \\sum_{k=2}^{\\infty} 1 / k^x,\n"
    "\n"
    "where ``x > 1``.  For ``x < 1`` the analytic continuation is\n"
    "computed. For more information on the Riemann zeta function, see\n"
    "[dlmf]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like of float\n"
    "    Values at which to compute zeta(x) - 1 (must be real).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of zeta(x) - 1.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "zeta\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [dlmf] NIST Digital Library of Mathematical Functions\n"
    "          https://dlmf.nist.gov/25\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import zetac, zeta\n"
    "\n"
    "Some special values:\n"
    "\n"
    ">>> zetac(2), np.pi**2/6 - 1\n"
    "(0.64493406684822641, 0.6449340668482264)\n"
    "\n"
    ">>> zetac(-1), -1.0/12 - 1\n"
    "(-1.0833333333333333, -1.0833333333333333)\n"
    "\n"
    "Compare ``zetac(x)`` to ``zeta(x) - 1`` for large `x`:\n"
    "\n"
    ">>> zetac(60), zeta(60) - 1\n"
    "(8.673617380119933e-19, 0.0)")
ufunc_zetac_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_zetac_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_zetac_types[0] = <char>NPY_FLOAT
ufunc_zetac_types[1] = <char>NPY_FLOAT
ufunc_zetac_types[2] = <char>NPY_DOUBLE
ufunc_zetac_types[3] = <char>NPY_DOUBLE
ufunc_zetac_ptr[2*0] = <void*>_func_zetac
ufunc_zetac_ptr[2*0+1] = <void*>(<char*>"zetac")
ufunc_zetac_ptr[2*1] = <void*>_func_zetac
ufunc_zetac_ptr[2*1+1] = <void*>(<char*>"zetac")
ufunc_zetac_data[0] = &ufunc_zetac_ptr[2*0]
ufunc_zetac_data[1] = &ufunc_zetac_ptr[2*1]
zetac = np.PyUFunc_FromFuncAndData(ufunc_zetac_loops, ufunc_zetac_data, ufunc_zetac_types, 2, 1, 1, 0, "zetac", ufunc_zetac_doc, 0)

#
# Aliases
#
jn = jv
