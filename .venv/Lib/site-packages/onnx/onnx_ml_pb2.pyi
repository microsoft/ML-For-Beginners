# @generated by protoc-gen-mypy.py.  Do not edit!
# mypy: disable-error-code=override
from typing import (
    Iterable,
    List,
    Optional as OptionalType,
    Tuple,
    cast,
)

from google.protobuf.message import (  # type: ignore
    Message,
)

from google.protobuf.internal.containers import (  # type: ignore
    RepeatedCompositeFieldContainer,
    RepeatedScalarFieldContainer,
)

class Version(int):
    @classmethod
    def Name(cls, number: int) -> str: ...
    @classmethod
    def Value(cls, name: str) -> int: ...
    @classmethod
    def keys(cls) -> List[str]: ...
    @classmethod
    def values(cls) -> List[int]: ...
    @classmethod
    def items(cls) -> List[Tuple[str, int]]: ...
_START_VERSION = cast(Version, 0)
IR_VERSION_2017_10_10 = cast(Version, 1)
IR_VERSION_2017_10_30 = cast(Version, 2)
IR_VERSION_2017_11_3 = cast(Version, 3)
IR_VERSION_2019_1_22 = cast(Version, 4)
IR_VERSION_2019_3_18 = cast(Version, 5)
IR_VERSION_2019_9_19 = cast(Version, 6)
IR_VERSION_2020_5_8 = cast(Version, 7)
IR_VERSION_2021_7_30 = cast(Version, 8)
IR_VERSION = cast(Version, 9)

class OperatorStatus(int):
    @classmethod
    def Name(cls, number: int) -> str: ...
    @classmethod
    def Value(cls, name: str) -> int: ...
    @classmethod
    def keys(cls) -> List[str]: ...
    @classmethod
    def values(cls) -> List[int]: ...
    @classmethod
    def items(cls) -> List[Tuple[str, int]]: ...
EXPERIMENTAL = cast(OperatorStatus, 0)
STABLE = cast(OperatorStatus, 1)

class AttributeProto(Message):
    class AttributeType(int):
        @classmethod
        def Name(cls, number: int) -> str: ...
        @classmethod
        def Value(cls, name: str) -> int: ...
        @classmethod
        def keys(cls) -> List[str]: ...
        @classmethod
        def values(cls) -> List[int]: ...
        @classmethod
        def items(cls) -> List[Tuple[str, int]]: ...
    UNDEFINED = cast(AttributeType, 0)
    FLOAT = cast(AttributeType, 1)
    INT = cast(AttributeType, 2)
    STRING = cast(AttributeType, 3)
    TENSOR = cast(AttributeType, 4)
    GRAPH = cast(AttributeType, 5)
    SPARSE_TENSOR = cast(AttributeType, 11)
    TYPE_PROTO = cast(AttributeType, 13)
    FLOATS = cast(AttributeType, 6)
    INTS = cast(AttributeType, 7)
    STRINGS = cast(AttributeType, 8)
    TENSORS = cast(AttributeType, 9)
    GRAPHS = cast(AttributeType, 10)
    SPARSE_TENSORS = cast(AttributeType, 12)
    TYPE_PROTOS = cast(AttributeType, 14)
    
    name = ... # type: str
    ref_attr_name = ... # type: str
    doc_string = ... # type: str
    type = ... # type: AttributeProto.AttributeType
    f = ... # type: float
    i = ... # type: int
    s = ... # type: bytes
    floats = ... # type: RepeatedScalarFieldContainer[float]
    ints = ... # type: RepeatedScalarFieldContainer[int]
    strings = ... # type: RepeatedScalarFieldContainer[bytes]
    
    @property
    def t(self) -> TensorProto: ...
    
    @property
    def g(self) -> GraphProto: ...
    
    @property
    def sparse_tensor(self) -> SparseTensorProto: ...
    
    @property
    def tp(self) -> TypeProto: ...
    
    @property
    def tensors(self) -> RepeatedCompositeFieldContainer[TensorProto]: ...
    
    @property
    def graphs(self) -> RepeatedCompositeFieldContainer[GraphProto]: ...
    
    @property
    def sparse_tensors(self) -> RepeatedCompositeFieldContainer[SparseTensorProto]: ...
    
    @property
    def type_protos(self) -> RepeatedCompositeFieldContainer[TypeProto]: ...
    
    def __init__(self,
        name : OptionalType[str] = None,
        ref_attr_name : OptionalType[str] = None,
        doc_string : OptionalType[str] = None,
        type : OptionalType[AttributeProto.AttributeType] = None,
        f : OptionalType[float] = None,
        i : OptionalType[int] = None,
        s : OptionalType[bytes] = None,
        t : OptionalType[TensorProto] = None,
        g : OptionalType[GraphProto] = None,
        sparse_tensor : OptionalType[SparseTensorProto] = None,
        tp : OptionalType[TypeProto] = None,
        floats : OptionalType[Iterable[float]] = None,
        ints : OptionalType[Iterable[int]] = None,
        strings : OptionalType[Iterable[bytes]] = None,
        tensors : OptionalType[Iterable[TensorProto]] = None,
        graphs : OptionalType[Iterable[GraphProto]] = None,
        sparse_tensors : OptionalType[Iterable[SparseTensorProto]] = None,
        type_protos : OptionalType[Iterable[TypeProto]] = None,
        ) -> None: ...
    @classmethod
    def FromString(cls, s: bytes) -> AttributeProto: ...
    def MergeFrom(self, other_msg: Message) -> None: ...
    def CopyFrom(self, other_msg: Message) -> None: ...

class ValueInfoProto(Message):
    name = ... # type: str
    doc_string = ... # type: str
    
    @property
    def type(self) -> TypeProto: ...
    
    def __init__(self,
        name : OptionalType[str] = None,
        type : OptionalType[TypeProto] = None,
        doc_string : OptionalType[str] = None,
        ) -> None: ...
    @classmethod
    def FromString(cls, s: bytes) -> ValueInfoProto: ...
    def MergeFrom(self, other_msg: Message) -> None: ...
    def CopyFrom(self, other_msg: Message) -> None: ...

class NodeProto(Message):
    input = ... # type: RepeatedScalarFieldContainer[str]
    output = ... # type: RepeatedScalarFieldContainer[str]
    name = ... # type: str
    op_type = ... # type: str
    domain = ... # type: str
    doc_string = ... # type: str
    
    @property
    def attribute(self) -> RepeatedCompositeFieldContainer[AttributeProto]: ...
    
    def __init__(self,
        input : OptionalType[Iterable[str]] = None,
        output : OptionalType[Iterable[str]] = None,
        name : OptionalType[str] = None,
        op_type : OptionalType[str] = None,
        domain : OptionalType[str] = None,
        attribute : OptionalType[Iterable[AttributeProto]] = None,
        doc_string : OptionalType[str] = None,
        ) -> None: ...
    @classmethod
    def FromString(cls, s: bytes) -> NodeProto: ...
    def MergeFrom(self, other_msg: Message) -> None: ...
    def CopyFrom(self, other_msg: Message) -> None: ...

class TrainingInfoProto(Message):
    
    @property
    def initialization(self) -> GraphProto: ...
    
    @property
    def algorithm(self) -> GraphProto: ...
    
    @property
    def initialization_binding(self) -> RepeatedCompositeFieldContainer[StringStringEntryProto]: ...
    
    @property
    def update_binding(self) -> RepeatedCompositeFieldContainer[StringStringEntryProto]: ...
    
    def __init__(self,
        initialization : OptionalType[GraphProto] = None,
        algorithm : OptionalType[GraphProto] = None,
        initialization_binding : OptionalType[Iterable[StringStringEntryProto]] = None,
        update_binding : OptionalType[Iterable[StringStringEntryProto]] = None,
        ) -> None: ...
    @classmethod
    def FromString(cls, s: bytes) -> TrainingInfoProto: ...
    def MergeFrom(self, other_msg: Message) -> None: ...
    def CopyFrom(self, other_msg: Message) -> None: ...

class ModelProto(Message):
    ir_version = ... # type: int
    producer_name = ... # type: str
    producer_version = ... # type: str
    domain = ... # type: str
    model_version = ... # type: int
    doc_string = ... # type: str
    
    @property
    def opset_import(self) -> RepeatedCompositeFieldContainer[OperatorSetIdProto]: ...
    
    @property
    def graph(self) -> GraphProto: ...
    
    @property
    def metadata_props(self) -> RepeatedCompositeFieldContainer[StringStringEntryProto]: ...
    
    @property
    def training_info(self) -> RepeatedCompositeFieldContainer[TrainingInfoProto]: ...
    
    @property
    def functions(self) -> RepeatedCompositeFieldContainer[FunctionProto]: ...
    
    def __init__(self,
        ir_version : OptionalType[int] = None,
        opset_import : OptionalType[Iterable[OperatorSetIdProto]] = None,
        producer_name : OptionalType[str] = None,
        producer_version : OptionalType[str] = None,
        domain : OptionalType[str] = None,
        model_version : OptionalType[int] = None,
        doc_string : OptionalType[str] = None,
        graph : OptionalType[GraphProto] = None,
        metadata_props : OptionalType[Iterable[StringStringEntryProto]] = None,
        training_info : OptionalType[Iterable[TrainingInfoProto]] = None,
        functions : OptionalType[Iterable[FunctionProto]] = None,
        ) -> None: ...
    @classmethod
    def FromString(cls, s: bytes) -> ModelProto: ...
    def MergeFrom(self, other_msg: Message) -> None: ...
    def CopyFrom(self, other_msg: Message) -> None: ...

class StringStringEntryProto(Message):
    key = ... # type: str
    value = ... # type: str
    
    def __init__(self,
        key : OptionalType[str] = None,
        value : OptionalType[str] = None,
        ) -> None: ...
    @classmethod
    def FromString(cls, s: bytes) -> StringStringEntryProto: ...
    def MergeFrom(self, other_msg: Message) -> None: ...
    def CopyFrom(self, other_msg: Message) -> None: ...

class TensorAnnotation(Message):
    tensor_name = ... # type: str
    
    @property
    def quant_parameter_tensor_names(self) -> RepeatedCompositeFieldContainer[StringStringEntryProto]: ...
    
    def __init__(self,
        tensor_name : OptionalType[str] = None,
        quant_parameter_tensor_names : OptionalType[Iterable[StringStringEntryProto]] = None,
        ) -> None: ...
    @classmethod
    def FromString(cls, s: bytes) -> TensorAnnotation: ...
    def MergeFrom(self, other_msg: Message) -> None: ...
    def CopyFrom(self, other_msg: Message) -> None: ...

class GraphProto(Message):
    name = ... # type: str
    doc_string = ... # type: str
    
    @property
    def node(self) -> RepeatedCompositeFieldContainer[NodeProto]: ...
    
    @property
    def initializer(self) -> RepeatedCompositeFieldContainer[TensorProto]: ...
    
    @property
    def sparse_initializer(self) -> RepeatedCompositeFieldContainer[SparseTensorProto]: ...
    
    @property
    def input(self) -> RepeatedCompositeFieldContainer[ValueInfoProto]: ...
    
    @property
    def output(self) -> RepeatedCompositeFieldContainer[ValueInfoProto]: ...
    
    @property
    def value_info(self) -> RepeatedCompositeFieldContainer[ValueInfoProto]: ...
    
    @property
    def quantization_annotation(self) -> RepeatedCompositeFieldContainer[TensorAnnotation]: ...
    
    def __init__(self,
        node : OptionalType[Iterable[NodeProto]] = None,
        name : OptionalType[str] = None,
        initializer : OptionalType[Iterable[TensorProto]] = None,
        sparse_initializer : OptionalType[Iterable[SparseTensorProto]] = None,
        doc_string : OptionalType[str] = None,
        input : OptionalType[Iterable[ValueInfoProto]] = None,
        output : OptionalType[Iterable[ValueInfoProto]] = None,
        value_info : OptionalType[Iterable[ValueInfoProto]] = None,
        quantization_annotation : OptionalType[Iterable[TensorAnnotation]] = None,
        ) -> None: ...
    @classmethod
    def FromString(cls, s: bytes) -> GraphProto: ...
    def MergeFrom(self, other_msg: Message) -> None: ...
    def CopyFrom(self, other_msg: Message) -> None: ...

class TensorProto(Message):
    class DataType(int):
        @classmethod
        def Name(cls, number: int) -> str: ...
        @classmethod
        def Value(cls, name: str) -> int: ...
        @classmethod
        def keys(cls) -> List[str]: ...
        @classmethod
        def values(cls) -> List[int]: ...
        @classmethod
        def items(cls) -> List[Tuple[str, int]]: ...
    UNDEFINED = cast(DataType, 0)
    FLOAT = cast(DataType, 1)
    UINT8 = cast(DataType, 2)
    INT8 = cast(DataType, 3)
    UINT16 = cast(DataType, 4)
    INT16 = cast(DataType, 5)
    INT32 = cast(DataType, 6)
    INT64 = cast(DataType, 7)
    STRING = cast(DataType, 8)
    BOOL = cast(DataType, 9)
    FLOAT16 = cast(DataType, 10)
    DOUBLE = cast(DataType, 11)
    UINT32 = cast(DataType, 12)
    UINT64 = cast(DataType, 13)
    COMPLEX64 = cast(DataType, 14)
    COMPLEX128 = cast(DataType, 15)
    BFLOAT16 = cast(DataType, 16)
    FLOAT8E4M3FN = cast(DataType, 17)
    FLOAT8E4M3FNUZ = cast(DataType, 18)
    FLOAT8E5M2 = cast(DataType, 19)
    FLOAT8E5M2FNUZ = cast(DataType, 20)
    
    class DataLocation(int):
        @classmethod
        def Name(cls, number: int) -> str: ...
        @classmethod
        def Value(cls, name: str) -> int: ...
        @classmethod
        def keys(cls) -> List[str]: ...
        @classmethod
        def values(cls) -> List[int]: ...
        @classmethod
        def items(cls) -> List[Tuple[str, int]]: ...
    DEFAULT = cast(DataLocation, 0)
    EXTERNAL = cast(DataLocation, 1)
    
    class Segment(Message):
        begin = ... # type: int
        end = ... # type: int
        
        def __init__(self,
            begin : OptionalType[int] = None,
            end : OptionalType[int] = None,
            ) -> None: ...
        @classmethod
        def FromString(cls, s: bytes) -> TensorProto.Segment: ...
        def MergeFrom(self, other_msg: Message) -> None: ...
        def CopyFrom(self, other_msg: Message) -> None: ...
    
    dims = ... # type: RepeatedScalarFieldContainer[int]
    data_type = ... # type: int
    float_data = ... # type: RepeatedScalarFieldContainer[float]
    int32_data = ... # type: RepeatedScalarFieldContainer[int]
    string_data = ... # type: RepeatedScalarFieldContainer[bytes]
    int64_data = ... # type: RepeatedScalarFieldContainer[int]
    name = ... # type: str
    doc_string = ... # type: str
    raw_data = ... # type: bytes
    data_location = ... # type: TensorProto.DataLocation
    double_data = ... # type: RepeatedScalarFieldContainer[float]
    uint64_data = ... # type: RepeatedScalarFieldContainer[int]
    
    @property
    def segment(self) -> TensorProto.Segment: ...
    
    @property
    def external_data(self) -> RepeatedCompositeFieldContainer[StringStringEntryProto]: ...
    
    def __init__(self,
        dims : OptionalType[Iterable[int]] = None,
        data_type : OptionalType[int] = None,
        segment : OptionalType[TensorProto.Segment] = None,
        float_data : OptionalType[Iterable[float]] = None,
        int32_data : OptionalType[Iterable[int]] = None,
        string_data : OptionalType[Iterable[bytes]] = None,
        int64_data : OptionalType[Iterable[int]] = None,
        name : OptionalType[str] = None,
        doc_string : OptionalType[str] = None,
        raw_data : OptionalType[bytes] = None,
        external_data : OptionalType[Iterable[StringStringEntryProto]] = None,
        data_location : OptionalType[TensorProto.DataLocation] = None,
        double_data : OptionalType[Iterable[float]] = None,
        uint64_data : OptionalType[Iterable[int]] = None,
        ) -> None: ...
    @classmethod
    def FromString(cls, s: bytes) -> TensorProto: ...
    def MergeFrom(self, other_msg: Message) -> None: ...
    def CopyFrom(self, other_msg: Message) -> None: ...

class SparseTensorProto(Message):
    dims = ... # type: RepeatedScalarFieldContainer[int]
    
    @property
    def values(self) -> TensorProto: ...
    
    @property
    def indices(self) -> TensorProto: ...
    
    def __init__(self,
        values : OptionalType[TensorProto] = None,
        indices : OptionalType[TensorProto] = None,
        dims : OptionalType[Iterable[int]] = None,
        ) -> None: ...
    @classmethod
    def FromString(cls, s: bytes) -> SparseTensorProto: ...
    def MergeFrom(self, other_msg: Message) -> None: ...
    def CopyFrom(self, other_msg: Message) -> None: ...

class TensorShapeProto(Message):
    class Dimension(Message):
        dim_value = ... # type: int
        dim_param = ... # type: str
        denotation = ... # type: str
        
        def __init__(self,
            dim_value : OptionalType[int] = None,
            dim_param : OptionalType[str] = None,
            denotation : OptionalType[str] = None,
            ) -> None: ...
        @classmethod
        def FromString(cls, s: bytes) -> TensorShapeProto.Dimension: ...
        def MergeFrom(self, other_msg: Message) -> None: ...
        def CopyFrom(self, other_msg: Message) -> None: ...
    
    
    @property
    def dim(self) -> RepeatedCompositeFieldContainer[TensorShapeProto.Dimension]: ...
    
    def __init__(self,
        dim : OptionalType[Iterable[TensorShapeProto.Dimension]] = None,
        ) -> None: ...
    @classmethod
    def FromString(cls, s: bytes) -> TensorShapeProto: ...
    def MergeFrom(self, other_msg: Message) -> None: ...
    def CopyFrom(self, other_msg: Message) -> None: ...

class TypeProto(Message):
    class Tensor(Message):
        elem_type = ... # type: int
        
        @property
        def shape(self) -> TensorShapeProto: ...
        
        def __init__(self,
            elem_type : OptionalType[int] = None,
            shape : OptionalType[TensorShapeProto] = None,
            ) -> None: ...
        @classmethod
        def FromString(cls, s: bytes) -> TypeProto.Tensor: ...
        def MergeFrom(self, other_msg: Message) -> None: ...
        def CopyFrom(self, other_msg: Message) -> None: ...
    
    class Sequence(Message):
        
        @property
        def elem_type(self) -> TypeProto: ...
        
        def __init__(self,
            elem_type : OptionalType[TypeProto] = None,
            ) -> None: ...
        @classmethod
        def FromString(cls, s: bytes) -> TypeProto.Sequence: ...
        def MergeFrom(self, other_msg: Message) -> None: ...
        def CopyFrom(self, other_msg: Message) -> None: ...
    
    class Map(Message):
        key_type = ... # type: int
        
        @property
        def value_type(self) -> TypeProto: ...
        
        def __init__(self,
            key_type : OptionalType[int] = None,
            value_type : OptionalType[TypeProto] = None,
            ) -> None: ...
        @classmethod
        def FromString(cls, s: bytes) -> TypeProto.Map: ...
        def MergeFrom(self, other_msg: Message) -> None: ...
        def CopyFrom(self, other_msg: Message) -> None: ...
    
    class Optional(Message):
        
        @property
        def elem_type(self) -> TypeProto: ...
        
        def __init__(self,
            elem_type : OptionalType[TypeProto] = None,
            ) -> None: ...
        @classmethod
        def FromString(cls, s: bytes) -> TypeProto.Optional: ...
        def MergeFrom(self, other_msg: Message) -> None: ...
        def CopyFrom(self, other_msg: Message) -> None: ...
    
    class SparseTensor(Message):
        elem_type = ... # type: int
        
        @property
        def shape(self) -> TensorShapeProto: ...
        
        def __init__(self,
            elem_type : OptionalType[int] = None,
            shape : OptionalType[TensorShapeProto] = None,
            ) -> None: ...
        @classmethod
        def FromString(cls, s: bytes) -> TypeProto.SparseTensor: ...
        def MergeFrom(self, other_msg: Message) -> None: ...
        def CopyFrom(self, other_msg: Message) -> None: ...
    
    class Opaque(Message):
        domain = ... # type: str
        name = ... # type: str
        
        def __init__(self,
            domain : OptionalType[str] = None,
            name : OptionalType[str] = None,
            ) -> None: ...
        @classmethod
        def FromString(cls, s: bytes) -> TypeProto.Opaque: ...
        def MergeFrom(self, other_msg: Message) -> None: ...
        def CopyFrom(self, other_msg: Message) -> None: ...
    
    denotation = ... # type: str
    
    @property
    def tensor_type(self) -> TypeProto.Tensor: ...
    
    @property
    def sequence_type(self) -> TypeProto.Sequence: ...
    
    @property
    def map_type(self) -> TypeProto.Map: ...
    
    @property
    def optional_type(self) -> TypeProto.Optional: ...
    
    @property
    def sparse_tensor_type(self) -> TypeProto.SparseTensor: ...
    
    @property
    def opaque_type(self) -> TypeProto.Opaque: ...
    
    def __init__(self,
        tensor_type : OptionalType[TypeProto.Tensor] = None,
        sequence_type : OptionalType[TypeProto.Sequence] = None,
        map_type : OptionalType[TypeProto.Map] = None,
        optional_type : OptionalType[TypeProto.Optional] = None,
        sparse_tensor_type : OptionalType[TypeProto.SparseTensor] = None,
        opaque_type : OptionalType[TypeProto.Opaque] = None,
        denotation : OptionalType[str] = None,
        ) -> None: ...
    @classmethod
    def FromString(cls, s: bytes) -> TypeProto: ...
    def MergeFrom(self, other_msg: Message) -> None: ...
    def CopyFrom(self, other_msg: Message) -> None: ...

class OperatorSetIdProto(Message):
    domain = ... # type: str
    version = ... # type: int
    
    def __init__(self,
        domain : OptionalType[str] = None,
        version : OptionalType[int] = None,
        ) -> None: ...
    @classmethod
    def FromString(cls, s: bytes) -> OperatorSetIdProto: ...
    def MergeFrom(self, other_msg: Message) -> None: ...
    def CopyFrom(self, other_msg: Message) -> None: ...

class FunctionProto(Message):
    name = ... # type: str
    input = ... # type: RepeatedScalarFieldContainer[str]
    output = ... # type: RepeatedScalarFieldContainer[str]
    attribute = ... # type: RepeatedScalarFieldContainer[str]
    doc_string = ... # type: str
    domain = ... # type: str
    
    @property
    def attribute_proto(self) -> RepeatedCompositeFieldContainer[AttributeProto]: ...
    
    @property
    def node(self) -> RepeatedCompositeFieldContainer[NodeProto]: ...
    
    @property
    def opset_import(self) -> RepeatedCompositeFieldContainer[OperatorSetIdProto]: ...
    
    def __init__(self,
        name : OptionalType[str] = None,
        input : OptionalType[Iterable[str]] = None,
        output : OptionalType[Iterable[str]] = None,
        attribute : OptionalType[Iterable[str]] = None,
        attribute_proto : OptionalType[Iterable[AttributeProto]] = None,
        node : OptionalType[Iterable[NodeProto]] = None,
        doc_string : OptionalType[str] = None,
        opset_import : OptionalType[Iterable[OperatorSetIdProto]] = None,
        domain : OptionalType[str] = None,
        ) -> None: ...
    @classmethod
    def FromString(cls, s: bytes) -> FunctionProto: ...
    def MergeFrom(self, other_msg: Message) -> None: ...
    def CopyFrom(self, other_msg: Message) -> None: ...
